var index = [{"name":"Charmonium:gg2doubleccbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor44","text":"Colour-singlet production of 3S1 charmonium state pairs via g g &rarr; ccbar[3S1(1)] ccbar[3S1(1)]. Code 421."},{"name":"StringPT:sigma","link":"Fragmentation.html#anchor24","text":"the width sigma in the fragmentation process."},{"name":"bool Particle::isFinal()","link":"ParticleProperties.html#anchor33","text":"true for a remaining particle, i.e. one with positive status code, else false. Thus, after an event has been fully generated, it separates the final-state particles from intermediate-stage ones. (If used earlier in the generation process, a particle then considered final may well decay later.)"},{"name":"double Particle::eT2()","link":"ParticleProperties.html#anchor48","text":"(squared) transverse energy, eT = e * sin(theta) = e * pT / pAbs."},{"name":"SUSYResonance:3BodyMatrixElement","link":"SUSYProcesses.html#anchor25","text":"When 'on', the spin-averaged, squared matrix element is used to sample the phase space for resonance decay.  Currently, only possible for a heavy neutralino decay to a light neutralino and a fermion-antifermion pair."},{"name":"virtual double MergingHooks::hardProcessME(const EventAMPERSAND  inEvent)","link":"CKKWLMerging.html#anchor28","text":"This routine will be supplied internally with the reconstructed lowest-multiplicity event. From this, it is possible to calculate the squared matrix element of the hard process, by using the information stored in the event record. The function should return a double value that corresponds to the matrix element at the phase space point given by the input event record. This number will then be multiplied to the product of splitting functions that define the probability of the current path of the parton shower history. In this way, the hard process configuration can be taken into account when choosing the parton shower history, which is, internally, used to generate the 'merging weight'."},{"name":"SoftQCD:doubleDiffractive","link":"QCDProcesses.html#anchor5","text":"Double diffractive scattering A B &rarr; X_1 X_2. See page on Diffraction for details. Code 105."},{"name":"Charmonium:O(3DJ)[3D1(1)]","link":"OniaProcesses.html#anchor34","text":"The color-singlet long-distance matrix elements <O[3D1(1)]> for the 3PJ charmonium states. For a 3DJ charmonium state where J is not 1 the long distance matrix element <O[3DJ(1)]> is calculated by (2J+1)<O[3D1(1)]/3> using leading order spin symmetry relations."},{"name":"Implement New Showers","link":"ImplementNewShowers.html","text":"Implement New Showers In case you want to replace the PYTHIA initial- and final-state showers by your own, it is possible but not trivial. The point is that multiparton interactions (MPI), initial-state radiation (ISR) and final-state radiation (FSR) in general appear in one single interleaved sequence of decreasing pT values. Therefore shower replacements would have to be able to play the game by such rules, as we will outline further below. Of course, this still leaves the field open exactly how to define what to mean by pT , how to handle recoil effects, how the colour flow is affected, and so on, so there is certainly room for alternative showers. A first example of a shower implemented within the PYTHIA context is VINCIA. For the moment we assume you want to keep the MPI part of the story unchanged, and make use of the existing beam-remnants (BR) machinery. If you want to replace both MPI, ISR, FSR and BR then you had better replace the whole PartonLevel module of the code. If, in addition, you want to produce your own hard processes, then you only need the hadron-level standalone part of the machinery. In order to write replacement codes for ISR and/or FSR it is useful to be aware of which information has to be shared between the different components, and which input/output structure is required of the relevant methods. For details, nothing beats studying the existing code. However, here we provide an overview, that should serve as a useful introduction. It should be noted that we here primarily address the problem in its full generality, with interleaved MPI, ISR and FSR. There exists an option TimeShower:interleave = off where only MPI and ISR would be interleaved and FSR be considered after these two, but still before BR. Most of the aspects described here would apply also for that case. By contrast, resonance decays are only considered after all the four above components, and timelike showers in those decays would never be interleaved with anything else, so are much simpler to administrate. Therefore the pythia.setShowerPtr( timesDecPtr, timesPtr, spacePtr) method allows two separate pointers to be set to instances of derived TimeShower classes. The first is only required to handle decays, say of Z^0 or Upsilon , with no dependence on beam remnants or ISR. The second, as well as spacePtr , has to handle the interleaved evolution of MPI, ISR and FSR. Therefore you are free to implement only the first, and let the PYTHIA default showers take care of the latter two. But, if you wanted to, you could also set timesDecPtr = 0 and only provide a timesPtr , or only a spacePtr. If your timelike shower does both cases, the first two pointers can agree. The only tiny point to take into account then is that init( beamAPtr, beamBPtr) is called twice, a first time to timesDecPtr with beam pointers 0, and a second time to timesPtr with nonvanishing beam pointers. The event record and associated information Obviously the main place for sharing information is the event record, specifically the Event event member of Pythia , passed around as a reference. It is assumed you already studied how it works, so here we only draw attention to a few aspects of special relevance. One basic principle is that existing partons should not be overwritten. Instead new partons should be created, even when a parton only receives a slightly shifted momentum and for the rest stays the same. Such 'carbon copies' by final-state branchings should be denoted by both daughter indices of the original parton pointing to the copy, and both mother indices of the copy to the original. If the copy instead is intended to represent an earlier step, e.g. in ISR backwards evolution, the role of mothers and daughters is interchanged. The event.copy( iCopy, newStatus) routine can take care of this tedious task; the sign of newStatus tells the program which case to assume. To make the event record legible it is essential that the status codes are selected appropriately to represent the reason why each new parton is added to the record. Also remember to change the status of a parton to be negative whenever an existing parton is replaced by a set of new daughter partons. Another important parton property is scale() , which does not appear in the normal event listing, but only if you use the extended Event:listScaleAndVertex = on option. This property is supposed to represent the production scale (in GeV) of a parton. In the current FSR and ISR algorithms it is used to restrict from above the allowed pT values for branchings of this particular parton. Beam remnants and other partons that should not radiate are assigned scale 0. Auxiliary to the event record proper is the PartonSystems class, that keep track of which partons belong together in the same scattering subsystem. This information must be kept up-to-date during the shower evolution. For initial-state showers it is also necessary to keep track of the partonic content extracted from the beams. This information is stored in the BeamParticle class. The TimeShower interface If you want to replace the TimeShower class this would involve replacing the virtual methods among the following ones. One of the major complications when combining fixed-order calculations with parton showers comes from constructing a parton shower history. This crucial step requires very precise knowledge of the functional forms of the evolution variable (e.g. transverse momentum), the auxiliary variable (e.g. an energy sharing variable), as well as the parton shower splitting probabilities and the (inverse) parton shower momentum mapping. All of these are readily available within the parton shower, but can be difficult to reconstruct, particularly if non-general improvements are included in the parton shower. To minimise code proliferation and bug potential, the timelike showers contain easy-access functions that can be loaded directly from PYTHIA's merging machinery. Note that within a new shower, you do not need to use these functions or all of the inputs transferred to these functions. Any dummy definition is acceptable. The easy-access functions are listed in the following. They use some common terminology, wherein iRad is the position in the event record of the radiating parton, iRec is the position of the recoiling partner of the dipole, which ensures overall energy and momentum conservation in the splitting, and iEmt is the position of the radiated parton, all after the splitting. (The ones before are stored in iRadBef and iRecBef , not used here.) Obviously the distinctions between iRad and iEmt , or between iRad and iRec , are a matter of choice. The SpaceShower interface If you want to replace the SpaceShower class this would involve replacing the virtual methods in the following. You will find that much of the story reminds of TimeShower above, and actually some cut-and-paste of text is involved. In some respects the description is simpler, since there are no special cases for resonance decays and non-interleaved evolution. Thus there is no correspondence to the TimeShower::shower(...) routine. As mentioned at the end of the section on timelike showers, it can be beneficial to merging and matching machinery of PYTHIA if some additional functionality is available. This in particular includes easy access to a) the evolution variable, b) the auxiliary (energy-sharing) variable, c) to parton shower splitting probabilities and d) to the (inverse) parton shower momentum mapping. Thus, as in the timelike case, it can be beneficial to define the functions"},{"name":"void LHAupLHEF::closeAllFiles()","link":"LesHouchesAccord.html#anchor84","text":"close main event file (LHEF) and, if present, separate header file."},{"name":"ExtraDimensionsTEV:mStar","link":"ExtraDimensionalProcesses.html#anchor41","text":"The KK mass m^* , given by the inverse of the single extra dimension radius."},{"name":"JetMatching:jetMatch","link":"JetMatching.html#anchor17","text":"Criteria for matching a clustered jet to a parton. This option can be used with both the CellJet and SlowJet algorithms. The delta R between each parton and jet is taken, and the minimal value compared against coneMatchLight * coneRadius for light jets or coneMatchHeavy * coneRadiusHeavy for heavy jets. Note that by default coneRadiusHeavy = coneRadius , see below. If below this value, the parton and jet are considered to match. With CellJet , the delta R measure is in (eta, phi) , while with SlowJet it is in (y, phi). This option can only be used with the SlowJet algorithm. The hard partons are inserted into the parton level event as 'ghost' particles, but at the correct (y, phi) position. If this particle is then clustered into a jet, it is considered a match."},{"name":"double ParticleData::charge(int id)","link":"ParticleDataScheme.html#anchor36","text":"the electrical charge of a particle, equal to chargeType(id)/3."},{"name":"Bottomonium:gg2bbbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor64","text":"Colour-singlet production of 3PJ bottomonium states via g g &rarr; bbbar[3PJ(1)] g. Code 511."},{"name":"TimeShower:nMaxGlobalBranch","link":"TimelikeShowers.html#anchor23","text":"The maximum number of splittings in the final state for which the next final-state emission can be performed with the global recoil strategy. This number has to be set if TimeShower:globalRecoilMode = 1 or TimeShower:globalRecoilMode = 2"},{"name":"Vec4 Particle::vProd()","link":"ParticleProperties.html#anchor21","text":"The production vertex four-vector. Note that the components of a Vec4 are named px(), py(), pz() and e() which of course then should be reinterpreted as above."},{"name":"SUSY:qqbar2chi+-gluino","link":"SUSYProcesses.html#anchor21","text":"Associated chargino-gluino production by quark-antiquark annihilation. The cross section expressions follow Fuk11. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: small differences between this implementation and PYTHIA 6 arise due to slightly different treatments of the weak mixing angle, which is fixed in PYTHIA 6, while it is computed from the SLHA input in PYTHIA 8; see SUSY:sin2thetaWMode above.)"},{"name":"A Second Hard Process","link":"ASecondHardProcess.html","text":"A Second Hard Process When you have selected a set of hard processes for hadron beams, the multiparton interactions framework can add further interactions to build up a realistic underlying event. These further interactions can come from a wide variety of processes, and will occasionally be quite hard. They do represent a realistic random mix, however, which means one cannot predetermine what will happen. Occasionally there may be cases where one wants to specify also the second hard interaction rather precisely. The options on this page allow you to do precisely that. Process Selection In principle the whole process selection allowed for the first process could be repeated for the second one. However, this would probably be overkill. Therefore here a more limited set of prepackaged process collections are made available, that can then be further combined at will. Since the description is almost completely symmetric between the first and the second process, you always have the possibility to pick one of the two processes according to the complete list of possibilities. Here comes the list of allowed sets of processes, to combine at will: A further process collection comes with a warning flag: Cuts and scales The second hard process obeys exactly the same selection rules for phase space cuts and couplings and scales as the first one does. Specifically, a pTmin cut for 2 &rarr; 2 processes would apply to the first and the second hard process alike, and ballpark half of the time the second could be generated with a larger pT than the first. (Exact numbers depending on the relative shape of the two cross sections.) That is, first and second is only used as an administrative distinction between the two, not as a physics ordering one. Optionally it is possible to pick the mass and pT phase space cuts separately for the second hard interaction. The main application presumably would be to allow a second process that is softer than the first, but still hard. But one is also free to make the second process harder than the first, if desired. So long as the two pT (or mass) ranges overlap the ordering will not be the same in all events, however. Cross-section calculation As an introduction, a brief reminder of Poissonian statistics. Assume a stochastic process in time, for now not necessarily a high-energy physics one, where the probability for an event to occur at any given time is independent of what happens at other times. Then the probability for n events to occur in a finite time interval is P_n = <n>^n exp(-<n>) / n! where <n> is the average number of events. If this number is small we can approximate exp(-<n>) = 1 , so that P_1 = <n> and P_2 = <n>^2 / 2 = P_1^2 / 2. Now further assume that the events actually are of two different kinds a and b , occurring independently of each other, such that <n> = <n_a> + <n_b>. It then follows that the probability of having one event of type a (or b ) and nothing else is P_1a = <n_a> (or P_1b = <n_b> ). From P_2 = (<n_a> + <n_b&gt)^2 / 2 = (P_1a + P_1b)^2 / 2 = (P_1a^2 + 2 P_1a P_1b + P_1b^2) / 2 it is easy to read off that the probability to have exactly two events of kind a and none of b is P_2aa = P_1a^2 / 2 whereas that of having one a and one b is P_2ab = P_1a P_1b. Note that the former, with two identical events, contains a factor 1/2 while the latter, with two different ones, does not. If viewed in a time-ordered sense, the difference is that the latter can be obtained two ways, either first an a and then a b or else first a b and then an a. To translate this language into cross-sections for high-energy events, we assume that interactions can occur at different pT values independently of each other inside inelastic nondiffractive (sometimes equated with 'minbias') events. Then the above probabilities translate into P_n = sigma_n / sigma_ND where sigma_ND is the total nondiffractive cross section. Again we want to assume that exp(-<n>) is close to unity, i.e. that the total hard cross section above pTmin is much smaller than sigma_ND. The hard cross section is dominated by QCD jet production, and a reasonable precaution is to require a pTmin of at least 20 GeV at LHC energies. (For 2 &rarr; 1 processes such as q qbar &rarr; gamma^*/Z^0 (&rarr; f fbar) one can instead make a similar cut on mass.) Then the generic equation P_2 = P_1^2 / 2 translates into sigma_2/sigma_ND = (sigma_1 / sigma_ND)^2 / 2 or sigma_2 = sigma_1^2 / (2 sigma_ND). Again different processes a, b, c, ... contribute, and by the same reasoning we obtain sigma_2aa = sigma_1a^2 / (2 sigma_ND) , sigma_2ab = sigma_1a sigma_1b / sigma_ND , and so on. There is one important correction to this picture: all collisions do no occur under equal conditions. Some are more central in impact parameter, others more peripheral. This leads to a further element of variability: central collisions are likely to have more activity than the average, peripheral less. Integrated over impact parameter standard cross sections are recovered, but correlations are affected by a 'trigger bias' effect: if you select for events with a hard process you favour events at small impact parameter which have above-average activity, and therefore also increased chance for further interactions. (In PYTHIA this is the origin of the 'pedestal effect', i.e. that events with a hard interaction have more underlying activity than the level found in minimum-bias events.) When you specify a matter overlap profile in the multiparton-interactions scenario, such an enhancement/depletion factor f_impact is chosen event-by-event and can be averaged during the course of the run. As an example, the double Gaussian form used in Tune A gives approximately <f_impact> = 2.5. In general, the more uneven the distribution the higher the <f_impact>. Also the pT0 parameter value has an impact, even if it is less important over a realistic range of values, although it implies that <f_impact> is energy-dependent. The origin of this effect is as follows. A lower pT0 implies more MPI activity at all impact parameters, so that the nondiffractive cross section sigma_ND increases, or equivalently the proton size. But if sigma_ND is fixed by data then the input radius of the matter overlap profile (not explicitly specified but implicitly adjusted at initialization) has to be shrunk  so that the output value can stay constant. This means that the proton matter is more closely packed and therefore <f_impact> goes up. The above equations therefore have to be modified to sigma_2aa = <f_impact> sigma_1a^2 / (2 sigma_ND) , sigma_2ab = <f_impact> sigma_1a sigma_1b / sigma_ND. Experimentalists often instead use the notation sigma_2ab = sigma_1a sigma_1b / sigma_eff , from which we see that PYTHIA 'predicts' sigma_eff = sigma_ND / <f_impact>. When the generation of multiparton interactions is switched off it is not possible to calculate <f_impact> and therefore it is set to unity. When this recipe is to be applied to calculate actual cross sections, it is useful to distinguish three cases, depending on which set of processes are selected to study for the first and second interaction. (1) The processes a for the first interaction and b for the second one have no overlap at all. For instance, the first could be TwoJets and the second TwoPhotons. In that case, the two interactions can be selected independently, and cross sections tabulated for each separate subprocess in the two above classes. At the end of the run, the cross sections in a should be multiplied by <f_impact> sigma_1b / sigma_ND to bring them to the correct overall level, and those in b by <f_impact> sigma_1a / sigma_ND. (2) Exactly the same processes a are selected for the first and second interaction. In that case it works as above, with a = b , and it is only necessary to multiply by an additional factor 1/2. A compensating factor of 2 is automatically obtained for picking two different subprocesses, e.g. if TwoJets is selected for both interactions, then the combination of the two subprocesses q qbar &rarr; g g and g g &rarr; g g can trivially be obtained two ways. (3) The list of subprocesses partly but not completely overlap. For instance, the first process is allowed to contain a or c and the second b or c , where there is no overlap between a and b. Then, when an independent selection for the first and second interaction both pick one of the subprocesses in c , half of those events have to be thrown, and the stored cross section reduced accordingly. Considering the four possible combinations of first and second process, this gives a sigma'_1 = sigma_1a + sigma_1c * (sigma_2b + sigma_2c/2) / (sigma_2b + sigma_2c) with the factor 1/2 for the sigma_1c sigma_2c term. At the end of the day, this sigma'_1 should be multiplied by the normalization factor f_1norm = <f_impact> (sigma_2b + sigma_2c) / sigma_ND here without a factor 1/2 (or else it would have been double-counted). This gives the correct (sigma_2b + sigma_2c) * sigma'_1 = sigma_1a * sigma_2b + sigma_1a * sigma_2c + sigma_1c * sigma_2b + sigma_1c * sigma_2c/2 The second interaction can be handled in exact analogy. For the considerations above it is assumed that the phase space cuts are the same for the two processes. It is possible to set the mass and transverse momentum cuts differently, however. This changes nothing for processes that already are different. For two collisions of the same type it is partly a matter of interpretation what is intended. If we consider the case of the same process in two non-overlapping phase space regions, most likely we want to consider them as separate processes, in the sense that we expect a factor 2 relative to Poissonian statistics from either of the two hardest processes populating either of the two phase space regions. In total we are therefore lead to adopt the same strategy as in case (3) above: only in the overlapping part of the two allowed phase space regions could two processes be identical and thus appear with a 1/2 factor, elsewhere the two processes are never identical and do not include the 1/2 factor. We reiterate, however, that the case of partly but not completely overlapping phase space regions for one and the same process is tricky, and not to be used without prior deliberation. The listing obtained with the pythia.stat() already contain these corrections factors, i.e. cross sections are for the occurrence of two interactions of the specified kinds. There is not a full tabulation of the matrix of all the possible combinations of a specific first process together with a specific second one (but the information is there for the user to do that, if desired). Instead pythia.stat() shows this matrix projected onto the set of processes and associated cross sections for the first and the second interaction, respectively. Up to statistical fluctuations, these two sections of the pythia.stat() listing both add up to the same total cross section for the event sample. There is a further special feature to be noted for this listing, and that is the difference between the number of 'selected' events and the number of 'accepted' ones. Here is how that comes about. Originally the first and second process are selected completely independently. The generation (in)efficiency is reflected in the different number of initially tried events for the first and second process, leading to the same number of selected events. While acceptable on their own, the combination of the two processes may be unacceptable, however. It may be that the two processes added together use more energy-momentum than kinematically allowed, or, even if not, are disfavoured when the PYTHIA approach to provide correlated parton densities is applied. Alternatively, referring to case (3) above, it may be because half of the events should be thrown for identical processes. Taken together, it is these effects that reduced the event number from 'selected' to 'accepted'. (A further reduction may occur if a user hook rejects some events.) It is allowed to use external Les Houches Accord input for the hardest process, and then pick an internal one for the second hardest. In this case PYTHIA does not have access to your thinking concerning the external process, and cannot know whether it overlaps with the internal or not. (External events q qbar' &rarr; e+ nu_e could agree with the internal W ones, or be a W' resonance in a BSM scenario, to give one example.) Therefore the combined cross section is always based on the scenario (1) above. Corrections for correlated parton densities are included also in this case, however. That is, an external event that takes a large fraction of the incoming beam momenta stands a fair chance of being rejected when it has to be combined with another hard process. For this reason the 'selected' and 'accepted' event numbers are likely to disagree. In the cross section calculation above, the sigma'_1 cross sections are based on the number of accepted events, while the f_1norm factor is evaluated based on the cross sections for selected events. That way the suppression by correlations between the two processes does not get to be double-counted. The pythia.stat() listing contains two final lines, indicating the summed cross sections sigma_1sum and sigma_2sum for the first and second set of processes, at the 'selected' stage above, plus information on the sigma_ND and <f_impact> used. The total cross section generated is related to this by <f_impact> * (sigma_1sum * sigma_2sum / sigma_ND) * (n_accepted / n_selected) with an additional factor of 1/2 for case 2 above. The error quoted for the cross section of a process is a combination in quadrature of the error on this process alone with the error on the normalization factor, including the error on <f_impact>. As always it is a purely statistical one and of course hides considerably bigger systematic uncertainties. Warning: the calculational machinery above has not (yet) been implemented for the case that the two interactions are to be associated with different impact-parameter profiles, as is the case for MultipartonInteractions:bProfile = 4 , i.e. when the radius depends on the x value. Results for the double cross section therefore cannot be trusted in this case. Event information Normally the process event record only contains the hardest interaction, but in this case also the second hardest is stored there. If both of them are 2 &rarr; 2 ones, the first would be stored in lines 3 - 6 and the second in 7 - 10. For both, status codes 21 - 29 would be used, as for a hardest process. Any resonance decay chains would occur after the two main processes, to allow normal parsing. The beams in 1 and 2 only appear in one copy. This structure is echoed in the full event event record. Most of the properties accessible by the pythia.info methods refer to the first process, whether that happens to be the hardest or not. The code and pT scale of the second process are accessible by the info.codeMPI(1) and info.pTMPI(1) , however. The sigmaGen() and sigmaErr() methods provide the cross section and its error for the event sample as a whole, combining the information from the two hard processes as described above. In particular, the former should be used to give the weight of the generated event sample. The statistical error estimate is somewhat cruder and gives a larger value than the subprocess-by-subprocess one  employed in pythia.stat() , but this number is anyway less relevant, since systematical errors are likely to dominate."},{"name":"JetMatching:coneRadiusHeavy","link":"JetMatching.html#anchor19","text":"The coneRadiusHeavy parameter used when JetMatching:jetMatch = 1. When assigned a negative value, the value of JetMatching:coneRadius is used."},{"name":"StringFlav:mesonUDvector","link":"FlavourSelection.html#anchor6","text":"the relative production ratio vector/pseudoscalar for light ( u , d ) mesons."},{"name":"friend Vec4 operator-(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor54","text":"subtract two four-vectors."},{"name":"StringFragmentation:eBothLeftJunction","link":"Fragmentation.html#anchor43","text":"Retry (up to 10 times) when the first two considered strings in to a junction both have a remaining energy (in the junction rest frame) above this number."},{"name":"void Info::setCounter(int i, int value = 0)","link":"EventInformation.html#anchor106","text":"set the above counters to a given value. Only to be used by you for the unassigned counters 40 - 49. the counter number, see above. set the counter to this number; normally the default value is what you want."},{"name":"HistAMPERSANDamp; Hist::operator*=(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor25","text":""},{"name":"int SigmaProcess::gmZmode()","link":"SemiInternalProcesses.html#anchor30","text":"allows a possibility to override the global mode WeakZ0:gmZmode for a specific process. The global mode normally is used to switch off parts of the gamma^*/Z^0 propagator for test purposes. The above local mode is useful for processes where a Z^0 really is that and nothing more, such as q qbar &rarr; H^0 Z^0. The default value -1 returned by gmZmode() ensures that the global mode is used, while 0 gives full gamma^*/Z^0 interference, 1 gamma^* only and 2 Z^0 only."},{"name":"double ParticleData::resWidth(int id, double mHat,  int idInFlav = 0, bool openOnly = false, bool setBR = false)","link":"ParticleDataScheme.html#anchor82","text":"calculate the total with for a resonance of a given current mass, optionally including coupling to incoming flavour state (consider the gamma*/Z^0 combination), optionally excluding decay channels that have been closed by the user, and optionally storing the results in the normal decay table."},{"name":"LeftRightSymmmetry:lgm2HLmu","link":"LeftRightSymmetryProcesses.html#anchor6","text":"Scatterings l_i gamma &rarr; H_L^-- mu^+. Code 3123."},{"name":"double LHAup::xErr(i)","link":"LesHouchesAccord.html#anchor25","text":""},{"name":"Main:spareMode1","link":"MainProgramSettings.html#anchor31","text":""},{"name":"Main:spareMode2","link":"MainProgramSettings.html#anchor32","text":""},{"name":"Main:spareMode3","link":"MainProgramSettings.html#anchor33","text":""},{"name":"TimeShower:weightGluonToQuark","link":"TimelikeShowers.html#anchor33","text":"Different options to assign kinematics distributions and weights for g &rarr; q qbar branchings, notably for charm and bottom quarks. These options also have the corresponding effect on gamma &rarr; f fbar branchings. The rationale for the options is described in this note. Notation: r_q = m_q^2/m_qq^2 , beta = sqrt(1 - 4r_q) , with m_q the quark mass and m_qq the q qbar pair invariant mass. The scale factor k is described below, TimeShower:scaleGluonToQuark. same splitting kernel (1/2) (z^2 + (1-z)^2) for massive as massless quarks, only with an extra beta phase space factor. a splitting kernel (beta/2) (z^2 + (1-z)^2 + 8r_q z(1-z)). a splitting kernel z^2 + (1-z)^2 + 8r_q z(1-z) , normalized so that the z -integrated rate is (beta/3) (1 + r/2). same as 3, but additionally a suppression factor (1 - m_qq^2/m_dipole^2)^3 , which reduces the rate of high-mass q qbar pairs. same as 1, but reweighted to an alpha_s(k m_qq^2) rather than the normal alpha_s(pT^2). same as 2, but reweighted to an alpha_s(k m_qq^2) rather than the normal alpha_s(pT^2). same as 3, but reweighted to an alpha_s(k m_qq^2) rather than the normal alpha_s(pT^2). same as 4, but reweighted to an alpha_s(k m_qq^2) rather than the normal alpha_s(pT^2)."},{"name":"void LHAup::setIdX(int id1, int id2, double x1, double x2)","link":"LesHouchesAccord.html#anchor53","text":""},{"name":"SpaceShower:pTdampFudge","link":"SpacelikeShowers.html#anchor5","text":"In cases 1 and 2 above, where a dampening is imposed at around the factorization or renormalization scale, respectively, this allows the pT scale of dampening of radiation by a half to be shifted by this factor relative to the default Q_fac or Q_ren. This number ought to be in the neighbourhood of unity, but variations away from this value could do better in some processes."},{"name":"Zprime:vnue","link":"NewGaugeBosonProcesses.html#anchor10","text":"vector coupling of nu_e neutrinos."},{"name":"LeftRightSymmmetry:ffbar2ZR","link":"LeftRightSymmetryProcesses.html#anchor2","text":"Scatterings f fbar &rarr; Z_R^0. Code 3101."},{"name":"Photon:Wmin","link":"Photoproduction.html#anchor5","text":"Lower limit for invariant mass of gamma-gamma system in GeV. In lepton-hadron collisions W corresponds to invariant mass of photon-hadron system."},{"name":"double CoupSM::alphaEM(double scale2)","link":"StandardModelParameters.html#anchor24","text":"the alpha_em value at the quadratic scale scale2."},{"name":"Compositeness Processes","link":"CompositenessProcesses.html","text":"Compositeness Processes Compositeness scenarios may give rise to sharp resonances of excited quarks and leptons. An excited copy of the first generation is implemented, consisting of spin 1/2 particles. The possibility of contact interactions between SM fermions is also implemented in the context of 2 &rarr; 2 quark or fermion-lepton scattering. Related to excited fermions, the current implementation contains gauge interaction production by quark-gluon fusion or lepton-photon fusion and contact interaction production by quark-quark or quark-antiquark scattering. For both the 2 &rarr; 1 and 2 &rarr; 2 processes a non-trivial angular dependence is included in the decay, however, only decays into gauge bosons are supported, i.e. not decays through contact interactions. In additions to the compositeness scale and couplings listed below, you are expected to change the excited-fermion masses in accordance with what is desired. See Bau90 for conventions. The contact interactions are implemented according to Eic83. The processes include the SM contributions as well as interference. For this reason the processes below converge toward the SM equivalents when the contact interaction contributions are close to zero, e.g. HardQCD:qq2qq and HardQCD:qqbar2qqbarNew in the case of quark scattering. It should also be noted that the gamma*/Z/Z' production process available with NewGaugeBoson:ffbar2gmZZprime is prepared for pair-production of excited quarks and leptons, assuming the same gauge couplings as for the non-excited fermions. What is missing is the actual decay channels in the list of Z' decay modes, which have to be added by hand, e.g. by 32:addChannel = 1 1. 100 4000001 -4000001 You can use Zprime:gmZmode to decide which gauge boson propagators actually are included in the simulation, and thus e.g. switch off the Z' part of the propagator. You may also want to switch off other decay channels and set the minimal mass to be at the threshold for the studied pair production (or suitably below it, if the excited fermions have a non-negligible width). Excited fermions, production processes A few different production processes have been implemented, which normally would not overlap and therefore could be run together. Excited fermions, parameters The basic couplings of the model are Contact interactions, production processes The processes including contact interactions are Contact interactions, parameters"},{"name":"Jet Finders","link":"JetFinders.html","text":"Jet Finders Pythia comes with three built-in jet finders , ClusterJet for e^+e^- events and SlowJet and CellJet for hadron collider ones. Especially the latter is not so well matched to the standards of its field, however. (But it is closely related to the anti- kT algorithm, so is also not completely disconnected Cac08 .) SlowJet can do jet finding according to the current-day kT , Cambridge/Aachen and anti- kT algorithms. It can be run in two modes. The original one is a native implementation which, as the name indicates, is rather slow. However, with the release of the fjcore code from FastJet Cac06, Cac12 , the default mode has become to use the fjcore methods. This is transparent to the user. FastJet SlowJet does not exhaust all the posssibilities of the fjcore code, so users are welcome to extend on the existing functionality by a direct usage of the fjcore methods. Missing from fjcore is a number of aspects, such as jet areas functionality, background estimation, access to other algorithms via plugins, interface to CGAL and tools such as filters and taggers. Therefore, for more sophisticated jet studies the complete FastJet package needs to be linked. This is foreseen in the configure file in the examples subdirectory, and the main71.cc and main72.cc programs contain examples how it can be used with Pythia events. (Even if these examples do not go beyond the functionality that SlowJet can offer.) The latter program makes use of the include/Pythia8Plugins/FastJet3.h header file, contributed by Gavin Salam. This allows simple input of a Pythia particle into a FastJet one, either retaining only the four-momentum or the full particle information. Thereby more sophisticated selectors become possible at the FastJet level. This code could be duplicated, with trivial modifications, to augment the fjcore package functionality in an identical manner, should the need arise."},{"name":"double CoupSM::Lambda3()","link":"StandardModelParameters.html#anchor21","text":""},{"name":"Charmonium:O(3PJ)[3S1(8)]","link":"OniaProcesses.html#anchor26","text":"The color-singlet long-distance matrix elements <O[3S1(8)]> for the 3PJ charmonium states."},{"name":"ExtraDimensionsLED:nQuarkNew","link":"ExtraDimensionalProcesses.html#anchor68","text":"Number of allowed outgoing new quark flavours in the above q qbar &rarr; (LED G*) &rarr; q' qbar' and g g &rarr; (LED G*) &rarr; q' qbar' processes. Similar to HardQCD:nQuarkNew for the QCD processes."},{"name":"StringZ:rFactC","link":"Fragmentation.html#anchor5","text":"r_c , i.e. the above parameter for c quarks."},{"name":"StringZ:rFactB","link":"Fragmentation.html#anchor6","text":"r_b , i.e. the above parameter for b quarks."},{"name":"StringZ:rFactH","link":"Fragmentation.html#anchor7","text":"r_h , i.e. the above parameter for heavier hypothetical quarks, or in general any new coloured particle long-lived enough to hadronize."},{"name":"Init:showChangedSettings","link":"MainProgramSettings.html#anchor3","text":"Print a list of the changed flag/mode/parameter/word settings."},{"name":"void LHAup::setXMax( int i, double xMax)","link":"LesHouchesAccord.html#anchor11","text":"update the xMax value of the i 'th process added with addProcess method."},{"name":"virtual bool UserHooks::doVetoResonanceDecays(EventAMPERSAND process)","link":"UserHooks.html#anchor37","text":"can optionally be called, as described above. You can study the process event record of the hard process. Based on that you can decide whether to reject the sequence of resonance decays that was not already fixed by the production step of the hard process (which can vary depending on how a process has been set up, see above). If you veto, then a new resonance decay sequence is selected, but the production step remains unchanged. The cross section remains unaffected by this veto, for better or worse. Warning: Normally you should not modify the process event record. However, as an extreme measure, parts or the complete decay chain could be overwritten. If so, be very careful."},{"name":"virtual bool UserHooks::doVetoISREmission(  int sizeOld, const EventAMPERSAND event, int iSys)","link":"UserHooks.html#anchor24","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the emission, true, or not, false. If you veto, then the latest emission is removed from the event record. In either case the evolution of the shower will continue from the point where it was left off. is the size of the event record before the latest emission was added to it. It will also become the new size if the emission is vetoed. the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent emission, which are stored in entries from sizeOld through event.size() - 1 inclusive. If you veto the emission these entries will be removed, and the history info in the remaining partons will be restored to a state as if the emission had never occurred. the system where the radiation occurs, according to Parton Systems."},{"name":"int MergingHooks::nHardInLeptons()","link":"CKKWLMerging.html#anchor22","text":"Returns the number of incoming leptons in the hard core process."},{"name":"CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0)","link":"EventAnalysis.html#anchor28","text":"create a CellJet instance, where the maximum +-pseudorapidity that the detector is assumed to cover. the number of equal-sized bins that the +-etaMax range is assumed to be divided into. the number of equal-sized bins that the phi range +-pi is assumed to be divided into. tells which particles are analyzed, all final-state particles, all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the isVisible() particle method), and only charged final-state particles. strategy to smear the actual eT bin by bin, no smearing, smear the eT according to a Gaussian with width resolution * sqrt(eT) , with the Gaussian truncated at 0 and upperCut * eT , smear the e = eT * cosh(eta) according to a Gaussian with width resolution * sqrt(e) , with the Gaussian truncated at 0 and upperCut * e. see above. see above. completely neglect all bins with an eT < threshold. the random-number generator used to select the smearing described above. Must be handed in for smearing to be possible. If your Pythia class instance is named pythia , then &pythia.rndm would be the logical choice."},{"name":"FourthBottom:ffbar2bPrimeqbar(s:W)","link":"FourthGenerationProcesses.html#anchor6","text":"Scatterings f fbar' &rarr; b' qbar'' by s -channel exchange of a W^+- boson. Here q'' is either u or c. Code 805."},{"name":"Beams:pzA","link":"BeamParameters.html#anchor9","text":"The p_z component of the first incoming particle, to be set if Beams:frameType = 3."},{"name":"BoseEinstein:widthSep","link":"BoseEinsteinEffects.html#anchor6","text":"Particle species with a width above this value (in GeV) are assumed to be so short-lived that they decay before Bose-Einstein effects are considered, while otherwise they do not. In the former case the decay products thus can obtain shifted momenta, in the latter not. The default has been picked such that both rho and K^* decay products would be modified."},{"name":"Beams:pzB","link":"BeamParameters.html#anchor12","text":"The p_z component of the second incoming particle, to be set if Beams:frameType = 3."},{"name":"virtual bool canChangeFragPar()","link":"UserHooks.html#anchor47","text":"In the base class this method returns false. If you redefine it to return true, it will enable the methods doChangeFragPar(...) and doVetoFragmentation(...)."},{"name":"HepMC Interface","link":"HepMCInterface.html","text":"HepMC Interface An interface to the HepMC Dob01 standard event record format has been provided by M. Kirsanov. The code is stored in include/Pythia8Plugins/HepMC2.h. To use it, the relevant libraries need to be linked, as explained in the README file. Only version 2.06 (or later) of HepMC is supported, by agreement with the LHC experimental community. The (simple) procedure to translate PYTHIA 8 events into HepMC ones is illustrated in the main41.cc , main42.cc and main43.cc main programs. At the core is a call to the HepMC::Pythia8ToHepMC::fill_next_event( pythia, hepmcevt, ievnum = -1) which takes a reference of the generator object and uses it, on the one hand, to read out and convert the event record in pythia.event and, on the other hand, to extract and store parton-density (PDF), cross section and other information for the hard subprocess from pythia.info. There is also an alternative form that does not requires access to the full pythia object, but only the event record, at the expense of a reduced information storage, see below. While PYTHIA always stores momenta in units of GeV, with c = 1 , HepMC nowadays can be built either for MeV or GeV as default, a choice that can then be overridden on an event-by-event basis, see e.g. the main41.cc code. When filling the HepMC event record, PYTHIA will convert to the unit specified for the current HepMC event record. Also for length units there are choices, and again the PYTHIA interface will convert to the units set for the HepMC event record. Here the mm choice of PYTHIA seems to be shared by most other programs, and is HepMC default. The status code is now based on the new standard introduced for HepMC 2.05, see the Event::statusHepMC(...) conversion routine for details. The current values from pythia.info.sigmaGen() and pythia.info.sigmaErr() are stored for each event, multiplied by 10^9 to convert from mb to pb. Note that PYTHIA improves its accuracy by Monte Carlo integration in the course of the run, so the values associated with the last generated event should be the most accurate ones. If events also come with a dimensional weight, like in some Les Houches strategies, this weight is in units of pb. The public methods Here comes a complete list of all public methods of the Pythia8ToHepMC class in the HepMC ( not Pythia8 !) namespace. The following paired methods can be used to set and get the status of some switches that modify the behaviour of the conversion routine. The set methods have the same default input values as the internal initialization ones, so that a call without an argument (re)stores the default."},{"name":"SUSY:sin2thetaWMode","link":"SUSYProcesses.html#anchor6","text":"The value of sin2(thetaW) should be taken from SM value, defined at M_Z , taken from PYTHIA's StandardModel:sin2thetaW parameter. SUSY value, defined at M_SUSY , derived from the running gauge couplings in BLOCK GAUGE in the SLHA file. Note: if no such block is present in the input file, this option will default back to option 1 above, i.e., the SM value. Pole value, defined by 1 - M_W^2/M_Z^2 , using the pole masses stored in the SLHA BLOCK MASS , or, alternatively, PYTHIA's internal pole masses if no such block is present."},{"name":"Hist::Hist()","link":"Histograms.html#anchor1","text":"declare a histogram, but does not define it."},{"name":"ExtraDimensionsUnpart:ffbar2Ugamma","link":"ExtraDimensionalProcesses.html#anchor75","text":"Scatterings f fbar &rarr; U gamma. This process corresponds to the photon limit of the U Z process, as described in Ask09. Code 5042."},{"name":"HiddenValley:ffbar2MUvMUvbar","link":"HiddenValleyProcesses.html#anchor28","text":"Pair production f fbar &rarr; MUv MUvbar via intermediate gamma*/Z^*. Code 4933."},{"name":"Diffraction:MBRdyminSigSD","link":"Diffraction.html#anchor15","text":""},{"name":"Vec4 CellJet::pMassless(int i)","link":"EventAnalysis.html#anchor37","text":"gives a Vec4 corresponding to the four-momentum defined by the eT and the weighted center of the i 'th jet,"},{"name":"Next:numberShowInfo","link":"MainProgramSettings.html#anchor11","text":"The number of events to list the Info information for, where relevant."},{"name":"PDF:GammaSet","link":"PDFSelection.html#anchor17","text":"Parton densities that can be used for resolved photon beams. CJKL, based on Cor03 but the rescaling for heavy quarks due to kinematic constraints in DIS is undone to obtain correct behaviour for photon-photon/hadron collisions."},{"name":"ContactInteractions:QCffbar2tautaubar","link":"CompositenessProcesses.html#anchor36","text":"Scatterings f fbar &rarr; tau- tau+ including contact interactions. Code 4205."},{"name":"double Info::y()","link":"EventInformation.html#anchor34","text":""},{"name":"double Info::x1pdf()","link":"EventInformation.html#anchor40","text":""},{"name":"Diffraction:MBRdyminDD","link":"Diffraction.html#anchor13","text":""},{"name":"Pythia::Pythia(SettingsAMPERSAND settingsIn,  ParticleDataAMPERSAND particleDataIn, bool printBanner = true)","link":"ProgramFlow.html#anchor2","text":"creates an instance of the Pythia event generators, and sets initial default values, notably for all settings and particle data. This option is intended for runs with multiple Pythia instances, where only the first one needs to read the xmldoc files, while subsequent ones can 'inherit' this information. can be set false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia instances, where output needs to be restricted."},{"name":"SigmaProcess:alphaSvalue","link":"CouplingsAndScales.html#anchor1","text":"The alpha_strong value at scale M_Z^2."},{"name":"SoftQCD:inelastic","link":"QCDProcesses.html#anchor7","text":"All of the above processes, except for elastic. Codes 101, 103, 104, 105 and 106."},{"name":"void SlowJet::removeJet(int i)","link":"EventAnalysis.html#anchor55","text":"removes the i 'th jet,"},{"name":"HiggsBSM:qg2H1q","link":"HiggsProcesses.html#anchor63","text":"Scattering q g &rarr; h^0 q. This process gives first-order corrections to the f fbar &rarr; h^0 one above, and should only be used to study  the high- pT tail, while f fbar &rarr; h^0 should be used for inclusive production. Only the dominant c and b contributions are included, and generated separately for technical reasons. Note that another first-order process would be q qbar &rarr; h^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any b at large pT , however, so is less interesting for many applications. Code 1011."},{"name":"void ParticleDataEntry::setTau0(double tau0)","link":"ParticleDataScheme.html#anchor120","text":""},{"name":"pairAMPERSANDlt;double, doubleAMPERSANDgt; Rndm::gauss2()","link":"RandomNumbers.html#anchor9","text":"generate a pair of random numbers according to exp( -(x^2 + y^2) / 2). Is faster than two calls to gauss()."},{"name":"double Particle::theta()","link":"ParticleProperties.html#anchor49","text":""},{"name":"RHadrons:mCollapse","link":"RHadrons.html#anchor10","text":"A colour singlet system with an invariant mass less than this amount, above the R-hadron mass with the given flavour content, is assumed to collapse to this single R-hadron, whereas a full fragmentation handling is applied above this mass."},{"name":"HardQCD:nQuarkNew","link":"QCDProcesses.html#anchor15","text":"Number of allowed outgoing new quark flavours in the above g g &rarr; q qbar and q qbar &rarr; q' qbar' processes, where quarks are treated as massless in the matrix-element expressions (but correctly in the phase space). It is thus assumed that c cbar and b bbar are added separately with masses taken into account, using the processes below. A change to 4 would also include c cbar in the massless approximation, etc. In order to avoid double-counting the processes below should then not be used simultaneously."},{"name":"double Info::Q2GammaA()","link":"EventInformation.html#anchor68","text":""},{"name":"SpaceShower:phiPolAsym","link":"SpacelikeShowers.html#anchor29","text":"Azimuthal asymmetry induced by gluon polarization; on/off = true/false."},{"name":"double ParticleDataEntry::tau0()","link":"ParticleDataScheme.html#anchor121","text":"the nominal proper lifetime tau_0 (in mm/c)."},{"name":"Merging:unorderedASscalePrescrip","link":"CKKWLMerging.html#anchor46","text":"Prescription which scale to use to evaluate &alpha; s weight for  splittings in a sequence of splittings which are not ordered in evolution pT. Use the combined splitting scale as argument in &alpha; s , for both splittings. Use the true reconstructed scale  as as argument in &alpha; s , for each splitting separately."},{"name":"int Particle::statusHepMC()","link":"ParticleProperties.html#anchor101","text":"returns the status code according to the HepMC conventions agreed in February 2009. This convention does not preserve the full information provided by the internal PYTHIA status code, as obtained by Particle::status() , but comes reasonably close. The allowed output values are: 0 : an empty entry, with no meaningful information and therefore to be skipped unconditionally; 1 : a final-state particle, i.e. a particle that is not decayed further by the generator (may also include unstable particles that are to be decayed later, as part of the detector simulation); 2 : a decayed Standard Model hadron or tau or mu lepton, excepting virtual intermediate states thereof (i.e. the particle must undergo a normal decay, not e.g. a shower branching); 3 : a documentation entry (not used in PYTHIA); 4 : an incoming beam particle; 11 - 200 : an intermediate (decayed/branched/...) particle that does not fulfill the criteria of status code 2, with a generator-dependent classification of its nature; in PYTHIA the absolute value of the normal status code is used. Note: for a particle without a properly set pointer to its event, codes 1 and 4 can still be inferred from its status code, while everythg else is assigned code 0."},{"name":"SoftQCD:elastic","link":"QCDProcesses.html#anchor3","text":"Elastic scattering A B &rarr; A B. Code 102. It is possible to include Coulomb corrections , but by default this is off."},{"name":"ColourReconnection:junctionCorrection","link":"ColourReconnection.html#anchor7","text":"This variable allows to use a different m0 for junction strings in the lambda measure. It is multiplicative correction to the m0 chosen above."},{"name":"Diffraction:mRefPomP","link":"Diffraction.html#anchor26","text":"The mRef reference mass scale introduced above."},{"name":"MultipartonInteractions:rescatterMode","link":"MultipartonInteractions.html#anchor20","text":"Selection of which partons rescatter against unscattered partons from the incoming beams A and B, based on their rapidity value y in the collision rest frame. Here ySep is shorthand for MultipartonInteractions:ySepRescatter and deltaY for MultipartonInteractions:deltaYRescatter , defined below. The description is symmetric between the two beams, so only one case is described below. only scattered partons with y > 0 can collide with unscattered partons from beam B. only scattered partons with y > ySep can collide with unscattered partons from beam B. the probability for a scattered parton to be considered as a potential rescatterer against unscattered partons in beam B increases linearly from zero at y = ySep - deltaY to unity at y = ySep + deltaY. the probability for a scattered parton to be considered as a potential rescatterer against unscattered partons in beam B increases with y according to (1/2) * (1 + tanh( (y - ySep) / deltaY)). all partons are potential rescatterers against both beams."},{"name":"mapAMPERSANDlt;string, ParmAMPERSANDgt; Settings::getParmMap(string match)","link":"SettingsScheme.html#anchor51","text":""},{"name":"virtual bool UserHooks::doVetoPT(int iPos, const EventAMPERSAND event)","link":"UserHooks.html#anchor16","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of Pythia::next(). is the position/status when the routine is called, information that can help you decide your course of action: when no MPI, ISR or FSR occurred above the veto scale; when inside the interleaved MPI + ISR + FSR evolution, after an MPI process; when inside the interleaved MPI + ISR + FSR evolution, after an ISR emission; when inside the interleaved MPI + ISR + FSR evolution, after an FSR emission; for the optional case where FSR is deferred from the interleaved evolution and only considered separately afterward (then alternative 3 would never occur); is for subsequent resonance decays, and is called once for each decaying resonance in a chain such as t &rarr; b W, W &rarr; u dbar. the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', and also those from further multiparton interactions. This may not be desirable for comparisons with matrix-element calculations. You may want to make use of the subEvent(...) method below to obtain a simplified event record workEvent."},{"name":"double Vec4::py()","link":"FourVectors.html#anchor13","text":""},{"name":"Hist::Hist(string title, const HistAMPERSANDamp; h)","link":"Histograms.html#anchor4","text":"creates an identical copy of the histogram in the argument, including bin contents, except that a new title is provided as first argument."},{"name":"TauDecays:tauPolarization","link":"ParticleDecays.html#anchor15","text":"Polarization of the tau when mode 2 or 3 of TauDecays:mode is selected."},{"name":"Merging:ktType","link":"CKKWLMerging.html#anchor2","text":"Precise functional definition of longitudinally invariant kT. For e+e- collisions, Durham kT is always defined by the square root of min{ 2*min[ E i 2 , E j 2 ] * [ 1 - cos&theta; ij ] } , so that this switch will have no effect. Longitudinally invariant kT is defined by the  square root of the minimum of minimal jet kinematic pT ( p Tkin,min 2 = min{ p T,i 2 } ) and p Tlon,min 2 = min{ min[ p T,i 2 , p T,j 2 ] *  [ (&Delta;y ij ) 2 + (&Delta;&phi; ij ) 2 ] / D 2 } , i.e. kT = min{ &radic;p Tkin,min 2 ,  &radic;p Tlon,min 2 } for hadronic collisions. Note that the true rapidity of partons is used. Longitudinally invariant kT is defined by the  square root of the minimum of minimal jet kinematic pT ( p Tkin,min 2 = min{ p T,i 2 } ) and p Tlon,min 2 = min{ min[ p T,i 2 , p T,j 2 ] * [ (&Delta;&eta; ij ) 2 + (&Delta;&phi; ij ) 2 ] / D 2 } , i.e. kT = min{ &radic;p Tkin,min 2 ,  &radic;p Tlon,min 2 } for hadronic collisions. Note that the pseudorapidity of partons is used. Longitudinally invariant kT is defined by the  square root of the minimum of minimal jet kinematic pT ( p Tkin,min 2 = min{ p T,i 2 } ) and p Tlon,min 2 = min{ min[ p T,i 2 , p T,j 2 ] * [ cosh(&Delta;&eta; ij ) - cos(&Delta;&phi; ij ) ] / D 2 } ,  i.e. kT = min{ &radic;p Tkin,min 2 , &radic;p Tlon,min 2 } for hadronic collisions."},{"name":"double Info::tPomeronB()","link":"EventInformation.html#anchor64","text":"The momentum transfer t in the hard diffractive process."},{"name":"virtual ~MyHardProcess()","link":"MatchingAndMerging.html#anchor24","text":"A destructor for your HardProcess class. If not defined, the base class's empty destructor will be used."},{"name":"virtual bool TimeShower::branch( EventAMPERSAND event,  bool isInterleaved = false)","link":"ImplementNewShowers.html#anchor15","text":"This method will be called once FSR has won the competition with MPI and ISR to do the next branching. The candidate branching found in the previous step should here be carried out in full. The pre-branching partons should get a negative status code and new replacement ones added to the end of the event record. Also the subsystem information should be updated, and possibly also the beams. Should some problem be encountered in this procedure, e.g. if some not-previously-considered kinematics requirement fails, it is allowed to return false to indicate that no branching could be carried out. Normally the optional isInterleaved argument would not be of interest. It can be used to separate resonance decays, false, from the interleaved evolution together with MPI and ISR, true. More precisely, it separates calls to the timesDecPtr and the timesPtr instances."},{"name":"Event Information","link":"EventInformation.html","text":"Event Information The Info class collects various one-of-a-kind information, some relevant for all events and others for the current event. An object info is a public member of the Pythia class, so if you e.g. have declared Pythia pythia , the Info methods can be accessed by pythia.info.method(). Most of this is information that could also be obtained e.g. from the event record, but is here more directly available. It is primarily intended for processes generated internally in PYTHIA, but many of the methods would work also for events fed in via the Les Houches Accord. List information The beams Initialization The event type Hard process initiators The methods in this sections refer to the two initial partons of the hard 2 &rarr; n process (diffraction excluded; see below). Hard process parton densities and scales The methods in this section refer to the partons for which parton densities have been defined, in order to calculate the cross section of the hard process (diffraction excluded; see below). These partons would normally agree with the ones above, the initiators of the 2 &rarr; n process, but it does not have to be so. Currently the one counterexample is POWHEG events Ali10. Here the original hard process could be 2 &rarr; (n-1). The NLO machinery at times would add an initial-state branching to give a 2 &rarr; n process with a changed initial state. In that case the values in this section refer to the original 2 &rarr; (n-1) state and the initiator ones above to the complete 2 &rarr; n process. The Info::list() printout will contain a warning in such cases. For external events in the Les Houches format, the pdf information is obtained from the optional #pdf line. When this information is absent, the parton identities and x values agree with the initiator ones above, while the pdf values are unknown and therefore set to vanish. The alpha_s and alpha_em values are part of the compulsory information. The factorization and renormalization scales are both equated with the one compulsory scale value in the Les Houches standard, except when a #pdf line provides the factorization scale separately. If alpha_s , alpha_em or the compulsory scale value are negative at input then new values are defined as for internal processes. Hard process kinematics The methods in this section provide info on the kinematics of the hard processes, with special emphasis on 2 &rarr; 2 (diffraction excluded; see below). Soft Diffraction Information on the primary elastic or diffractive process ( A B &rarr; A B, X1 B, A X2, X1 X2, A X B ) can be obtained with the methods in the 'Hard process kinematics' section above. The variables here obviously are s, t, u, ... rather than sHat, tHat, uHat, ... , but the method names remain to avoid unnecessary duplication. Most other methods are irrelevant for a primary elastic/diffractive process. Central diffraction A B &rarr; A X B is a 2 &rarr; 3 process, and therefore most of the 2 &rarr; 2 variables are no longer relevant. The tHat() and uHat() methods instead return the two t values at the A &rarr; A and B &rarr; B vertices, and pTHat() the average transverse momentum of the three outgoing 'particles', while thetaHat() and phiHat() are undefined. While the primary interaction does not contain a hard process, the diffractive subsystems can contain them, but need not. Specifically, double diffraction can contain two separate hard subprocesses, which breaks the methods above. Most of them have been expanded with an optional argument to address properties of diffractive subsystems. This argument can take four values: 0 : default argument, used for normal nondiffractive events or the primary elastic/diffractive process (see above); 1 : the X1 system in single diffraction A B &rarr; X1 B or double diffraction A B &rarr; X1 X2 ; 2 : the X2 system in single diffraction A B &rarr; A X2 or double diffraction A B &rarr; X1 X2 ; 3 : the X system in central diffraction A B &rarr; A X B. The argument is defined for all of the methods in the three sections above, 'Hard process initiators', 'Hard process parton densities and scales' and 'Hard process kinematics', with the exception of the isValence methods. Also the four final methods of 'The event type' section, the ...Sub() methods, take this argument. But recall that they will only provide meaningful answers, firstly if there is a system of the requested type, and secondly if there is a hard subprocess in this system. A simple check for this is that id1() has to be nonvanishing. The methods below this section do not currently provide information specific to diffractive subsystems, e.g. the MPI information is not bookkept in such cases. Hard Diffraction Information on the momentum fraction taken from the beam and the momentum transfer in the hard diffractive process. Note that when side A is diffractively exited, then the Pomeron has been taken from side B and vice versa. Photons from lepton beams Information about the kinematics of photon-photon collisions from lepton beams. Event weight and activity Multiparton interactions As already noted, these methods do not make sense for diffractive topologies, and should not be used there. Partly this is physics, but mainly it is for technical reasons, e.g. that double diffraction involves two separate systems that would have to be bookkept as such. Cross sections Here are the currently available methods related to the event sample as a whole, for the default value i = 0 , and otherwise for the specific process code provided as argument. This is the number obtained with Info::code() , while the further subdivision given by Info::codeSub() is not bookkept. While continuously updated during the run, it is recommended only to study these properties at the end of the event generation, when the full statistics is available. The individual process results are not available if a second hard process has been chosen, but can be gleaned from the pythia.stat() output. Loop counters Mainly for internal/debug purposes, a number of loop counters from various parts of the program are stored in the Info class, so that one can keep track of how the event generation is progressing. This may be especially useful in the context of the User Hooks facility. Parton shower history The following methods are mainly intended for internal use, e.g. for matrix-element matching. Les Houches Event File 3.0 information Les Houches Event files can conform to version 1.0 and version 3.0 of the standard (version 2.0 having been extended to 3.0). The LHEF version of an input file can can be accessed by The Info class also provides a suitable interface to the information stored after reading Les Houches Event files in the updated format But14. An example main program using LHEF 3.0 information is main38.cc. LHEF 3.0 offers new features both in the initialisation and the event sections of the input files. Possible information include extended use of XML tags in the <header> and <init> blocks.  The LHEF 3.0 information is stored in a series struct 's: -- &nbsp; &nbsp; The <initrwgt> tag is a container  tag for weight and weightgroup tags.  This information is stored  internally in LHAinitrwgt.  Currently, there is no dedicated  output for this tag. However, all the information stored in the tag can  be retrieved by using the Info class member pointer LHAinitrwgt Info::initrwgt. -- &nbsp; &nbsp; Multiple <weightgroup> tags:  Container tag for weight tags. Currently, there is no dedicated  output for this tag. However, all the information stored in the tag can  be retrieved by using the Info class member pointer vector<LHAweightgroups> * Info::weightgroups. -- &nbsp; &nbsp; Multiple <weight> tags: Tag defining  auxiliary information on an event weight, e.g. the identifier and information  on what the weight represents. All the information stored in the tag can  be retrieved by using the Info class member pointer vector<LHAweightgroups> * Info::init_weights. This vector  contains all <weight> tags in the <initrwgt> container and its subcontainer <weightgroup> tags. The size of the vector can be accessed  through the method -- &nbsp; &nbsp; Multiple <generator> tags: Store  information on the generators used in the event generation. All the  information stored in the tag can be retrieved by using the Info class member pointer vector<LHAgenerators> * Info::generators. More easy-to-use  output functions are available. The size of this vector can be obtained from The complete header can be obtained with the Info class member string getHeaderBlock(). The contents of a <generator> tag can be accessed through the method Attributes of the <generator> tag (e.g. the generator name and version ) can be accessed via To obtain information on cross sections, the following two methods can be used Possible information also includes extended use of XML tags in the <event> blocks: -- &nbsp; &nbsp; The <rwgt> tag is a container  tag for wgt tags. Currently, there is no dedicated  output for this tag. It can however be retrieved by using the Info class member pointer LHArwgt Info::rwgt. -- &nbsp; &nbsp; Multiple <wgt> tags: Tag defining  the event weight in the detailed version of LHEF 3.0.  All the information  stored in the tag can be retrieved by using the Info class  member pointer vector<LHAwgt> * Info::weights_detailed.  More easy-to-use output functions are available. The size of this vector  can be obtained from A convenient access point to the information stored in the <wgt> tags is the Info class member vector<double> Info::weights_detailed_vector. The entries of this vector are ordered according to how <wgt> tags appear in the event block. The contents of a <wgt> tag can be accessed through the method Attributes of the <wgt> tag (e.g. the weight id ) can be accessed via -- &nbsp; &nbsp; The <weights> tag: Tag containing  a vector of double entries for weights in the compressed version  of LHEF 3.0. All the information stored in the tag can be retrieved by using  the Info class member pointer LHAweights *  Info::weights and the vector vector<double>  Info::weights_compressed. More easy-to-use output functions are  available. The size of this vector can be obtained from The n'th weight can be accessed through the method Attributes of the <weights> tag (not normally used) can be accessed via -- &nbsp; &nbsp; The <scales> tag: Contains information  on different scales used by the matrix element generator. All the information  stored in the tag can be retrieved by using the Info class  member pointer LHAweights * Info::scales. More easy-to-use  output functions are available. The contents of the scales tag can be  obtained from However, note that the actual scale values are stored as attributes (called e.g. muf or mur ). Attributes of the <scales> tag can be accessed via Finally, arbitrary attributes of the <event> tag are supported. Attributes of the <event> tag can be accessed by Additional comments appearing in the <event> tag can be obtained with the Info class member string getEventComments(). Header information A simple string key/value store, mainly intended for accessing information that is stored in the header block of Les Houches Event (LHE) files. In principle, any LHAup derived class can set this header information, which can then be read out later. Although the naming convention is arbitrary, in practice, it is dictated by the XML-like format of LHE files, see Les Houches Accord for more details."},{"name":"void DecayChannel::onMode(int onMode)","link":"ParticleDataScheme.html#anchor170","text":""},{"name":"Charmonium:gg2ccbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor18","text":"Colour-octet production of 3S1 charmonium states via g g &rarr; ccbar[1S0(8)] g. Code 405."},{"name":"SigmaTotal:sigmaAXB2TeV","link":"TotalCrossSections.html#anchor1","text":"The CD cross section for p p and pbar p collisions, normalized to its value at 2 TeV CM energy, expressed in mb. The energy dependence is then parametrized, and behaves roughly like ln^1.5(s). Is used for the options Diffraction:PomFlux = 1 - 4 , while the MBR model ( = 5 ) has its own parametrization."},{"name":"NewGaugeBoson:ffbar2Wprime","link":"NewGaugeBosonProcesses.html#anchor39","text":"Scattering f fbar' &rarr; W'^+-. Code 3021."},{"name":"FourthTop:ffbar2tPrimetPrimebar(s:gmZ)","link":"FourthGenerationProcesses.html#anchor12","text":"Scatterings f fbar &rarr; t' t'bar by s -channel exchange of a gamma^*/Z^0 boson. Code 824."},{"name":"bool Settings::reInit(string  startFile = AMPERSANDquot;../share/Pythia8/xmldoc/Index.xmlAMPERSANDquot;)","link":"SettingsScheme.html#anchor5","text":"overwrite the existing database. read in the settings from all the files listed in this file, and assumed to be located in the same subdirectory. Note: The method returns false if it fails."},{"name":"double LHAup::alphaQED()","link":"LesHouchesAccord.html#anchor36","text":""},{"name":"double Info::alphaEM()","link":"EventInformation.html#anchor47","text":"the alpha_strong and alpha_electromagnetic values used for the hard process."},{"name":"void Event::rot(double theta, double phi)","link":"EventRecord.html#anchor32","text":"rotate all particles in the event by this polar and azimuthal angle (expressed in radians)."},{"name":"bool init(istreamAMPERSAND is, bool append = false)","link":"SettingsScheme.html#anchor4","text":"read in the settings from an input stream. This allows initialization without reading the xml files directly, which is useful for initialization of multiple copies of Pythia8."},{"name":"FourthGeneration:VtPrimes","link":"FourthGenerationProcesses.html#anchor20","text":"The V_t's matrix element in the 4 * 4 CKM matrix."},{"name":"HiggsSM:ffbar2HW","link":"HiggsProcesses.html#anchor11","text":"Scattering f fbar &rarr; H^0 W^+- via s -channel W^+- exchange. Code 905."},{"name":"Zprime:anumu","link":"NewGaugeBosonProcesses.html#anchor19","text":"axial coupling of nu_mu neutrinos."},{"name":"Resonance Decays","link":"ResonanceDecays.html","text":"Resonance Decays The ResonanceDecays class performs the sequential decays of all resonances formed in the hard process. Note the important distinction between 'resonances' and other 'particles' made in PYTHIA. The list of resonances contains gamma^*/Z^0 , W^+- , top, the Higgs, and essentially all new particles of Beyond-the-Standard-Model physics: further Higgs bosons, sfermions, gauginos, techniparticles, and so on. The partial widths to different decay channels are perturbatively calculable, given the parameters of the respective model, and branching ratios may be allowed to vary across a (reasonably broad) resonance peak. Usually resonances are short-lived, and therefore it makes sense to consider their decays immediately after the primary hard process has been set up. Furthermore, in several cases the decay angular distributions are encoded as part of the specific process, e.g. the W decays differently in f fbar &rarr; W^+- , f fbar &rarr; W^+ W^- and h^0 &rarr; W^+ W^-. All of these particles are (in PYTHIA) only produced as part of the hard process itself, i.e. they are not produced in showers or hadronization processes. Therefore the restriction to specific decay channels can be consistently taken into account as a corresponding reduction in the cross section of a process. Finally, note that all of these resonances have an on-shell mass above 20 GeV, with the exception of some hypothetical weakly interacting and stable particles such as the gravitino. The other particles include normal hadrons and the Standard-Model leptons, including the tau^+-. These can be produced in the normal hadronization and decay description, which involve unknown nonperturbative parameters and multistep chains that cannot be predicted beforehand: a hard process like g g &rarr; g g can develop a shower with a g &rarr; b bbar branching, where the b hadronizes to a B^0bar that oscillates to a B^0 that decays to a tau^+. Therefore any change of branching ratios - most of which are determined from data rather than from first principles anyway - will not be taken into account in the cross section of a process. Exceptions exist, but most particles in this class are made to decay isotropically. Finally, note that all of these particles have a mass below 20 GeV. There is one ambiguous case in this classification, namely the photon. The gamma^*/Z^0 combination contains a low-mass peak when produced in a hard process. On the other hand, photons can participate in shower evolution, and therefore a photon originally assumed massless can be assigned an arbitrarily high mass when it is allowed to branch into a fermion pair. In some cases this could lead to double-counting, e.g. between processes such as f fbar &rarr; (gamma^*/Z^0) (gamma^*/Z^0) , f fbar &rarr; (gamma^*/Z^0) gamma and f fbar &rarr; gamma gamma. Here it make sense to limit the lower mass allowed for the gamma^*/Z^0 combination, in 23:mMin , to be the same as the upper limit allowed for an off-shell photon in the shower evolution, in TimeShower:mMaxGamma. By default this matching is done at 10 GeV. In spite of the above-mentioned differences, the resonances and the other particles are all stored in one common particle data table , so as to offer a uniform interface to setting and getting properties such as name, mass, charge and decay modes, also for the particle properties in the event record. Some methods are specific to resonances, however, in particular for the calculation of partial widths and thereby of branching ratio. For resonances these can be calculated dynamically, set up at initialization for the nominal mass and then updated to the current mass when these are picked according to a Breit-Wigner resonance shape. Resonance Decays and Cross Sections As already hinted above, you have the possibility to set the allowed decay channels of resonances, see Particle Data Scheme description. For instance, if you study the process q qbar &rarr; H^0 Z^0 you could specify that the Z^0 should decay only to lepton pairs, the H^0 only to W^+ W^- , the W^+ only to a muon and a neutrino, while the W^- can decay to anything. Unfortunately there are limits to the flexibility: you cannot set a resonance to have different properties in different places of a process, e.g. if instead H^0 &rarr; Z^0 Z^0 in the above process then the three Z^0 's would all obey the same rules. The restrictions on the allowed final states of a process is directly reflected in the cross section of it. That is, if some final states are excluded then the cross section is reduced accordingly. Such restrictions are built up recursively in cases of sequential decay chains. The restrictions are also reflected in the compositions of those events that actually do get to be generated. For instance, the relative rates of H^0 &rarr; W^+ W^- and H^0 &rarr; Z^0 Z^0 are shifted when the allowed sets of W^+- and Z^0 decay channels are changed. We remind that only those particles that Pythia treat as resonances enjoy this property, and only those that are considered as part of the hard process and its associated resonance decays. There is one key restriction on resonances: In spite of this technical parameter choice, it is possible to set a lifetime for a resonance, and thereby to obtain displaced vertices. If a resonance is allowed to decay it will do so, irrespective of the location of the decay vertex. This is unlike normal particle decays , where it is possible to define some region around the primary vertex within which all decays should happen, with particles leaving that region considered stable. The logic is that resonances as a rule are too short-lived for secondary vertices, so if you pick a scenario with a long-lived but unstable resonance it is because you want to study secondary vertices. How to interface those decays to a detector simulation program then is another story, to be solved separately. Do note that a special treatment is needed for coloured long-lived resonances, that form R-hadrons , and where charge and flavour may change between the production and decay vertices. Special properties and methods for resonances The method ParticleData::isResonance(id) allows you to query whether a given particle species is considered a resonance or not. You can also change the default value of this flag in the normal way, e.g. pythia.readString('id:isResonance = true'). Resonances come in two kinds. The standard built-in ones include Z^0 , W^+- , t , h^0 , and many more. These have explicit decay-widths formulae encoded, in classes derived from the ResonanceWidths base class. The formulae are used, e.g., to calculate all the partial widths as a function of the resonance masses you choose, and at initialization the existing total width values are overwritten. This is especially convenient for hypothetical states, like a Z' , where the mass is not known and therefore routinely changed. Often the partial widths are associated with parameters that can be changed by the user, e.g. for MSSM Higgs states. If a resonance does not have a class of its own, with hardcoded equations for all relevant partial widths, then a simpler object will be created at initialization. This object will take the total width and branching ratios as is (with the optional variations explained in the next section). When you set a particle to be a resonance, and do not provide any class to go with its width calculations, this is where it will end up. Sometimes experimentalists want to modify the physical width of a resonance, to understand how sensitive analyses are to this width, if at all. For the second, simpler kind of resonances, the id:mWidth can be changed right away, but for the first kind any change will be overwritten at initialization. To circumvent this problem, the id:doForceWidth flag can be changed from the default off to on. Then the width stored in id:mWidth is strictly used to describe the Breit-Wigner of the resonance. Partial widths are still recalculated to set the mass-dependent branching ratios, but then uniformly rescaled to the requested total width. The width can also run across the lineshape, so that it deviates from the nominal one in the wings of the Breit-Wigner. For processes that contain interference terms between resonances, notably gamma^*/Z^0 or gamma^*/Z^0/Z'^0 , it is not obvious how these contributions should be modified consistently. Therefore it is necessary to set WeakZ0:gmZmode = 2 or Zprime:gmZmode = 3 , to have a pure Z^0 or Z'^0 , respectively, for width forcing to be allowed in these cases. A warning is that the different processes have cross sections that rescale in different ways when the resonance width is varied. This depends on them not having been implemented in a guaranteed uniform way. To illustrate the point, consider the case of an s -channel resonance, where the cross section dependence on the width can be written as sigmaHat(sHat) = constant * Gamma_in * Gamma_out / ((sHat - m^2)^2 + m^2 * Gamma^2) Here the doForceWidth = on option ensures that the Gamma in the denominator is rescaled by some factor k relative to the natural width, but does not guarantee that Gamma_in and Gamma_out are rescaled as well. If all three are rescaled by the same factor k , as they should, then the integrated cross section also scales like k , assuming that the peak is reasonably narrow, so that the variation of PDF's across the Breit-Wigner can be neglected. This is the case for some processes. But in others either or both of the production and decay vertices can have been hardcoded, based on the coupling structure, and thus not scale with k. If only Gamma_out scales with k , say,  the cross section remains (approximately) constant, and if neither scales the cross section will even go like 1/k. Such obvious normalization imperfections have to be corrected by hand. Mainly for internal usage, the ParticleData contain some special methods that are only meaningful for resonances: resInit(...) to initialize a resonance, possibly including a recalculation of the nominal width to match the nominal mass; resWidth(...) to calculate the partial and total widths at the currently selected mass; resWidthOpen(...) to calculate the partial and total widths of those channels left open by user switches, at the currently selected mass; resWidthStore(...) to calculate the partial and total widths of those channels left open by user switches, at the currently selected mass, and store those as input for a subsequent selection of decay channel; resOpenFrac(...) to return the fraction of the total width that is open by the decay channel selection made by users (based on the choice of onMode for the various decay channels, recursively calculated for sequential decays); resWidthRescaleFactor(...) returns the factor by which the internally calculated PYTHIA width has to be rescaled to give the user-enforced width; resWidthChan(...) to return the width for one particular channel (currently only used for Higgs decays, to obtain instate coupling from outstate width). These methods actually provide an interface to the classes derived from the ResonanceWidths base class, to describe various resonances. Modes for Matrix Element Processing The meMode() value for a decay mode is used to specify nonisotropic decays or the conversion of a parton list into a set of hadrons in some channels of normal particles. For resonances it can also take a third function, namely to describe how the branching ratios and widths of a resonance should be rescaled as a function of the current mass of the decaying resonance. The rules are especially useful when new channels are added to an existing particle, or a completely new resonance added. 0 : channels for which hardcoded partial-width expressions are expected to exist in the derived class of the respective resonance. Should no such code exist then the partial width defaults to zero. 1 - 99 : same as 0, but normally not used for resonances. 100 : calculate the partial width of the channel from its stored branching ratio times the stored total width. This value remains unchanged when the resonance fluctuates in mass. Specifically there are no threshold corrections. That is, if the resonance fluctuates down in mass, to below the nominal threshold, it is assumed that one of the daughters could also fluctuate down to keep the channel open. (If not, there may be problems later on.) 101 : calculate the partial width of the channel from its stored branching ratio times the stored total width. Multiply by a step threshold, i.e. the channel is switched off when the sum of the daughter on-shell masses is above the current mother mass. 102 : calculate the partial width of the channel from its stored branching ratio times the stored total width. Multiply by a smooth threshold factor beta = sqrt( (1 - m_1^2/m_2 - m_2^2/m^2)^2 - 4 m_1^2 m_2^2/m^4) for two-body decays and sqrt(1 - Sum_i m_i / m) for multibody ones. The former correctly encodes the size of the phase space but misses out on any nontrivial matrix-element behaviour, while the latter obviously is a very crude simplification of the correct phase-space expression. Specifically, it is thereby assumed that the stored branching ratio and total width did not take into account such a factor. 103 : use the same kind of behaviour and threshold factor as for 102 above, but assume that such a threshold factor has been used when the default branching ratio and total width were calculated, so that one should additionally divide by the on-shell threshold factor. Specifically, this will give back the stored branching ratios for on-shell mass, unlike the 102 option. To avoid division by zero, or in general unreasonably big rescaling factors, a lower limit minThreshold (see below) on the value of the on-shell threshold factor is imposed. (In cases where a big rescaling is intentional, code 102 would be more appropriate.) All of these meMode 's may coexist for the same resonance. This would be the case e.g. if you want to add a few new channels to an already existing resonance, where the old partial widths come hardcoded while the new ones are read in from an external file. The typical example would be an MSSM Higgs sector, where partial widths to SM particles are already encoded, meMode = 0 , while decay rates to sparticles are read in from some external calculation and maybe would be best approximated by using meMode = 103. Indeed the default particle table in PYTHIA uses 103 for all channels that are expected to be provided by external input. Some further clarification may be useful. At initialization the existing total width and on-shell branching ratios will be updated. For channels with meMode < 100 the originally stored branching ratios are irrelevant, since the existing code will anyway be used to calculate the partial widths from scratch. For channels with meMode = 100 or bigger, instead the stored branching ratio is used together with the originally stored total width to define the correct on-shell partial width. The sum of partial widths then gives the new total width, and from there new branching ratios are defined. In these operations the original sum of branching ratios need not be normalized to unity. For instance, you may at input have a stored total width of 1 GeV and a sum of branching ratios of 2. After initialization the width will then have been changed to 2 GeV and the sum of branching ratios rescaled to unity. This might happen e.g. if you add a few channels to an existing resonance, without changing the branching ratios of the existing channels or the total width of the resonance. In order to simulate the Breit-Wigner shape correctly, it is important that all channels that contribute to the total width are included in the above operations. This must be kept separate from the issue of which channels you want to have switched on for a particular study, to be considered next. In the event-generation process, when an off-shell resonance mass has been selected, the width and branching ratios are re-evaluated for this new mass. At this stage also the effects of restrictions on allowed decay modes are taken into account, as set by the onMode switch for each separate decay channel. Thus a channel may be on or off, with different choices of open channels between the particle and its antiparticle. In addition, even when a channel is on, the decay may be into another resonance with its selection of allowed channels. It is these kinds of restrictions that lead to the Gamma_out possibly being smaller than Gamma_tot.  As a reminder, the Breit-Wigner for decays behaves like Gamma_out / ((s - m^2)^2 + s * Gamma_tot^2) , where the width in the numerator is only to those channels being studied, but the one in the denominator to all channels of the particle. These ever-changing numbers are not directly visible to the user, but are only stored in a work area."},{"name":"FourthGeneration:VtPrimed","link":"FourthGenerationProcesses.html#anchor19","text":"The V_t'd matrix element in the 4 * 4 CKM matrix."},{"name":"Diffraction:pickQuarkNorm","link":"Diffraction.html#anchor21","text":"The abovementioned normalization N for the relative quark rate in diffractive systems."},{"name":"ColourReconnection:reconnect","link":"ColourReconnection.html#anchor1","text":"Allow or not a system to be merged with another one."},{"name":"Charmonium:qqbar2ccbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor20","text":"Colour-octet production of 3S1 charmonium states via q qbar &rarr; ccbar[1S0(8)] g. Code 407."},{"name":"Diffraction:PomFluxEpsilon","link":"Diffraction.html#anchor2","text":"The Pomeron trajectory intercept epsilon above for the 3 and 4 flux options. For technical reasons epsilon > 0 is necessary in the current implementation."},{"name":"HiggsSM:ffbar2HZ","link":"HiggsProcesses.html#anchor10","text":"Scattering f fbar &rarr; H^0 Z^0 via s -channel Z^0 exchange. Code 904."},{"name":"FourthGeneration:VtPrimeb","link":"FourthGenerationProcesses.html#anchor21","text":"The V_t'b matrix element in the 4 * 4 CKM matrix."},{"name":"ExtraDimensionsLED:monojet","link":"ExtraDimensionalProcesses.html#anchor42","text":"Common switch for the group of lowest-order G jet emission processes, i.e. the three ones below."},{"name":"FragmentationSystems:mJoin","link":"Fragmentation.html#anchor39","text":"When two colour-connected partons are very nearby, with at least one being a gluon, they can be joined into one, to avoid technical problems of very small string regions. The requirement for joining is that the invariant mass of the pair is below mJoin , where a gluon only counts with half its momentum, i.e. with its contribution to the string region under consideration. (Note that, for technical reasons, the 0.2 GeV lower limit is de facto hardcoded.)"},{"name":"double TimeShower::enhancePTmax()","link":"ImplementNewShowers.html#anchor6","text":"Relative to the default pT_max evolution scale of the process, it may still be convenient to vary the matching slightly for the hardest interaction in an event, to probe the sensitivity to such details. The base-class implementation returns the value of the TimeShower:pTmaxFudge parameter."},{"name":"PDF:PomQuarkB","link":"PDFSelection.html#anchor13","text":"the parameter b in the ansatz xq(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"Charmonium:gg2ccbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor27","text":"Colour-singlet production of 3PJ charmonium states via g g &rarr; ccbar[3PJ(1)] g. Code 411."},{"name":"SigmaTotal:sigmaTot","link":"TotalCrossSections.html#anchor4","text":"Total cross section in mb."},{"name":"Vec4AMPERSAND Vec4::operator*=(double f)","link":"FourVectors.html#anchor51","text":"multiply all four-vector components by a real number."},{"name":"friend Vec4 operator*(const Vec4AMPERSAND v, double f)","link":"FourVectors.html#anchor56","text":"multiply a four-vector by a real number."},{"name":"double CoupSM::vf(int idAbs)","link":"StandardModelParameters.html#anchor30","text":""},{"name":"virtual vectorAMPERSANDlt;intAMPERSANDgt;TimeShower::getRecoilers(  const EventAMPERSAND  event, int iRad, int iEmt, string name)","link":"ImplementNewShowers.html#anchor26","text":"This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the timelike shower for all possible recoilers for a particular combination of radiator and emission. The function arguments are the event which contains the radiator and emission, and the position of the radiator ( iRad ) and emission ( iEmt ) in said event. Since this information might not be enough to uniquely determine the list of recoilers, a further string argument that encodes e.g. the splitting name is supplied. The function should return a vector of the positions of all possible allowed recoilers in the input event."},{"name":"TimeShower:pTmaxFudgeMPI","link":"TimelikeShowers.html#anchor3","text":"A multiplicative factor f such that pT_max = f * pT_factorization , as above, but here for the non-hardest interactions (when multiparton interactions are allowed)."},{"name":"SpaceShower:QCDshower","link":"SpacelikeShowers.html#anchor24","text":"Allow a QCD shower; on/off = true/false."},{"name":"PromptPhoton:nQuarkLoop","link":"ElectroweakProcesses.html#anchor7","text":"Number of quark flavours included in the box graphs responsible for g g &rarr; g gamma and g g&rarr; gamma gamma processes. Owing to the complexity if the massive expressions, quarks are treated as massless. The default value should be applicable in the range of transverse momenta above the b mass but below the t one."},{"name":"Charmonium:gg2ccbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor15","text":"Colour-octet production of 3S1 charmonium states via g g &rarr; ccbar[3S1(8)] g. Code 402."},{"name":"int Info::nFinal()","link":"EventInformation.html#anchor15","text":"the number of final-state partons in the hard process."},{"name":"double LHAup::x1()","link":"LesHouchesAccord.html#anchor56","text":""},{"name":"ColourReconnection:fracGluon","link":"ColourReconnection.html#anchor16","text":"The probability that a given gluon will be considered for being moved. It thus gives the average fraction of gluons being considered."},{"name":"Next:showMothersAndDaughters","link":"MainProgramSettings.html#anchor15","text":"In addition to the normal information in the listing of the process and event records, further lines list all the mothers and daughters of each particle."},{"name":"Check:event","link":"ErrorChecks.html#anchor4","text":"When an event has been successfully generated, check that the final event record in event does not contain any unphysical particles, or nonconserved charge or energy-momentum. If this check fails, then pythia.next() obtains the value false , i.e. the event is counted as aborted."},{"name":"Beams:eCM","link":"BeamParameters.html#anchor4","text":"Collision CM energy, to be set if Beams:frameType = 1."},{"name":"ExcitedFermion:qqbar2nueStarnue","link":"CompositenessProcesses.html#anchor16","text":"Scatterings q qbar &rarr; nu_e^* nu_ebar. Code 4032."},{"name":"double SigmaProcess::weightDecay( EventAMPERSAND process,  int iResBeg, int iResEnd)","link":"SemiInternalProcesses.html#anchor11","text":"is called when the basic process has one or several resonances, after each set of related resonances in process[i] , iResBeg <= i <= iResEnd , has been allowed to decay. The calculated weight, to be normalized to the range between 0 and 1, is used to decide whether to accept the decay(s) or try for a new decay configuration. The base-class version of this method returns unity, i.e. gives isotropic decays by default. This method may be called repeatedly for a single event. For instance, in q qbar &rarr; H^0 Z^0 with H^0 &rarr; W^+ W^- , a first call would be made after the H^0 and Z^0 decays, and then depend only on the Z^0 decay angles since the H^0 decays isotropically. The second call would be after the W^+ W^- decays and then involve correlations between the four daughter fermions."},{"name":"Leptoquark Processes","link":"LeptoquarkProcesses.html","text":"Leptoquark Processes Leptoquarks arise in many scenarios, and can have widely different characteristics, with respect to spin, isospin am d flavour. The current implementation in no sense attempts to exhaust these possibilities, but only to encode one of the simplest possibilities, with a single scalar leptoquark, denoted LQ and assigned PDG code 42. The leptoquark is assumed to carry specific quark and lepton quantum numbers, by default u quark plus electron. These flavour numbers are conserved, i.e. a process such as u e^- &rarr; LQ &rarr; d nu_e is not allowed. Although only one leptoquark is implemented, its flavours may be changed arbitrarily to study the different possibilities. The flavours of the leptoquark are defined by the quark and lepton flavours in the decay mode list. Therefore, to change from the current u e^- to c mu^+ , say, you only need a line pythia.readString('42:0:products = 4 -13'); in your main program, or the equivalent in a command file. The former must always be a quark, while the latter could be a lepton or an antilepton; a charge-conjugate partner is automatically defined by the program. At initialization, the charge is recalculated as a function of the flavours defined; also the leptoquark name is redefined to be of the type LQ_q,l , where actual quark and lepton flavours are displayed. The leptoquark is likely to be fairly long-lived, in which case it could have time to fragment into a mesonic- or baryonic-type state, which would decay later on. Currently this possibility is not handled; therefore the leptoquark is always assumed to decay before fragmentation. For that reason the leptoquark can also not be put stable. Production processes Four production processes have been implemented, which normally would not overlap and therefore could be run together. Parameters In the above scenario the main free parameters are the leptoquark flavour content, set as already described, and the LQ mass, set as usual. In addition there is one further parameter."},{"name":"HiggsBSM:ff2A3ff(t:WW)","link":"HiggsProcesses.html#anchor51","text":"Scattering f_1 f_2 &rarr; A^0(A_3^0) f_3 f_4 via W^+ W^- fusion. Code 1047."},{"name":"StringFlav:StrangeSuppression","link":"FlavourSelection.html#anchor42","text":"Extra suppression factor for strange quarks. Note that in case of more than one strange quark in the hadron the factor gets squared or tripled respectively."},{"name":"void LHAupMadgraph::setEvents(int events)","link":"MadGraph5Processes.html#anchor3","text":"the number of events to generate per MadGraph run. Normally does not need to be set, but defaults to 10000."},{"name":"double Info::scalup()","link":"EventInformation.html#anchor50","text":"returns the stored SCALUP value for Les Houches events, and else zero. It may agree with both the QFac() and QRen() values, as explained above. However, to repeat, should the input SCALUP scale be negative, separate positive factorization and renormalization scales are calculated and set as for internally generated events. Furthermore, when PDF info is supplied for the Les Houches event, the factorization scale is set by this PDF info ( scalePDF ), which can disagree with SCALUP."},{"name":"bool ParticleData::readXML(string inFile,  bool reset = true)","link":"ParticleDataScheme.html#anchor9","text":""},{"name":"Random Numbers","link":"RandomNumbers.html","text":"Random Numbers This page describes the random-number generator in PYTHIA and how it can be replaced by an external one. Internal random numbers The Rndm class generates random numbers, using the Marsaglia-Zaman-Tsang algorithm Mar90. Random numbers R uniformly distributed in 0 < R < 1 are obtained with Rndm::flat(); There are also methods to generate according to an exponential, to x * exp(-x) , to a Gaussian, or picked among a set of possibilities, which make use of flat(). If the random number generator is not initialized before, it will be so the first time it is asked to generate a random number, and then with the default seed, 19780503. This means that, by default, all runs will use identically the same random number sequence. This is convenient for debugging purposes, but dangerous if you intend to run several 'identical' jobs to boost statistics. You can initialize, or reinitialize, with your own choice of seed with a Rndm::init(seed); Here values 0 < seed < 900 000 000 gives so many different random number sequences, while seed = 0 will call the Stdlib time(0) function to provide a 'random' seed , and seed < 0 will revert back to the default seed. The Pythia class defines a flag and a mode , that allows the seed to be set in the Pythia::init call. That would be the standard way for a user to pick the random number sequence in a run. External random numbers RndmEngine is a base class for the external handling of random-number generation. The user-written derived class is called if a pointer to it has been handed in with the pythia.rndmEnginePtr() method. Since the default Marsaglia-Zaman-Tsang algorithm is quite good, chances are that any replacement would be a step down, but this may still be required by consistency with other program elements in big experimental frameworks. There is only one pure virtual method in RndmEngine , to generate one random number flat in the range between 0 and 1: virtual double flat() = 0; Note that methods for initialization are not provided in the base class, in part since input parameters may be specific to the generator used, in part since initialization can as well be taken care of externally to the Pythia code. An example illustrating how to run with an external random number generator is provided in main23.cc. The methods We here collect a more complete and formal overview of the methods."},{"name":"TimeShower:interleave","link":"TimelikeShowers.html#anchor16","text":"If on, final-state emissions are interleaved in the same decreasing- pT chain as multiparton interactions and initial-state emissions. If off, final-state emissions are only addressed after the multiparton interactions and initial-state radiation have been considered."},{"name":"bool ParticleDataEntry::isOctetHadron()","link":"ParticleDataScheme.html#anchor148","text":"true for an intermediate hadron-like state with a colour octet charge as used in the colour octet model for onia production."},{"name":"Onia:massSplit","link":"OniaProcesses.html#anchor2","text":"Mass splitting in GeV between the physical colour-singlet states and their corresponding colour-octet state."},{"name":"bool ParticleDataEntry::canDecay(int id)","link":"ParticleDataScheme.html#anchor139","text":"true for a particle with at least one decay channel defined."},{"name":"TimeShower:pTmaxFudge","link":"TimelikeShowers.html#anchor2","text":"In cases where the above pTmaxMatch rules would imply that pT_max = pT_factorization , pTmaxFudge introduces a multiplicative factor f such that instead pT_max = f * pT_factorization. Only applies to the hardest interaction in an event, and a 'second hard' if there is such a one, cf. below. It is strongly suggested that f = 1 , but variations around this default can be useful to test this assumption. Note: Scales for resonance decays are not affected, but can be set separately by user hooks."},{"name":"HiddenValley:gg2SvSvbar","link":"HiddenValleyProcesses.html#anchor10","text":"Pair production g g &rarr; Sv Svbar. Code 4903."},{"name":"StringFlav:mesonBL1S1J2","link":"FlavourSelection.html#anchor29","text":"the relative tensor production ratio (L=1,S=1,J=2) /pseudoscalar for bottom mesons."},{"name":"ExcitedFermion:qqbar2numuStarnumuStar","link":"CompositenessProcesses.html#anchor24","text":"Scatterings q qbar &rarr; nu_mu^* nu_mu^*bar. Code 4054."},{"name":"virtual SlowJetHook::~SlowJetHook()","link":"EventAnalysis.html#anchor67","text":"the constructor and destructor need not do anything, and if so you need not write your own destructor."},{"name":"Main:timesAllowErrors","link":"MainProgramSettings.html#anchor24","text":"Allow this many times that pythia.next() returns false, i.e. that an event is flawed, before aborting the run."},{"name":"JetMatching:nJet","link":"JetMatching.html#anchor14","text":"When JetMatching:exclusive = 2 , nJet indicates the minimum number of additional light jets in the incoming process. This value may be set automatically."},{"name":"void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax)","link":"LesHouchesAccord.html#anchor8","text":"sets info on an allowed process (cf. LPRUP, XSECUP, XERRUP, XMAXUP ). Each new call will append one more entry to the list of processes. The choice of strategy determines which quantities are mandatory: xSec for strategies +-2 and +-3, xErr never, and xMax for strategies +-1 and +-2."},{"name":"Pythia::Pythia( istreamAMPERSAND settingsStrings,  istreamAMPERSAND particleDataStrings, bool printBanner = true)","link":"ProgramFlow.html#anchor3","text":"creates an instance of the Pythia event generators, and sets initial default values, notably for all settings and particle data. This option is intended for runs with multiple Pythia instances, where input streams can avoid file read congestion. can be set false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia instances, where output needs to be restricted."},{"name":"Diffraction:useMBRrenormalization","link":"Diffraction.html#anchor35","text":"Use the renormalized MBR flux."},{"name":"HiddenValley:qqbar2DvDvbar","link":"HiddenValleyProcesses.html#anchor14","text":"Pair production q qbar &rarr; Dv Dvbar via intermediate gluon. Code 4911."},{"name":"ExtraDimensionsLED:GravScalar","link":"ExtraDimensionalProcesses.html#anchor59","text":"Allow the monojet processes to produce scalar graviton emission instead of the default tensor one. The scalar option is according to the processes described in Azu05 and includes two coupling constants below."},{"name":"bool LHAup::setOldEventLHEF()","link":"LesHouchesAccord.html#anchor77","text":"store the event information from the staging area into the normal location. Thus a single setNewEventLHEF call can be followed by several setOldEventLHEF ones, so as to process the same configuration several times. This method currently only returns true, i.e. any errors should be caught by the preceding setNewEventLHEF call."},{"name":"Flavour Selection","link":"FlavourSelection.html","text":"Flavour Selection for Gaussian pT Distribution The StringFlav class handles the choice of a new flavour in the fragmentation process, and the production of a new hadron from a set of input flavours. It is mainly used by the string fragmentation machinery (including ministrings), but also e.g. in some particle decays and for some beam-remnant cases. The basic concepts are in agreement with And83. An alternative 'thermal model' is described further below. The relative production rates of different particle species is influenced by the parameters below. Some have only an impact on one specific quantity, but most directly or indirectly have consequences for many observables. Therefore the values to use have to be viewed in the context of a complete tune. New flavours The main parameters of the selection of a new flavour are Standard-meson production The bulk of the particle production corresponds to the lowest-lying pseudoscalar and vector multiplets. Their production rates are determined by the parameters in this section. For a given set of flavours, produced according to the probabilities outlined above, the ratio of vector-to-pseudocalar meson production is described by the parameters below. The maximum allowed rate for each case has been set according to spin-counting rules, but we expect the real rates to be lower, especially for lighter mesons, owing to the vector-pseudoscalar mass splitting. Inside each light-quark meson nonet, an octet-singlet mixing angle describes the mixing of the two flavour-diagonal isoscalar = 0 states. (For terminology and details see Yao06 , chapter 14 on the quark model.) This angle is needed to specify the probability for such a q qbar state to project onto a specific meson. More transparent formulae are obtained by introducing the angle alpha = theta + 54.7 degrees: f  = (uubar + ddbar)/sqrt(2) * sin(alpha) + ssbar * cos(alpha) f' = (uubar + ddbar)/sqrt(2) * cos(alpha) - ssbar * sin(alpha) Further, the simple model overestimates the production of eta and, in particular, eta' mesons, which can be rectified by Excited-meson production Several excited mesons, ie. with radial or orbital excitations, have been observed at non-negligible production rates. Extrapolated to all states a fair fraction of all particle production might proceed through such states. There are big uncertainties, however, since these excited mesons in many cases are extremely poorly known. This also means that the modeling of their production and decay is very primitive, and even that the inclusion of the production of such states may lead to a degraded agreement with data. Currently the default is that all such production is switched off. Parameters are provided to switch them on. By demand, this machinery has been made more flexible than in the past. Therefore one parameter is provided for each combination of heaviest flavour ( u/d , s , c or b ) and multiplet produced. In each case the production rate is normalized to that of the lowest-lying pseudoscalar of the same flavour content, as for the vector-meson rates introduced above. The multiplets available are the four obtained for one unit of orbital angular momentum, in the nonrelativistic classification. Using J to denote the sum of quark spin S and orbital angular momentum L , i.e. what would normally be called the spin of the meson, one has: a pseudovector multiplet with L=1, S=0, J=1 ; a scalar multiplet with L=1, S=1, J=0 ; a pseudovector multiplet with L=1, S=1, J=1 ; a tensor multiplet with L=1, S=1, J=2. The maximum allowed rate for each case has been set according to spin-counting rules, but we expect the real rates to be significantly lower, owing to mass suppression. In addition, an octet-singlet mixing angle is needed for each multiplet, as for the pseudoscalar and vector multiplets above. Only for the tensor multiplet does any determination exist; for the other multiplets default has been chose so that ssbar does not mix with the light quarks, and so that the ssbar state is the heavier of the two. Baryon production The relative rate of baryon production is mainly given by the quark and diquark production parameters above, plus SU(6) Clebsch-Gordans. The one modifiable parameter related to these coefficients is In addition, if popcorn production is allowed, wherein a set of mesons ( M ) may be produced in between the baryon ( B ) and the antibaryon ( Bbar ), a set of further parameters is introduced. Currently only the simplest scenario is implemented, wherein at most one intermediate meson may be produced. Finally, there are some indications that leading-baryon production may be further suppressed. A proper description should probably be based on a suppression of early production times Ede97 , but we here only implement a simpler version where production near the end of a string, as defined by rank, is suppressed. The more detailed studies suggest that leading c and b baryon production will be less suppressed, so we leave it open to set light- and heavy-baryon suppression separately. Flavour Selection for Thermal pT Distribution If the hadronic pT is generated according to the non-default thermal distribution, i.e. if StringPT:thermalModel = on , the choice of a new flavour in the fragmentation process, and the production of a new hadron from a set of input flavours, depends mainly on the hadron mass Fis16. For a given pT value the new flavour is chosen according to exp( -mT_had/T) = exp( - sqrt( pT_had^2 + mT_had^2 )/T). Here T is primarily given by StringPT:temperature , but can be further modified in the context of closely packed strings, StringPT:closePacking = on. Additional factors are included from theory arguments, for instance the ratio of vector-to-pseudocalar meson production is set according to spin-counting rules. Note that the octet-singlet mixing angles in the light-quark meson nonets are taken from the parameters above. Currently popcorn production has not been implemented, i.e. a baryon and an antibaryon are nearest neighbours in the flavour fragmentation chain, and share the flavours of one diquark. In addition the following two factors are introduced to provide an improved description of the flavour composition, although not as good as obtained in the default Gaussian scenario, with its bigger selection of free parameters. The following parameters are used to determine which hadrons to choose from. By default only the pseudoscalar and vector meson nonet (L=0) and baryons with u/d/s quarks are included. For an already-existing heavier flavour, say c or b, this corresponds to picking only u/d/s for the new quark(s). Note: The computer time for selecting the flavour of new hadrons goes linearly with the number of hadrons included. Therefore we recommend sticking to the default options as heavier hadrons are produced less likely anyway."},{"name":"string Info::getScalesValue()","link":"EventInformation.html#anchor127","text":""},{"name":"int LHAup::id2()","link":"LesHouchesAccord.html#anchor55","text":""},{"name":"int Info::getCounter(int i)","link":"EventInformation.html#anchor105","text":"the method that gives you access to the value of the various loop counters. the counter number you want to access: counters that refer to the run as a whole, i.e. are set 0 at the beginning of the run and then only can increase. the number of successful constructor calls for the Pythia class (can only be 0 or 1). the number of times a Pythia::init() call has been begun. the number of times a Pythia::init() call has been completed successfully. the number of times a Pythia::next() call has been begun. the number of times a Pythia::next() call has been completed successfully. counters that refer to each individual event, and are reset and updated in the top-level Pythia::next() method. the number of times the selection of a new hard process has been begun. Normally this should only happen once, unless a user veto is set to abort the current process and try a new one. the number of times the selection of a new hard process has been completed successfully. as 11, but additionally the process should survive any user veto and go on to the parton- and hadron-level stages. as 11, but additionally the process should survive the parton- and hadron-level stage and any user cuts. the number of times the loop over parton- and hadron-level processing has begun for a hard process. Is reset each time counter 12 above is reached. the number of times the above loop has successfully completed the parton-level step. the number of times the above loop has successfully completed the checks and user vetoes after the parton-level step. the number of times the above loop has successfully completed the hadron-level step. the number of times the above loop has successfully completed the checks and user vetoes after the hadron-level step. counters that refer to a local part of the individual event, and are reset at the beginning of this part. the current system being processed in PartonLevel::next(). Is almost always 1, but for double diffraction the two diffractive systems are 1 and 2, respectively. the number of times the processing of the current system (see above) has begun. the number of times a step has begun in the combined MPI/ISR/FSR evolution downwards in pT for the current system. the number of times MPI has been selected for the downwards step above. the number of times ISR has been selected for the downwards step above. the number of times FSR has been selected for the downwards step above. the number of times MPI has been accepted as the downwards step above, after the vetoes. the number of times ISR has been accepted as the downwards step above, after the vetoes. the number of times FSR has been accepted as the downwards step above, after the vetoes. the number of times a step has begun in the separate (optional) FSR evolution downwards in pT for the current system. the number of times FSR has been selected for the downwards step above. the number of times FSR has been accepted as the downwards step above, after the vetoes. counters that are unused (currently), and that therefore are free to use, with the help of the two methods below."},{"name":"Zprime:universality","link":"NewGaugeBosonProcesses.html#anchor3","text":"If on then you need only set the first-generation couplings below, and these are automatically also used for the second and third generation. If off, then couplings can be chosen separately for each generation."},{"name":"double Particle::charge()","link":"ParticleProperties.html#anchor66","text":""},{"name":"int SigmaProcess::idSChannel()","link":"SemiInternalProcesses.html#anchor23","text":"normally no intermediate state is shown in the event record for 2 &rarr; 2 and 2 &rarr; 3 processes. However, in case that idSChannel is overloaded to return a nonzero value, an intermediate particle with that identity code is inserted into the event record, to make it a 2 &rarr; 1 &rarr; 2 or 2 &rarr; 1 &rarr; 3 process. Thus if both isSChannel and idSChannel are overloaded, a process will behave and look like it proceeded through a resonance. The one difference is that the implementation of the matrix element is not based on the division into a production and a decay of an intermediate resonance, but is directly describing the transition from the initial to the final state."},{"name":"LeftRightSymmmetry:lgm2HRe","link":"LeftRightSymmetryProcesses.html#anchor11","text":"Scatterings l_i gamma &rarr; H_R^-- e^+. Code 3142."},{"name":"unsigned int Info::getWeightsDetailedSize()","link":"EventInformation.html#anchor121","text":""},{"name":"UncertaintyBands:nFlavQ","link":"Variations.html#anchor9","text":"Number of quark flavours controlled via Q2QG keywords, with higher ID codes controlled by X2XG keywords. Thus a change to 5 would mean that top-quark variations would use X2XG keyword values instead of the corresponding Q2QG ones."},{"name":"void RotBstMatrix::rotbst(const RotBstMatrixAMPERSAND Min);","link":"FourVectors.html#anchor84","text":"combine the current matrix with another one."},{"name":"void ParticleData::rescaleBR(int id, double newSumBR = 1.)","link":"ParticleDataScheme.html#anchor79","text":"rescales all partial branching ratios by a common factor, such that the sum afterward becomes newSumBR."},{"name":"HiddenValley:alphaFSR","link":"HiddenValleyProcesses.html#anchor35","text":"fixed alpha scale of gv/gammav emission; corresponds to alpha_strong of QCD or alpha_em of QED. For shower branchings such as Dv &rarr; Dv + gv the coupling is multiplied by C_F = (N^2 - 1) / (2 * N) for an SU(N) group and for gv &rarr; gv + gv by N."},{"name":"ExtraDimensionsLED:dijets","link":"ExtraDimensionalProcesses.html#anchor52","text":"Common switch for the group of lowest-order jet jet production processes with graviton exchange, i.e. the six ones below."},{"name":"Four-Vectors","link":"FourVectors.html","text":"Four-Vectors The Vec4 class gives a simple implementation of four-vectors. The member function names are based on the assumption that these represent four-momentum vectors. Thus one can get or set p_x, p_y, p_z and e , but not x, y, z or t. This is only a matter of naming, however; a Vec4 can equally well be used to store a space-time four-vector. The Particle object contains a Vec4 p that stores the particle four-momentum, and another Vec4 vProd for the production vertex. For the latter the input/output method names are adapted to the space-time character rather than the normal energy-momentum one. Thus a user would not normally access the Vec4 classes directly, but only via the methods of the Particle class, see Particle Properties. Nevertheless you are free to use the PYTHIA four-vectors, e.g. as part of some simple analysis code based directly on the PYTHIA output, say to define the four-vector sum of a set of particles. But note that this class was never set up to allow complete generality, only  to provide the operations that are of use inside PYTHIA. There is no separate class for three-vectors, since such can easily be represented by four-vectors where the fourth component is not used. Four-vectors have the expected functionality: they can be created, copied, added, multiplied, rotated, boosted, and manipulated in other ways. Operator overloading is implemented where reasonable. Properties can be read out, not only the components themselves but also for derived quantities such as absolute momentum and direction angles. Constructors and basic operators A few methods are available to create or copy a four-vector: Member methods for input The values stored in a four-vector can be modified in a few different ways: Member methods for output A number of methods provides output of basic or derived quantities: Friend methods for output There are also some friend methods that take one, two or three four-vectors as argument. Several of them only use the three-vector part of the four-vector. Operations with four-vectors Of course one should be able to add, subtract and scale four-vectors, and more: There are also a few related operations that are normal member methods: Rotations and boosts A common task is to rotate or boost four-vectors. In case only one four-vector is affected the operation may be performed directly on it. However, in case many particles are affected, the helper class RotBstMatrix can be used to speed up operations. For a longer sequence of rotations and boosts, and where several Vec4 are to be rotated and boosted in the same way, a more efficient approach is to define a RotBstMatrix , which forms a separate auxiliary class. You can build up this 4-by-4 matrix by successive calls to the methods of the class, such that the matrix encodes the full sequence of operations. The order in which you do these calls must agree with the imagined order in which the rotations/boosts should be applied to a four-momentum, since in general the operations do not commute. (Mathematically you would e.g. define M = M_3 M_2 M_1 in that M p = M_3( M_2( M_1 p) ) ). That is, operations on the four-vector p are carried out in the order first M_1 , then M_2 and finally M_3. Thus M_1, M_2, M_3 is also the order in which you should input rotations and boosts to M .)"},{"name":"ParticleDecays:tau0Max","link":"ParticleDecays.html#anchor2","text":"The above tau0Max , expressed in mm/c."},{"name":"int Particle::intPol()","link":"ParticleProperties.html#anchor34","text":"if the polarization value is within 1e-10 of an integer 0, +-1, +-2 or 9 then this integer is returned, else -9. Is useful when the double-precision value returned by pol() is really intended to represent an integer, e.g. a helicity eigenstate."},{"name":"StringPT:tempPreFactor","link":"Fragmentation.html#anchor31","text":"Temperature prefactor for strange quarks and diquarks. Default is determined to have the same average pT in u/d &rarr; s and s &rarr; u/d transistions."},{"name":"long Info::nTried(int i = 0)","link":"EventInformation.html#anchor100","text":""},{"name":"Merging:nJetMax","link":"CKKWLMerging.html#anchor4","text":"Maximal number of additional jets in the matrix element. Note that the EW-improved 'merging of mergings' strategy presented in Chr15a requires a different meaning of 'additional', as explained in the 'Electroweak Merging' section below."},{"name":"bool Settings::getIsInit()","link":"SettingsScheme.html#anchor77","text":"return true if the database has been initialized, else false."},{"name":"HiggsSM:qg2Hq","link":"HiggsProcesses.html#anchor16","text":"Scattering q g &rarr; H^0 q. This process gives first-order corrections to the f fbar &rarr; H^0 one above, and should only be used to study  the high- pT tail, while f fbar &rarr; H^0 should be used for inclusive production. Only the dominant c and b contributions are included, and generated separately for technical reasons. Note that another first-order process would be q qbar &rarr; H^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any b at large pT , however, so is less interesting for many applications. Code 911."},{"name":"double Particle::pz()","link":"ParticleProperties.html#anchor11","text":""},{"name":"SpaceShower:pTminChgQ","link":"SpacelikeShowers.html#anchor17","text":"Parton shower cut-off pT for photon coupling to a coloured particle."},{"name":"bool Settings::readString(string line, bool warn = true)","link":"SettingsScheme.html#anchor6","text":"read in a string, and change the relevant quantity in the database. It is normally used indirectly, via Pythia::readString(...) and Pythia::readFile(...). the string to be interpreted as an instruction. write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. Note: the method returns false if it fails to make sense out of the input string."},{"name":"Merging:doMGMerging","link":"CKKWLMerging.html#anchor7","text":"Even easier, but highly non-general, is to perform the merging with MadGraph/MadEvent-produced LHE files, with a merging scale defined by a kT cut.  For this, set this switch to on. The merging scale value will be read from  the +1 jet LHE file by searching for the string ktdurham , and  extracting the value from value  = ktdurham. Also, the hard  process will be read from the +0 jet LHE file, from the line containing  the string \@1 (the tag specifying the first process in the  MadGraph process card). For this to work, PYTHIA should be initialised on LHE files called NameOfYourLesHouchesFile_0.lhe (+0 jet sample) and NameOfYourLesHouchesFile_1.lhe (+1 jet sample) and the same naming convention for LHE files with two or more additional jets. Since for this option, the merging scale value is read from the LHEF, no merging scale value needs to be supplied by setting Merging:TMS.  Also, the hard process is read from LHEF, the input Merging::Process does not have to be defined. However, the maximal number of merged jets still has to be supplied by setting Merging:nJetMax."},{"name":"MultipartonInteractions:alphaSvalue","link":"MultipartonInteractions.html#anchor2","text":"The value of alpha_strong at m_Z. Default value is picked equal to the one used in CTEQ 5L."},{"name":"double Particle::m2Calc()","link":"ParticleProperties.html#anchor39","text":"(squared) mass calculated from the four-momentum; should agree with m(), m2() up to roundoff. Negative for spacelike virtualities."},{"name":"StringFlav:mesonCL1S0J1","link":"FlavourSelection.html#anchor22","text":"the relative pseudovector production ratio (L=1,S=0,J=1) /pseudoscalar for charm mesons."},{"name":"Bottomonium:qqbar2doublebbbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor82","text":"Colour-singlet production of 3S1 bottomonium state pairs via q qbar &rarr; bbbar[3S1(1)] bbbar[3S1(1)]. Code 522."},{"name":"bool LHAupAlpgen::addResonances()","link":"AlpgenEventInterface.html#anchor7","text":"This is a private method used when an event is read in. The information read from the event file does not always contain a complete listing of all particles and four-momenta, and so various details must be reconstructed. Exactly which details are filled in can vary based on the ALPGEN process in question."},{"name":"bool ParticleDataEntry::isParton()","link":"ParticleDataScheme.html#anchor144","text":"true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"virtual bool MyHardProcess::exchangeCandidates(  vectorAMPERSANDlt;intAMPERSANDgt; candidates1, vectorAMPERSANDlt;intAMPERSANDgt; candidates2, mapAMPERSANDlt;int,  intAMPERSANDgt; further1, mapAMPERSANDlt;int, intAMPERSANDgt; further2)","link":"MatchingAndMerging.html#anchor31","text":"This function implements the replacement of a list of core scattering candidates by another list of candidates."},{"name":"void Particle::bst(double betaX, double betaY, double betaZ,  double gamma)","link":"ParticleProperties.html#anchor108","text":"as above, but also input the gamma value, to reduce roundoff errors."},{"name":"StandardModel:alphaSnfmax","link":"StandardModelParameters.html#anchor1","text":"Use 5-flavour running for all scales above the b flavour threshold (old default). Use 6-flavour running above the t threshold (new default)."},{"name":"PDF:pSet","link":"PDFSelection.html#anchor2","text":"Parton densities to be used for proton beams (and, by implication, antiproton ones). Note that the choice of a string input (rather than e.g. an integer) allows to pick either an internal, LHAPDF5 or LHAPDF6 set in one single setting, by some behind-the-scenes machinations. GRV 94L, LO alpha_s(M_Z) = 0.128 (this set is out of date, but retained for historical comparisons). CTEQ 5L, LO alpha_s(M_Z) = 0.127 (this set is also out of date, but not badly so, and many tunes are based on it). MRST LO* (2007), NLO alpha_s(M_Z) = 0.12032. MRST LO** (2008), NLO alpha_s(M_Z) = 0.11517. MSTW 2008 LO (central member), LO alpha_s(M_Z) = 0.13939. MSTW 2008 NLO (central member), NLO alpha_s(M_Z) = 0.12018 (NLO, see Warning 3 above). CTEQ6L, NLO alpha_s(M_Z) = 0.1180. CTEQ6L1, LO alpha_s(M_Z) = 0.1298. CTEQ66.00 (NLO, central member), NLO alpha_s(M_Z) = 0.1180 (NLO, see Warning 3 above). CT09MC1, LO alpha_s(M_Z) = 0.1300. CT09MC2, NLO alpha_s(M_Z) = 0.1180. CT09MCS, NLO alpha_s(M_Z) = 0.1180. NNPDF2.3 QCD+QED LO alpha_s(M_Z) = 0.130. NNPDF2.3 QCD+QED LO alpha_s(M_Z) = 0.119. NNPDF2.3 QCD+QED NLO alpha_s(M_Z) = 0.119. NNPDF2.3 QCD+QED NNLO alpha_s(M_Z) = 0.119. NNPDF3.1 QCD LO alpha_s(M_Z) = 0.130. Warning : the NNPDF 3.1 sets are quite different from the NNPDF 2.3 ones, and cannot be used interchangeably but need retuning of the MPI framework. NNPDF3.1 QCD LO alpha_s(M_Z) = 0.118. NNPDF3.1 QCD NLO alpha_s(M_Z) = 0.118. NNPDF3.1 QCD NNLO alpha_s(M_Z) = 0.118. Use an external LHAPDF set where set is the name of the set to use and member is the member of the set to use. The value for set is the name of the PDF set to use while the value for member must be an integer and is the member of the set to use. If member is not supplied, then 0 is assumed. Same as for LHAPDF5:set/member but now the LHAPDF6 library is used instead. Use the internal implementation of interpolation in .dat files in the default 'lhagrid1' LHAPDF6 format. This is a simplified implementation, with cubic interpolation in ln(x) and in ln(Q2). If there are several Q^2 subgrids they have to have the same x grid. (Linear interpolation in ln(Q2) is used, should a subgrid contain fewer than four Q2 values.) Other restrictions may also apply, so use with caution. If the filename begins with a / it is supposed to contain the absolute path to the file, and if not the file is supposed to be located in the standard share/Pythia8/xmldoc directory. Warning 1: the alpha_s(M_Z) values and the order of the running in the description above is purely informative, and does not affect any other parts of the program. Instead you have the freedom to set alpha_s(M_Z) value and running separately for hard processes (including resonance decays), multiparton interactions , initial-state radiation , and final-state radiation. Warning 2: in order for LHAPDF PDF sets to work you must have compiled the approriate LHAPDF plugins for PYTHIA and have set the LHAPATH environment variable (or LHAPDF_DATA_PATH ) to provide the data-files directory of your local LHAPDF installation. See the README file in the examples directory for further instructions. Warning 3: it is technically possible to simultaneously use LHAPDF5 and LHAPDF6 PDF sets at the same time for the two beams, but such a configuration is not officially supported and strongly discouraged."},{"name":"double Particle::yDec()","link":"ParticleProperties.html#anchor57","text":""},{"name":"virtual void TimeShower::update( int iSys, EventAMPERSAND event,  bool hasWeakRad = false)","link":"ImplementNewShowers.html#anchor13","text":"This method is called immediately after a spacelike branching in the iSys 'th subsystem. Thus the information for that system is out-of-date, while that of the others is unchanged. If you want, you are free to throw away all information for the affected subsystem and call prepare( iSys, event) to create new one. Alternatively you may choose only to update the information that has changed. The optional final argument is used to signal if a weak radiation has occured in the spacelike evolution, which might be used to switch off the timelike weak emissions."},{"name":"bool LHAupAlpgen::rescaleMomenta()","link":"AlpgenEventInterface.html#anchor8","text":"This is another private method used when an event is read in. It shuffles and rescales momenta in an event to ensure energy-momentum conservation.  First, pT is made to balance by splitting any imbalance between all outgoing particles with their energies also scaled. Second, the e/pZ of the two incoming particles are scaled to balance the outgoing particles. Finally, any intermediate resonances are recalculated from their decay products."},{"name":"bool DecayChannel::contains(int id1)","link":"ParticleDataScheme.html#anchor183","text":""},{"name":"void ParticleDataEntry::rescaleBR(double newSumBR = 1.)","link":"ParticleDataScheme.html#anchor156","text":"rescales all partial branching ratios by a common factor, such that the sum afterward becomes newSumBR."},{"name":"void ParticleDataEntry::setHasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor132","text":""},{"name":"ExtraDimensionsUnpart:qqbar2Ug","link":"ExtraDimensionalProcesses.html#anchor73","text":"Scatterings q qbar &rarr; U g. Code 5047."},{"name":"Charmonium:gg2ccbar(3DJ)[3DJ(1)]g","link":"OniaProcesses.html#anchor36","text":"Colour-singlet production of 3PJ charmonium states via g g &rarr; ccbar[3DJ(1)] g. Code 417."},{"name":"Diffraction:MBRm2Min","link":"Diffraction.html#anchor8","text":"the lowest value of the mass squared of the dissociated system."},{"name":"friend Hist operator-(double f, const HistAMPERSANDamp; h1)","link":"Histograms.html#anchor34","text":""},{"name":"ExtraDimensionsLED:NegInt","link":"ExtraDimensionalProcesses.html#anchor63","text":"Allows to change sign of the interference terms in the graviton exchange processes, common in connection to using the Hewett convention Hew99. 1 -1"},{"name":"ExcitedFermion:bg2bStar","link":"CompositenessProcesses.html#anchor6","text":"Scatterings b g &rarr; b^*. Code 4005."},{"name":"POWHEG:nFinal","link":"POWHEGMerging.html#anchor1","text":"Number of outgoing particles of POWHEG Born level process, i.e. not counting additional POWHEG radiation."},{"name":"void ParticleData::names(int id,  string name, string antiName)","link":"ParticleDataScheme.html#anchor30","text":""},{"name":"virtual bool MyHardProcess::findOtherCandidates(int iPos, const  EventAMPERSAND event, bool doReplace)","link":"MatchingAndMerging.html#anchor30","text":"The argument iPos specifies the position of a particle in the input event which is tagged as part of the core scattering. This function may be used to check the role of iPos as  core scattering member may be filled by another particle in the event record. If so, and if doReplace=true , then iPos will no longer be book-kept as part of the core scattering. An example where this functionality is helpful is if the input event is g g -> b b~ b  b~, and the core scattering is g g -> b b~. Not swapping the hard process candidates could in this case mean that not all parton shower histories can be found. The function should return false if no replacements can be found, and true otherwise."},{"name":"HiggsBSM:qg2H2q","link":"HiggsProcesses.html#anchor69","text":"Scattering q g &rarr; H^0 q. This process gives first-order corrections to the f fbar &rarr; H^0 one above, and should only be used to study  the high- pT tail, while f fbar &rarr; H^0 should be used for inclusive production. Only the dominant c and b contributions are included, and generated separately for technical reasons. Note that another first-order process would be q qbar &rarr; H^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any b at large pT , however, so is less interesting for many applications. Code 1031."},{"name":"virtual Vec4 vertexForISR( ParticleAMPERSAND rad)","link":"UserHooks.html#anchor53","text":"Method to assign production vertex to a particle produced in ISR ( SpaceShower ). Should return the production vertex as a Vec4. is (the address of) the radiating particle as above."},{"name":"Zprime:vtPrime","link":"NewGaugeBosonProcesses.html#anchor33","text":"vector coupling of t' quarks."},{"name":"ExtraDimensionsG*:Gll","link":"ExtraDimensionalProcesses.html#anchor11","text":"Coupling between graviton and leptons."},{"name":"mapAMPERSANDlt;string, PVecAMPERSANDgt; Settings::getPVecMap(string match)","link":"SettingsScheme.html#anchor55","text":""},{"name":"Merging:aCollISR","link":"CKKWLMerging.html#anchor44","text":"Factor with which to multiply the scalar pT of an initial state splitting, when choosing the history by the smallest sum of scalar pT. Default value taken from Herwig++ Tul09."},{"name":"HiggsBSM:qg2H1q(l:t)","link":"HiggsProcesses.html#anchor67","text":"Scattering q g &rarr; h^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1015."},{"name":"ExtraDimensionsG*:SMinBulk","link":"ExtraDimensionalProcesses.html#anchor8","text":"Parameter to choose between the two scenarios: off , SM on the TeV brane (common kappaMG coupling); on , SM in the ED bulk (flavour dependent couplings). This parameter is only relevant for the lowest-order graviton ( G* ) processes, where as the first-order processes corresponds to the off scenario."},{"name":"Charmonium:qg2ccbar(3S1)[1S0(8)]q","link":"OniaProcesses.html#anchor19","text":"Colour-octet production of 3S1 charmonium states via q g &rarr; ccbar[1S0(8)] q. Code 406."},{"name":"double CoupSM::sin2thetaW()","link":"StandardModelParameters.html#anchor25","text":""},{"name":"WeakShower:vetoWeakJets","link":"WeakShowers.html#anchor3","text":"There are two ways to produce weak bosons in association with jets, namely Drell-Yan weak production with QCD radiation and QCD hard process with weak radiation. In order to avoid double counting between the two production channels, a veto procedure built on the kT jet algorithm is implemented in the evolution starting from a 2 &rarr; 2 QCD process, process codes in the range 111 - 129. The veto algorithm finds the first cluster step, and if it does not involve a weak boson the radiation of the weak boson is vetoed when WeakShower:vetoWeakJets is on. Note that this flag does not affect other internal or external processes, only the 111 - 129 ones. For the Drell-Yan process the same veto algorithm is used, but this time the event should be vetoed if the first clustering does contain a weak boson, see WeakShower:vetoQCDjets below."},{"name":"RotBstMatrix::RotBstMatrix(const RotBstMatrixAMPERSAND Min)","link":"FourVectors.html#anchor74","text":"creates a copy of the input matrix."},{"name":"void ParticleData::name(int id, string name)","link":"ParticleDataScheme.html#anchor28","text":""},{"name":"bool SlowJet::doStep()","link":"EventAnalysis.html#anchor58","text":"do the next step of the clustering. This can either be that two clusters are joined to one, or that a cluster is promoted to a jet (which is discarded if its pT value is below pTjetMin ). The routine will only return false if there are no clusters left, or if useFJcore = true."},{"name":"bool Pythia8ToHepMC::print_inconsistency()","link":"HepMCInterface.html#anchor6","text":"print a warning line, on cerr , when inconsistent mother and daughter information is encountered."},{"name":"MultipartonInteractions:alphaEMorder","link":"MultipartonInteractions.html#anchor4","text":"The running of alpha_em used in hard processes. first-order running, constrained to agree with StandardModel:alphaEMmZ at the Z^0 mass. zeroth order, i.e. alpha_em is kept fixed at its value at vanishing momentum transfer. zeroth order, i.e. alpha_em is kept fixed, but at StandardModel:alphaEMmZ , i.e. its value at the Z^0 mass."},{"name":"HardQCD:qg2qg","link":"QCDProcesses.html#anchor11","text":"Scatterings q g &rarr; q g and qbar g &rarr; qbar g. Code 113."},{"name":"double Info::weight()","link":"EventInformation.html#anchor73","text":"weight assigned to the current event. Is normally 1 and thus uninteresting. However, there are several cases where one may have nontrivial event weights. These weights must the be used e.g. when filling histograms. (i) In the PhaseSpace:increaseMaximum = off default strategy, an event with a differential cross-section above the assumed one (in a given phase-space point) is assigned a weight correspondingly above unity. This should happen only very rarely, if at all, and so could normally be disregarded. (ii) The User Hooks class offers the possibility to bias the selection of phase space points, which means that events come with a compensating weight, stored here. (iii) For Les Houches events some strategies allow negative weights, which then after unweighting lead to events with weight -1. There are also Les Houches strategies where no unweighting is done, so events come with a weight. Specifically, for strategies +4 and -4 , the event weight is in units of pb. (Internally in mb, but converted at output.)"},{"name":"double Info::getScalesAttribute(string key)","link":"EventInformation.html#anchor128","text":"Return the value of the <scales> tag's attribute named key. Not-a-number will be returned if the attribute named key does not exist."},{"name":"HadronLevel:Decay","link":"MasterSwitches.html#anchor14","text":"Master switch for decays; on/off = true/false. Further options are found here."},{"name":"Alpgen:setMLM","link":"AlpgenEventInterface.html#anchor4","text":"When switched on, the merging parameters (see below) are set according to the ALPGEN hard process cuts: JetMatching:eTjetMin = min(ptjmin + 5., 1.2 * ptjmin) , JetMatching:coneRadius = drjmin , JetMatching:etaJetMax = etajmax. where the ptjmin , drjmin and etajmax are the incoming ALPGEN parameters. Note that any existing values of these parameters are overwritten."},{"name":"WeakBosonAndParton:qg2gmZq","link":"ElectroweakProcesses.html#anchor24","text":"Scattering q g &rarr; gamma^*/Z^0 q. Code 242."},{"name":"LeftRightSymmmetry:lgm2HLtau","link":"LeftRightSymmetryProcesses.html#anchor7","text":"Scatterings l_i gamma &rarr; H_L^-- tau^+. Code 3124."},{"name":"Check:mTolWarn","link":"ErrorChecks.html#anchor10","text":"A check on the deviation as above, but counted as a warning rather than an error."},{"name":"Les Houches Accord","link":"LesHouchesAccord.html","text":"Les Houches Accord The Les Houches Accord (LHA) for user processes Boo01 is the standard way to input parton-level information from a matrix-elements-based generator into PYTHIA. The conventions for which information should be stored has been defined in a Fortran context, as two commonblocks. Here a C++ equivalent is defined, as a single class. The most common application is to read input from a Les Houches Event File (LHEF) Alw06 , but it is also possible to have a runtime interface to another program. A 'no-beams' extension, currently not part of the standard, has been implemented. In this case only one part of a complete event is studied, and so no meaningful beam information can be set. The prime example is to study the decay properties of a resonance, where a parton-level decay chain is provided as input, and then showers and nadronization should be added. Another example would be where a given partonic configuration would be hadronized, without any previous showers. See further below and in the Hadron-Level Standalone description. The LHAup class is a base class, containing reading and printout functions, plus two pure virtual functions, one to set initialization information and one to set information on each new event. Derived classes have to provide these two virtual functions to do the actual work. The existing derived classes are for reading information from a Les Houches Event File, from the respective Fortran commonblocks, or from PYTHIA 8 itself. You are free to write your own derived classes, using the rules and methods to be described below. Normally, pointers to objects of such derived classes should be handed in with the Pythia::setLHAupPtr( LHAup*) method. However, with the LHEF format a filename can replace the pointer, see further below. Let us now describe the methods at your disposal to do the job. Initialization The LHAup class stores information equivalent to the /HEPRUP/ commonblock, as required to initialize the event generation chain. The main difference is that the vector container now allows a flexible number of subprocesses to be defined. For the rest, names have been modified, since the 6-character-limit does not apply, and variables have been regrouped for clarity, but nothing fundamental is changed. Inside setInit() , such information can be set by the following methods: Note : PYTHIA does not make active use of the (optional) xErr values, but calculates a statistical cross section error based on the spread of event-to-event weights. This should work fine for strategy options +-1, but not for the others. Specifically, for options +-2 and +-3 the weight spread may well vanish, and anyway is likely to be an underestimate of the true error. If the author of the LHA input information does provide error information you may use that - this information is displayed at initialization. If not, then a relative error decreasing like 1/sqrt(n_acc) , where n_acc is the number of accepted events, should offer a reasonable estimate. Information is handed back by the following methods (that normally you would not need to touch): Event input The LHAup class also stores information equivalent to the /HEPEUP/ commonblock, as required to hand in the next parton-level configuration for complete event generation. The main difference is that the vector container now allows a flexible number of partons to be defined. For the rest, names have been modified, since the 6-character-limit does not apply, and variables have been regrouped for clarity, but nothing fundamental is changed. The LHA standard is based on Fortran arrays beginning with index 1, and mother information is defined accordingly. In order to be compatible with this convention, the zeroth line of the C++ particle array is kept empty, so that index 1 also here corresponds to the first particle. One small incompatibility is that the sizePart() method returns the full size of the particle array, including the empty zeroth line, and thus is one larger than the true number of particles ( NUP ). Inside a normal setEvent(...) call, information can be set by the following methods: Information is handed back by the following methods: From the information in the event record it is possible to set the flavour and x values of the initiators This information is returned by the methods In the LHEF description Alw06 an extension to include information on the parton densities of the colliding partons is suggested. This optional further information can be set by This information is returned by the methods The maximum scale for parton-shower evolution of a Les Houches event is regulated by the TimeShower:pTmaxMatch and SpaceShower:pTmaxMatch modes. If you want to guarantee that the input scale value is respected, as is often the case in matching/merging procedures, you should set both of these modes to 1. That only affects the hard process, while resonance decays are still processed using the resonance mass to set the upper limit. However, the optional Beams:strictLHEFscale = on setting restricts also resonance-decay emissions to be below the input scale value. As a further non-standard feature, it is also possible to read in the separate scale values of all final particles. Such scale values could be used e.g. to restrict the maximum scale for shower evolutions for each parton separately. This reading will only be applied if the Beams:setProductionScaleFromLHEF switch is true (see Beam Parameters for details). This information is returned by the method double LHAup::scale(int i). When no such information has been read from the LHEF, the scale defaults to -1. The LHA expects the decay of resonances to be included as part of the hard process, i.e. if unstable particles are produced in a process then their decays are also described. This includes Z^0, W^+-, H^0 and other short-lived particles in models beyond the Standard Model. Should this not be the case then PYTHIA will perform the decays of all resonances it knows how to do, in the same way as for internal processes. Note that you will be on slippery ground if you then restrict the decay of these resonances to specific allowed channels since, if this is not what was intended, you will obtain the wrong cross section and potentially the wrong mix of different event types. (Since the original intention is unknown, the cross section will not be corrected for the fraction of open channels, i.e. the procedure used for internal processes is not applied in this case.) Even if PYTHIA can select resonance decay modes according to its internal tables, there is normally no way for it to know which decay angular correlations should exist in the simulated process. Therefore almost all decays are isotropic. The exceptions are Higgs and top decays, in the decay chains H &rarr; WW/ZZ &rarr; f fbar f' fbar' and t &rarr; b W &rarr; b f fbar , where the process-independent correlations implemented for internal processes are used. If part of the decay chain has already been set, however (e.g. H &rarr; WW/ZZ or t &rarr; b W ), then decay is still isotropic. Transfer to the PYTHIA process record There are a few settings available for event input. They take effect when the LHA event record is translated to the PYTHIA process event record, but leaves the LHA event record itself unchanged. An interface to Les Houches Event Files The LHEF standard ( Alw06 , But14 ) specifies a format where a single file packs initialization and event information. This has become the most frequently used procedure to process external parton-level events in Pythia. To access this, you must set Beams:frameType = 4 and Beams:LHEF to be the file name, see Beam Parameters. Internally this name is then used to create an instance of the derived class LHAupLHEF , which can do the job of reading an LHEF. As some information in a Les Houches Event File init block is only known at the end of generation, some programs choose to output this as a separate file. If so, the name of this file can be specified by Beams:LHEFheader. The two key compulsory parts of an LHEF is the initialization information stored in an init block, enclosed by a matching <init> - </init> pair of lines, and the event input, with each event enclosed by a matching <event> - </event> pair of lines. In the case of the no-beams extension the init block may be empty, but the <init> and </init> lines must be included for the file parsing to work as expected. It is also possible to have a non-empty init block, with the beams assigned code 0, and optionally a number of specified 'processes'. The latest update of the LHEF format But14 introduced a multitude of different optional features. This means that apart from the <init> and <event> tags, a plethora of new, optional information is available. Furthermore, the inclusion of an arbitrary number of attributes into the tags should be supported. The LHEF reader in Pythia adheres to the updated LHEF format without any restriction. The new generation information available through the updated LHEF format can be retrieved by using Pythia's Info class. For a detailed description, please consult the section 'Les Houches Event File 3.0 information' in Event Information. The LHEF reader can also read in and store header blocks. By default this option is switched on, but may be controlled through the Beams:readLHEFheaders flag if necessary. The information can later be read out through the Info class for further processing. Due to the non-standard nature of the information in these blocks they are stored whole, and PYTHIA itself makes no further attempt to process their meaning. Because Les Houches Event files tend not to adhere strictly to XML conventions, to consistently read in header information, certain choices must be made. The primary goal is to make as much information available as possible. First, information sitting directly in the <header> block is stored under the key 'base'. Second, the tags starting and ending each sub block must be on their own line. Finally, the contents of comment blocks, <!-- -->, are still stored. The header keys are formed hierarchically from the names of the header blocks. This behaviour is illustrated in the following example: <header>    BaseA    <hblock1>     1A     <hblock11>      11A <hblock111>      </hblock111> 11B     </hblock11>     1B    </hblock1>    <hblock2>     2A     <!-- 2B -->    </hblock2>    BaseB  </header> which would lead to the following information being stored in the Info class: Key Value base BaseA BaseB hblock1 1A 1B hblock1.hblock11 11A <hblock111> </hblock111> 11B hblock2 2A <!-- 2B --> Normally the LHEF would be in uncompressed format, and thus human-readable if opened in a text editor. A possibility to read gzipped files has been added, based on the Boost and zlib libraries, which therefore have to be linked appropriately in order for this option to work. See the README file in the main directory for details on how to do this. An example how to generate events from an LHEF is found in main11.cc. Note the use of Info::atEndOfFile() to find out when the whole LHEF has been processed. To allow the sequential use of several event files, the Beams:newLHEFsameInit can be set true. Then there will be no initialization, except that the existing LHAupLHEF class instance will be deleted and replaced by one pointing to the new file. It is assumed (but never checked) that the initialization information is identical, and that the new file simply contains further events of exactly the same kind as the previous one. An example of this possibility, and the option to mix with internal processes, is found in main12.cc. A variant, based on input in a command file, is given in main13.cc. In C++, real numbers are printed with an 'E' to denote the exponent part, e.g. 1.23E+04, and are read in accordingly. Other languages may use other letters, e.g. Fortran allows either 'E' or 'D'. A file using the latter convention would not be readable by the standard routines. In case you have such an 'incorrectly formatted' file, a conversion to a new corrected file could be done e.g. using sed , as a one-line command sed -e 's/\([0-9]\.\{0,1\}\)[dD]\([+-]\{0,1\}[0-9]\)/\1E\2/g' old.lhe > new.lhe This replaces a 'd' or 'D' with an 'E' only when it occurs in the combination (digit) ('.' or absent) ('d' or 'D') ('+', '-' or absent) (digit) It will work on all parts of the file, also inside a <header>...</header> block. For conversion only inside the <init>...</init> and <event>...</event> blocks, create a file convert.sed containing /<init>/,/<\/init>/bconv  /<event>/,/&lt\/event>/bconv  b  :conv  s/\([0-9]\.\{0,1\}\)[dD]\([+-]\{0,1\}[0-9]\)/\1E\2/g and run it with sed -f convert.sed old.lhe > new.lhe The workhorses of the LHAupLHEF class are three methods found in the base class, so as to allow them to be reused in other contexts. These three main methods build on a number of container classes and a generic LHEF reader class (called Reader ) found in LHEF3.h and LHEF3.cc. The Reader handles all the parsing and storage necessary to adhere with But14. (A matching Writer class is also available; see documentation in LHEF3.h how it can be used.) All parsing that is not strictly part of the LHEF format (e.g. the reading of header information) is instead performed directly in the LHAupLHEF methods. Some other small utility routines are: A few other methods, most of them derived from the base class, streamlines file opening and closing, e.g. if several LHE files are to be read consecutively, without the need for a complete reinitialization. This presupposes that the events are of the same kind, only split e.g. to limit file sizes. A runtime Fortran interface The runtime Fortran interface requires linking to an external Fortran code. In order to avoid problems with unresolved external references when this interface is not used, the code has been put in a separate include/Pythia8Plugins/LHAFortran.h file, that is not included in any of the other library files. Instead it should be included in the user-supplied main program, and used to create a derived class that contains the implementation of two methods below that call the Fortran program to do its part of the job. The LHAupFortran class derives from LHAup. It reads initialization and event information from the LHA standard Fortran commonblocks, assuming these commonblocks behave like two extern 'C' struct named heprup_ and hepeup_. (Note the final underscore, to match how the gcc compiler internally names Fortran files.) The instantiation does not require any arguments. The user has to supply implementations of the fillHepRup() and fillHepEup() methods, that is to do the actual calling of the external Fortran routines that fill the HEPRUP and HEPEUP commonblocks. The translation of this information to the C++ structure is provided by the existing setInit() and setEvent() code. Up to and including version 8.125 the LHAupFortran class was used to construct a runtime interface to PYTHIA 6.4. This was convenient in the early days of PYTHIA 8 evolution, when this program did not yet contain hard-process generation, and the LHEF standard did not yet exist. Nowadays it is more of a bother, since a full cross-platform support leads to many possible combinations. Therefore this support has been removed, but can still be recuperated from previous code versions, in a reduced form up to version 8.176. Methods for LHEF output The main objective of the LHAup class is to feed information from an external program into PYTHIA. It can be used to export information as well, however. Specifically, there are four routines in the base class that can be called to write a Les Houches Event File. These should be called in sequence in order to build up the proper file structure. PYTHIA 8 output to a Les Houches Event File version 1.0 The above methods could be used by any program to write an LHEF. For PYTHIA 8 to do this, a derived class already exists, LHAupFromPYTHIA8. In order for it to do its job, it must gain access to the information produced by PYTHIA, specifically the process event record and the generic information stored in info. Therefore, if you are working with an instance pythia of the Pythia class, you have to instantiate LHAupFromPYTHIA8 with pointers to the process and info objects of pythia : LHAupFromPYTHIA8 myLHA(&pythia.process, &pythia.info); The method setInit() should be called to store the pythia initialization information in the LHA object, and setEvent() to store event information. Furthermore, updateSigma() can be used at the end of the run to update cross-section information, cf. closeLHEF(true) above. An example how the generation, translation and writing methods should be ordered is found in main20.cc. Currently there are some limitations, that could be overcome if necessary. Firstly, you may mix many processes in the same run, but the cross-section information stored in info only refers to the sum of them all, and therefore they are all classified as a common process 9999. Secondly, you should generate your events in the CM frame of the collision, since this is the assumed frame of stored Les Houches events, and no boosts have been implemented for the case that Pythia::process is not in this frame. The LHEF standard is the agreed format to store the particles of a hard process, as input to generators, whereas output of final states is normally handled using the HepMC standard. It is possible to use LHEF also here, however. It requires that the above initialization is replaced by LHAupFromPYTHIA8 myLHA(&pythia.event, &pythia.info); i.e. that process is replaced by event. In addition, the PartonLevel:all = off command found in main20.cc obviously must be removed if one wants to obtain complete events. PYTHIA 8 output to a Les Houches Event File version 3.0 PYTHIA 8 also supports LHEF 3.0 output, and we include a general LHEF3 writer ( Pythia::Writer of LHEF3.h and LHEF3.cc) for this purpose. The functions of this file writer are used in the LHEF3FromPYTHIA8. This latter class allows users to output PYTHIA events in LHEF3 format from a PYTHIA main program. An example of how to use LHEF3FromPYTHIA8 is found in the main20lhef3.cc example. Please note that, although similar, the usage of LHEF3FromPYTHIA8 differs from the usage of LHAupFromPYTHIA8 , with LHEF3FromPYTHIA8 requiring fewer function calls. To print a comprehensive LHE file, LHEF3FromPYTHIA8 is constructed with pointers to an Event object, as well as pointers to instances of Settings , Info and ParticleData , giving e.g. a constructor call LHEF3FromPYTHIA8 myLHEF3(&pythia.event, &pythia.settings, &pythia.info, &pythia.particleData); As a next step, you should open the output file by using the LHAupFromPYTHIA8 member function openLHEF(string name) where name is the output file name. Then, the method setInit() should be called to store the initialization information (read from settings and info ) and write the header and init blocks into the output file. Note that at this stage, the cross section printed in the init block is not sensible, as no integration has yet taken place. The init block can be updated at the end of the event generation (see below). During event generation, you should use setEvent() to write the event information (as read from info and event ) to the output file. Finally, before leaving your main program, it is necessary to close the output file by using the LHAupFromPYTHIA8 member function closeLHEF( bool doUpdate = false) The boolean variable doUpdate is optional. If doUpdate is used, and if doUpdate = true , then the init block of the output file will be updated with the latest cross section information. Currently there are some limitations, that could be overcome if necessary. Firstly, you may mix many processes in the same run, but the cross-section information stored in info only refers to the sum of them all, and therefore they are all classified as a common process 9999. Secondly, you should generate your events in the CM frame of the collision, since this is the assumed frame of stored Les Houches events, and no boosts have been implemented for the case that Pythia::process is not in this frame."},{"name":"WeakBosonExchange:ff2ff(t:gmZ)","link":"ElectroweakProcesses.html#anchor10","text":"Scattering f f' &rarr; f f' via gamma^*/Z^0 t -channel exchange, with full interference between the gamma^* and Z^0. Code 211."},{"name":"bool Info::hasSub()","link":"EventInformation.html#anchor26","text":"does the process have a subprocess classification? Currently only true for nondiffractive and Les Houches events, where it allows the hardest collision to be identified."},{"name":"AlpgenHooks(Pythia AMPERSANDamp;pythia)","link":"AlpgenEventInterface.html#anchor15","text":"The constructor takes a PYTHIA object as input, so that the beam parameter settings can be overridden if the Alpgen:file option is given. If this is the case, an LHAupAlpgen instance is automatically created and passed to PYTHIA."},{"name":"Stat:showPartonLevel","link":"MainProgramSettings.html#anchor17","text":"Print the available statistics on number and types of multiparton interactions, where relevant."},{"name":"virtual void SpaceShower::init(BeamParticle* beamAPtrIn,  BeamParticle* beamBPtrIn)","link":"ImplementNewShowers.html#anchor30","text":"You have to store your local copy of the pointers to these objects, since they have to be used during the generation, as explained above. This is also the place to do initialization of whatever parameters you plan to use, e.g. by reading in them from a user-accessible database like the Settings one."},{"name":"WeakBosonExchange:ff2ff(t:W)","link":"ElectroweakProcesses.html#anchor11","text":"Scattering f_1 f_2 &rarr; f_3 f_4 via W^+- t -channel exchange. Code 212."},{"name":"void Event::initColTag(int colTag = 0)","link":"EventRecord.html#anchor13","text":"forces the current colour tag value to be the larger of the input colTag and the above Event:startColTag values."},{"name":"Merging:Dparameter","link":"CKKWLMerging.html#anchor3","text":"The value of the D parameter needed in the definition of longitudinally invariant kT separation."},{"name":"virtual vectorAMPERSANDlt;stringAMPERSANDgt; SpaceShower::getSplittingName(  const EventAMPERSAND event, int iRad, int iEmt, int iRec)","link":"ImplementNewShowers.html#anchor44","text":"This function should return a string identifier of the splitting producing the particles with indices iRad , iEmt and iRec in the input event. If e.g. iRad is the index of an intial state quark and iEmt the index of a final state gluon, we could imagine returning the string 'isr:Q2QG' (which is the name of such a branching in PYTHIA's UserHooks facilities). The return value is a vector to allow for multiple string identifiers, e.g. if multiple splittings lead to identical final states."},{"name":"Bottomonium:O(3DJ)[3D1(1)]","link":"OniaProcesses.html#anchor71","text":"The color-singlet long-distance matrix elements <O[3D1(1)]> for the 3PJ bottomonium states. For a 3DJ bottomonium state where J is not 1 the long distance matrix element <O[3DJ(1)]> is calculated by (2J+1)<O[3D1(1)]/3> using leading order spin symmetry relations."},{"name":"virtual bool UserHooks::doVetoPartonLevel(const EventAMPERSAND event)","link":"UserHooks.html#anchor11","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of Pythia::next(). Note: the above veto is different from setting the flag HadronLevel:all = off. Also in the latter case the event generation will stop after the parton level, but an event generated up to this point is considered perfectly acceptable. It can be studied and it contributes to the cross section. That is, HadronLevel:all = off is intended for simple studies of complete partonic states, where one can save time by not generating the complete hadronic final state. By contrast, the doVetoPartonLevel() method allows you to throw away uninteresting events to save time that way, but those events that do survive the veto are allowed to develop into complete final states (unless flags have been set otherwise)."},{"name":"TimeShower:MEafterFirst","link":"TimelikeShowers.html#anchor44","text":"Use of matrix element corrections also after the first emission, for dipole ends of the same system that did not yet radiate. Only has a meaning if MEcorrections above is switched on."},{"name":"WeakDoubleBoson:ffbar2WW","link":"ElectroweakProcesses.html#anchor21","text":"Scattering f fbar &rarr; W^+ W^-. Code 233."},{"name":"StringFragmentation:stopNewFlav","link":"Fragmentation.html#anchor36","text":"Add to W_min an amount stopNewFlav * m_q_last , where q_last is the last q qbar pair produced between the final two hadrons."},{"name":"double Sphericity::eigenValue(int i)","link":"EventAnalysis.html#anchor5","text":"gives one of the three eigenvalues for i = 1, 2 or 3, in descending order,"},{"name":"virtual void SpaceShower::list()","link":"ImplementNewShowers.html#anchor40","text":"This method is not at all required. In the current implementation it outputs a list of all the dipole ends, with information on the respective dipole. The routine is not called anywhere in the public code, but has been inserted at various places during the development/debug phase."},{"name":"SUSY:qqbar2sleptonantislepton","link":"SUSYProcesses.html#anchor22","text":"Pair production of slepton-antislepton via s-channel W, Z and gamma exchange.  Includes both charged sleptons and sneutrinos but right handed sneutrinos currently not supported."},{"name":"HiggsA3:parity","link":"HiggsProcesses.html#anchor117","text":"possibility to modify angular decay correlations in the decay of a A^0(H_3) decay Z^0 Z^0 or W^+ W^- to four fermions, or tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. isotropic decays. assuming the A^0(H_3) is a pure scalar (CP-even). assuming the A^0(H_3) is a pure pseudoscalar (CP-odd), as in the MSSM. assuming the A^0(H_3) is a mixture of the two, including the CP-violating interference term. The parameter eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to eta and the CP-odd one to eta^2. Intended for decays into W^+ W^- or Z^0 Z^0. same as 3 but now phi , see below, sets the CP-mixing angle. The CP-even term is proportional to sin^2(phi) , the interference to sin(phi)cos(phi) , and the CP-odd term to cos^2(phi). Consequently phi=0 is pure CP-odd and phi=pi/2 is pure CP-even. Intended for decays of A -> f fbar , notably for tau lepton polarization, whereas W^+ W^- and Z^0 Z^0 decays are isotropic."},{"name":"void Vec4::bstback(const Vec4AMPERSAND p, double m)","link":"FourVectors.html#anchor71","text":"boost the four-momentum by beta = (-p_x/E, -p_y/E, -p_z/E) , where the gamma = E/m is also calculated from input to allow better precision when beta is close to unity."},{"name":"void Settings::addParm(string key,  double default, bool hasMin, bool hasMax, double min, double max)","link":"SettingsScheme.html#anchor27","text":""},{"name":"friend ostreamAMPERSAND operatorAMPERSANDlt;AMPERSANDlt;(ostreamAMPERSANDamp; os, const HistAMPERSANDamp; h)","link":"Histograms.html#anchor10","text":"appends a simple histogram printout (see above for format) to the ostream , while leaving the histogram object itself unchanged. At most 100 columns are allowed to be displayed. If the number of bins is larger than 100 then the contents of adjacent bins are added to give the value in each column. (Two by two up to 200 bins, three by three up to 300, and so on, with the very last column possibly summing fewer rows than the others.)"},{"name":"BeamShape::BeamShape()","link":"BeamShape.html#anchor1","text":""},{"name":"friend Hist operator+(double f, const HistAMPERSANDamp; h1)","link":"Histograms.html#anchor31","text":""},{"name":"int Settings::mode(string key)","link":"SettingsScheme.html#anchor34","text":""},{"name":"The Particle Data Scheme","link":"ParticleDataScheme.html","text":"The Particle Data Scheme The particle data scheme may take somewhat longer to understand than the settings one. In particular the set of methods to access information is rather more varied, to allow better functionality for advanced usage. However, PYTHIA does come with a sensible default set of particle properties and decay tables. Thus there is no need to learn any of the methods on this page to get going. Only when you perceive a specific need does it make sense to learn the basics. The central section on this page is the Operation one. The preceding sections are there mainly to introduce the basic structure and the set of properties that can be accessed. The subsequent sections provide a complete listing of the existing public methods, which most users probably will have little interaction with. Databases The management of particle data is based on three classes: ParticleData , which is the top-level class, with methods that can be used to interrogate all particle data. It contains a map of PDG particle identity numbers Yao06 onto the relevant ParticleDataEntry objects, ParticleDataEntry , which stores the relevant information on an individual particle species, and DecayChannel , which stores info on one particular decay mode of a particle. The objects of these classes together form a database that is continuously being used as the program has to assign particle masses, select decay modes, etc. Each Pythia object has a public member particleData of the ParticleData class. Therefore you access the particle data methods as pythia.particleData.command(argument) , assuming that pythia is an instance of the Pythia class. Further, for some of the most frequent user tasks, Pythia methods have been defined, so that pythia.command(argument) would work, see further below. A fundamental difference between the particle data classes and the settings ones is that the former are accessed regularly during the event generation process, as a new particle is produced and its mass need to be set, e.g., while the latter are mainly/only used at the initialization stage. Nevertheless, it is not a good idea to change data in either of them in mid-run, since this may lead to inconsistencies. Stored properties for particles The main properties stored for each particle are as follows. Different ways to set and get these properties will be described further down. name : a character string with the name of the particle. Particle and antiparticle names are stored separately, with void returned when no antiparticle exists. spinType : the spin type, of the form 2 s + 1 , with special code 0 for entries of unknown or indeterminate spin. chargeType : three times the charge (to make it an integer). colType : the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 octet. (A preliminary implementation of colour  sextets, available since version 8.150, further uses 3 for a sextet  and -3 for an antisextet.) m0 : the nominal mass m_0 (in GeV). mWidth : the width Gamma of the Breit-Wigner distribution (in GeV). mMin : the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there. mMax : the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there. tau0 : the nominal proper lifetime tau_0 (in mm/c). isResonance : a flag telling whether a particle species is considered as a resonance or not. Here 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the b bbar bound systems in mass, i.e. for W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with m0 above 20 GeV are by default initialized to be considered as resonances. mayDecay : a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for particle decays (or resonance decays ). All particles with tau0 below 1000 mm are by default initialized to allow decays. doExternalDecays : a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the Pythia::decayPtr(...) method should be provided with the list of relevant particles. isVisible : a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector. doForceWidth : a flag applicable only for resonances (see isResonance above), whereby it is possible to force resonances to retain their assigned width, whatever that is, see Resonance Decays for details. Stored properties for decays An unstable particle has a decay table consisting of one or more decay channel. The following properties are stored for each such channel. Again different ways to set and get these properties will be described further down. onMode : integer code for use or not of channel, 0 if a channel is off, 1 if on, 2 if on for a particle but off for an antiparticle, 3 if on for an antiparticle but off for a particle. If a particle is its own antiparticle then 2 is on and 3 off but, of course, for such particles it is much simpler and safer to use only 1 and 0. The 2 and 3 options can be used e.g. to encode CP violation in B decays, or to let the W 's in a q qbar &rarr; W^+ W^- process decay in different channels. bRatio : the branching ratio of the channel (with some reservations for resonances, see meMode below). meMode : the mode of processing this channel, possibly with matrix elements; see the particle decays and resonance decays descriptions for the list of possibilities. Notably the default code 0 for a particle means pure phase space decays according to the given branching ratios, while for a resonance it means that code exists for the dynamic calculations of partial widths and thereby branching ratios as a function of the resonance mass (which is done e.g. at initialization based on the mass set by the user). Then codes 1 - 99 are reserved for various matrix-element-improved ordinary particle decays, and 100 - 103 for resonances where the partial width of a given channel is calculated from the total width and the stored branching ratio. Thus, to enforce a new branching ratio for a resonance channel (with its own partial-width calculation code) it is not sufficient only to change the bRatio but also to set e.g. meMode = 100. multiplicity : the number of decay products of the channel. Can be at most 8. product(i) : the identity code of the decay products, where i runs between 0 and multiplicity - 1. Trailing positions are filled with 0. Operation The normal flow of the particle data operations is: When a Pythia object pythia is created, the pythia.particleData member is asked to scan the ParticleData.xml file. All lines beginning with <particle are scanned for information on a particle species, and all lines beginning with <channel are assumed to contain a decay channel of the enclosing particle. In both cases XML syntax is used, with attributes used to identify the stored properties, and with omitted properties defaulting back to 0 where meaningful. The particle and channel information may be split over several lines, up to the > endtoken. The format of a <particle tag is: <particle id='...' name='...' antiName='...' spinType='...' chargeType='...' colType='...'      m0='...' mWidth='...' mMin='...' mMax='...' tau0='...'>    </particle> where the fields are the properties already introduced above. Note that isResonance , mayDecay , doExternalDecay , isVisible and doForceWidth are not set here, but are provided with default values by the rules described above. Once initialized, also these latter properties can be changed, see below. The format of  a <channel> tag is: <channel onMode='...' bRatio='...' meMode='...' products='...' /> again see properties above. The products are given as a blank-separated list of id codes. Important : the values in the .xml file should not be changed, except by the PYTHIA authors. Any changes should be done with the help of the methods described below. Between the creation of the Pythia object and the init call for it, you may use the methods of the ParticleData class to modify some of the default values. Several different approaches can be chosen for this. a) Inside your main program you can directly set values with pythia.readString(string); where both the variable name and the value are contained inside the character string, separated by blanks and/or a =, e.g. pythia.readString('111:mayDecay = off'); switches off the decays of the pi^0. The particle id (> 0) and the property to be changed must be given, separated by a colon. The allowed properties are: name , antiName , spinType , chargeType , colType , m0 , mWidth , mMin , mMax , tau0 , isResonance , mayDecay , doExternalDecay , isVisible and doForceWidth. All of these names are case-insensitive. Names that do not match an existing variable are ignored. Strings beginning with a non-alphanumeric character, like # or !, are assumed to be comments and are not processed at all. For bool values, the following notation may be used interchangeably: true = on = yes = ok = 1 , while everything else gives false (including but not limited to false , off , no and 0 ). Particle data often comes in sets of closely related information. Therefore some properties expect the value to consist of several numbers. These can then be separated by blanks (or by commas). A simple example is names , which expects both the name and antiname to be given. A more interesting one is the all property, id:all = name antiName spinType chargeType colType m0 mWidth mMin mMax tau0 where all the current information on the particle itself is replaced, but any decay channels are kept unchanged. Using new instead of all also removes any previous decay channels. If the string contains fewer fields than expected the trailing properties are set to vanish ('void', 0 or 0.). Note that such a truncated string should not be followed by a comment, since this comment would then be read in as if it contained the missing properties. The truncation can be done anywhere, specifically a string with only id:new defines a new 'empty' particle. As before, isResonance , mayDecay , doExternalDecay , isVisible and doForceWidth are (re)set to their default values, and would have to be changed separately if required. A further command is rescaleBR , which rescales each of the existing branching ratios with a common factor, such that their new sum is the provided value. This may be a first step towards adding new decay channels, see further below. Alternatively the id code may be followed by another integer, which then gives the decay channel number. This then has to be followed by the property specific to this channel, either onMode , bRatio , meMode or products. In the latter case all the products of the channel should be given: id:channel:products =  product1 product2 .... The line will be scanned until the end of the line, or until a non-number word is encountered, or until the maximum allowed number of eight products is encountered, whichever happens first. (Thus the multiplicity of a decay channel need not be input; it is automatically calculated from the products list.) It is also possible to replace all the properties of a channel in a similar way: id:channel:all = onMode bRatio meMode product1 product2 .... To add a new channel at the end, use id:addChannel = onMode bRatio meMode product1 product2 .... It is currently not possible to remove a channel selectively, but setting its branching ratio vanishing is as effective. If you want to remove all existing channels and force decays into one new channel you can use id:oneChannel = onMode bRatio meMode product1 product2 .... A first oneChannel command could be followed by several subsequent addChannel ones, to build up a completely new decay table for an existing particle. When adding new channels or changing branching ratios in general, note that, once a particle is to be decayed, the sum of branching ratios is always rescaled to unity. Beforehand, rescaleBR may be used to rescale an existing branching ratio by the given factor. There are a few commands that will study all the decay channels of the given particle, to switch them on or off as desired. The id:onMode = onMode will set the onMode property of all channels to the desired value. The id:offIfAny  = product1 product2 ....    id:onIfAny   = product1 product2 ....    id:onPosIfAny = product1 product2 ....    id:onNegIfAny = product1 product2 .... will set the onMode 0, 1, 2 or 3, respectively, for all channels which contain any of the enumerated products, where the matching to these products is done without distinction of particles and antiparticles. Note that ' Pos ' and ' Neg ' are slightly misleading since it refers to the particle and antiparticle of the id species rather than charge, but should still be simpler to remember and understand than alternative notations. Correspondingly id:offIfAll  = product1 product2 ....    id:onIfAll   = product1 product2 ....    id:onPosIfAll = product1 product2 ....    id:onNegIfAll = product1 product2 .... will set the onMode 0, 1, 2 or 3, respectively, for all channels which contain all of the enumerated products, again without distinction of particles and antiparticles. If the same product appears twice in the list it must also appear twice in the decay channel, and so on. The decay channel is allowed to contain further particles, beyond the product list. By contrast, id:offIfMatch  = product1 product2 ....    id:onIfMatch   = product1 product2 ....    id:onPosIfMatch = product1 product2 ....    id:onPosIfMatch = product1 product2 .... requires the decay-channel multiplicity to agree with that of the product list, but otherwise works as the onIfAll/offIfAll methods. Note that the action of several of the commands depends on the order in which they are executed, as one would logically expect. For instance, id:oneChannel removes all decay channels of id and thus all previous changes in this decay table, while subsequent additions or changes would still take effect. Another example would be that 23:onMode = off followed by 23:onIfAny = 1 2 3 4 5 would let the Z^0 decay to quarks, while no decays would be allowed if the order were to be reversed. b) The Pythia readString(string) method actually does not do changes itself, but sends on the string either to the ParticleData class or to the Settings one, depending on whether the string begins with a digit or a letter. If desired, it is possible to communicate directly with the corresponding ParticleData method: pythia.particleData.readString('111:mayDecay = off');    pythia.particleData.readString('15:2:products = 16 -211'); In this case, changes intended for Settings would not be understood. c) Underlying this are commands for all the individual properties in the ParticleData class, one for each. These are further described below. Thus, an example now reads pythia.particleData.mayDecay(111, false); Boolean values should here be given as true or false. d) A simpler and more useful way is to collect all your changes in a separate file, with one line per change, e.g. 111:mayDecay = off The file can be read by the pythia.readFile(fileName); method, where fileName is a string, e.g. pythia.readFile('main.cmnd') (or an istream instead of a fileName ). Each line is processed as described for the string in 2a). This file can freely mix commands to the Settings and ParticleData classes. A routine reInit(fileName) is provided, and can be used to zero the particle data table and reinitialize it from scratch. Such a call might be useful if several subruns are to be made with widely different particle data - normally the maps are only built from scratch once, namely when the Pythia() object is created. Also, there is no other possibility to restore the default values, unlike for the settings. You may at any time obtain a listing of all the particle data by calling pythia.particleData.listAll(); The listing is by increasing id number. It shows the basic quantities introduced above. Some are abbreviated in the header to fit on the lines: spn = spinType , chg = chargeType , col = colType , res = isResonance , dec = mayDecay && canDecay (the latter checks that decay channels have been defined), ext = doExternalDecay , vis = isVisible and wid = doForceWidth. To list only those particles that were changed (one way or another, the listing will not tell what property or decay channel was changed), instead use pythia.particleData.listChanged(); (This info is based on a further hasChanged flag of a particle or a channel, set true whenever any of the changing methods are used. It is possible to manipulate this value, but this is not recommended.) By default the internal initialization of the widths of resonances such as gamma^*/Z^0, W^+-, t/tbar, H^0 do not count as changes; if you want to list also those changes instead call listChanged(true). To list only one particle, give its id code as argument to the list(...) function.. To list a restricted set of particles, give in their id codes to list(...) as a vector<int>. For wholesale changes of particle properties all available data can be written out, edited, and then read back in again. These methods are mainly intended for expert users. You can choose between two alternative syntaxes. a) XML syntax, using the <particle and <channel lines already described. You use the method particleData.listXML(fileName) to produce such an XML file and particleData.readXML(fileName) to read it back in after editing. b) Fixed/free format, using exactly the same information as illustrated for the <particle and <channel lines above, but now without any tags. This means that all information fields must be provided (if there is no antiparticle then write void ), in the correct order (while the order is irrelevant with XML syntax), and all on one line. Information is written out in properly lined-up columns, but the reading is done using free format, so fields need only be separated by at least one blank. Each new particle is supposed to be separated by (at least) one blank line, whereas no blank lines are allowed between the particle line and the subsequent decay channel lines, if any.  You use the method particleData.listFF(fileName) to produce such a fixed/free file and particleData.readFF(fileName) to read it back in after editing. As an alternative to the readXML and readFF methods you can also use the particleData.reInit(fileName, xmlFormat) method, where xmlFormat = true (default) corresponds to reading an XML file and xmlFormat = false to a fixed/free format one. To check that the new particle and decay tables makes sense, you can use the particleData.checkTable() method, either directly or by switching it on among the standard error checks. The public methods In the following we present briefly the public methods in the three classes used to build up the particle database. The order is top-down, i.e from the full table of all particles to a single particle to a single channel. Note that these methods usually are less elegant and safe than the input methods outlined above. If you use any of these methods, it is likely to be the ones in the full database, i.e. the first ones to be covered in the following. For convenience, we have grouped related input and output methods together. It should be obvious from the context which is which: the input is of type void and has an extra last argument, namely is the input value, while the output method returns a quantity of the expected type. The ParticleData methods The ParticleDataEntry methods Most of the methods that can be applied to a single ParticleDataEntry object are almost identical with those used above for the ParticleData , except that the id argument is no longer needed to find the right entry in the table. By and large, this makes direct access to the ParticleDataEntry methods superfluous. There are a few methods that are unique to each class, however. Furthermore, to avoid some naming ambiguities, many methods that set values begin with set. The DecayChannel methods The properties stored in an individual decay channel can be set or get by the methods in this section."},{"name":"void Hist::book(string title, int numberOfBins,  double xMin, double xMax)","link":"Histograms.html#anchor6","text":"define a histogram that previously was only declared; see above for the meaning of the arguments."},{"name":"double Particle::mSel()","link":"ParticleProperties.html#anchor75","text":"the mass of the particle, picked according to a Breit-Wigner distribution for particles with width. It is different each time called, and is therefore only used once per particle to set its mass m()."},{"name":"friend double costheta(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor39","text":"the (cosine) of the opening angle between the vectors, in the range 0 through pi."},{"name":"void ParticleData::mMax(int id, double mMax)","link":"ParticleDataScheme.html#anchor45","text":""},{"name":"External Decays","link":"ExternalDecays.html","text":"External Decays DecayHandler is a base class for the external handling of decays. It is intended for normal particle decays, primarily B mesons and tau , and cannot be used to redirect decays of heavy resonances like t or Z^0. The user-written derived class is called if a pointer to it has been given with the pythia.decayPtr() method, where it also is specified which particles it will be called for. This particle information is accessible with the doExternalDecay() method. The main pure virtual method in DecayHandler to do the decay is: At input, these vectors each have size one, so that idProd[0] , mProd[0] and pProd[0] contain information on the particle that is to be decayed. At output, the vectors should have increased by the addition of all the decay products. Even if initially defined in the rest frame of the mother, the products should have been boosted so that their four-momenta add up to the pProd[0] of the decaying particle. Should it be of interest to know the prehistory of the decaying particle, e.g. to set some helicity information affecting the decay angular distribution, the full event record is available read-only, with info in which slot iDec the decaying particle is stored. The routine should return true if it managed the decay and false otherwise, in which case Pythia will try to do the decay itself. This e.g. means you can choose to do some decay channels yourself, and leave others to Pythia. To avoid double-counting, the channels you want to handle should be switched off in the Pythia particle database. In the beginning of the external decay method you should then return false with a probability given by the sum of the branching ratios for those channels you do not want to handle yourself. Note that the decay vertex is always set by Pythia , and that B-Bbar oscillations have already been taken into account, if they were switched on. Thus idProd[0] may be the opposite of event[iDec].id() , where the latter provides the code at production. One limitation of the method above is that it is only intended for one decay step, not for a sequential decay chain. (At least not for displaying such intermediate steps.) That is, the control for any subsequent decays returns to PYTHIA. If you want to avoid this another method exists, with one extra argument: Here the new motherProd vector also has size one at input, with motherProd[0] = 0. At output it should have increaed in size in the same way as the other arrays. Particles that come directly from the mother should have value 0, whereas secondary decay products should have the index of the mother in the arrays. To simplify parsing, particles having the same mother should be placed consecutively in the arrays, and daughters can not be put before their mothers. When the particles are transferred to the standard event record, the full mother-daughter relations will be reconstructed from the new array, and any particle with daughters will be considered to have decayed. For long-lived intermediate particles also vertex information will take this into account. User-selected secondary decay channels will be accepted as they are, however, without any knowledge whether the user has allowed for particle-antiparticle oscillations before that decay. Therefore a simple exponential decay time will be used to find secondary vertices. While primarily intended for sequential decays, of course the chainDecay method can be used also for simple decays in one step, and is then equivalent with decay one. This is useful if a particle species has some decay channels that lead to sequential decays whereas others do not. During code execution it is first checked whether chainDecay can do the decay, and if not decay is offered to. By default chainDecay returns false, so if you only overload decay it will be called. If you want to you can choose to handle the decays of some particles in one of the methods and other particles in the other method, so long as you return false for those decays you do not handle. The choice of which method to use can be done by the user in the method A sample test program is available in main17.cc , providing a simple example of how to use this facility. EvtGen The external B and C -hadron decay program EvtGen performs a chain of decays, rather than single particle decays, to propagate helicity information throughout the chain. Consequently, EvtGen cannot be simply interfaced via the DecayHandler class. A special class, EvtGenDecays , is provided in Pythia8Plugins which can be called after an event has been generated, to perform all remaining decays via EvtGen. An example of how to use this class is provided in main48.cc. A more detailed discussion of some physics considerations, notably event weights for forced decays, can be found in this note."},{"name":"Main:subrun","link":"MainProgramSettings.html#anchor25","text":"The number of the current subrun, a non-negative integer, put as first line in a section of lines to be read for this particular subrun."},{"name":"virtual double tmsDefinition( const EventAMPERSAND  event)","link":"MatchingAndMerging.html#anchor21","text":""},{"name":"Diffraction:MBRdyminDDflux","link":"Diffraction.html#anchor10","text":""},{"name":"void Settings::addFlag(string key, bool default)","link":"SettingsScheme.html#anchor25","text":""},{"name":"virtual double MergingHooks::tmsDefinition(const EventAMPERSAND event)","link":"CKKWLMerging.html#anchor17","text":"This method will have to calculate the value of the merging scale defined in  some variable from the input event record. An example of such a function is  given in main82.cc."},{"name":"FourthGeneration:VtbPrime","link":"FourthGenerationProcesses.html#anchor18","text":"The V_tb' matrix element in the 4 * 4 CKM matrix."},{"name":"ExtraDimensionsUnpart:ffbar2gammagamma","link":"ExtraDimensionalProcesses.html#anchor76","text":"Scatterings f fbar &rarr; (U*) &rarr; gamma gamma. If the unparticle contribution is zero in the spin-2 case, the results corresponds to the SM contribution, i.e. equivalent to PromptPhoton:ffbar2gammagamma. Code 5043."},{"name":"int SlowJet::jetAssignment(int i)","link":"EventAnalysis.html#anchor54","text":"gives the index of the jet that the particle i of the event record belongs to, or -1 if there is no jet containing particle i ,"},{"name":"Process Selection","link":"ProcessSelection.html","text":"Process Selection There is no way PYTHIA could contain all processes of interest, neither in terms of potential physics topics nor in terms of high-multiplicity final states. What exists is a reasonably complete setup of all 2 &rarr; 1 and 2 &rarr; 2 processes within the Standard Model, plus some examples of processes beyond that, again for low multiplicities. Combined with the PYTHIA parton showers, this should be enough to get a flying start in the study of many physics scenarios. Other processes could be fed in via the Les Houches Accord or be implemented as a Semi-Internal Process. In the latter case the existing processes would act as obvious templates. By default all processes are switched off. You should switch on those you want to simulate. This may be done at two (occasionally three) levels, either for each individual process or for a group of processes. That is, a process is going to be generated either if its own flag or its group flag is on. There is no built-in construction to switch on a group and then switch off a few of its members. Each process is assigned an integer code. This code is not used in the internal administration of events (so having the same code for two completely different processes would not be a problem), but only intended to allow a simpler user separation of different processes. Also the process name is available, as a string. To ease navigation, the list of processes has been split into several separate pages, by main topic. The classification is hopefully intuitive, but by no means unambiguous. For instance, essentially all processes involve QCD, so the 'QCD processes' are the ones that only involve QCD. (And also that is not completely true, once one includes all that may happen in multiparton interactions.) On these separate pages also appear the settings that are completely local to that particular process class, but not the ones that have a broader usage. QCD Processes QCD processes fall in two main categories: soft and hard. The soft ones contain elastic, diffractive and 'minimum-bias' events, together covering the total cross section. Hard processes are the normal 2 &rarr; 2 ones, including charm and bottom production. Reserved code range: 101 - 199. Electroweak Processes Prompt-photon, gamma^*/Z^0 and W^+- production, plus a few processes with t -channel boson exchange. Reserved code range: 201 - 299. Onia Processes Colour singlet and octet production of charmonium and bottomonium. Reserved code range: 401 - 499 for charmonium and 501 - 599 for bottomonium. Top Processes Top production, singly or doubly. Reserved code range: 601 - 699. Fourth-Generation Processes Production of hypothetical fourth-generation fermions. Reserved code range: 801 - 899. Higgs Processes Higgs production, within or beyond the Standard Model. See section on Left-Right-Symmetry processes for doubly charged Higgs bosons. Reserved code range: 901 - 999 for a Standard Model Higgs and 1001 - 1199 for MSSM Higgs bosons. SUSY Processes Production of supersymmetric particles, currently barely begun. Reserved code range: 1001 - 2999. (Whereof 1001 - 1199 for Higgs bosons; see above.) New-Gauge-Boson Processes Production of new gauge bosons such as Z' and W'. Reserved code range: 3001 - 3099. Left-Right-Symmetry Processes Production of righthanded Z_R and W_R bosons and of doubly charged Higgs bosons. Reserved code range: 3101 - 3199. Leptoquark Processes Production of a simple scalar leptoquark state. Reserved code range: 3201 - 3299. Compositeness Processes Production of excited fermion states and contact-interaction modification to interactions between fermions (excluding technicolor; see below). Reserved code range: 4001 - 4099. Technicolor Processes Production of technicolor particles and modifications of QCD processes by technicolor interactions. Does not exist yet. Reserved code range: 4101 - 4199. Hidden Valley Processes A scenario for the pair production of new particles with couplings under a new gauge group, with invisible gauge bosons. Radiation of these gauge bosons is included in the standard final-state parton shower. Reserved code range: 4901 - 4999. Extra-Dimensional Processes A vast area, here represented by the production of a Randall-Sundrum excited graviton state and a Kaluza-Klein gluon, a Kaluza-Klein tower of gamma/Z^0 excitations in one TeV^- sized extra dimension, several Large Extra Dimension processes, and a few related Unparticle processes. Reserved code range: 5001 - 5099. Dark Matter Processes An area of increasing interest. Currently only represented by a few basic processes. Reserved code range: 6001 - 6099."},{"name":"bool SigmaProcess::useMirrorWeight()","link":"SemiInternalProcesses.html#anchor29","text":"in 2 &rarr; 3 processes the phase space selection used here involves a twofold ambiguity basically corresponding to a flipping of the positions of last two outgoing particles. These are assumed equally likely by default, false , but for processes proceeding entirely through t -channel exchange the Monte Carlo efficiency can be improved by making a preselection based on the relative propagator weights, true."},{"name":"SecondHard:WAndJet","link":"ASecondHardProcess.html#anchor10","text":"Scattering q qbar' &rarr; W^+- g and q g &rarr; W^+- q'."},{"name":"ParticleDecays:limitTau","link":"ParticleDecays.html#anchor3","text":"When on, only particles with tau < tauMax are decayed."},{"name":"LeftRightSymmmetry:ll2HR","link":"LeftRightSymmetryProcesses.html#anchor10","text":"Scatterings l_i l_j &rarr; H_R^--. Code 3141."},{"name":"void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet)","link":"LesHouchesAccord.html#anchor58","text":"which gives the flavours , the x and the Q scale (in GeV) at which the parton densities x*f_i(x, Q) have been evaluated. The last argument is normally true."},{"name":"Event Pythia::event","link":"ProgramFlow.html#anchor37","text":"the complete event record, see here for further details."},{"name":"Init:showAllParticleData","link":"MainProgramSettings.html#anchor7","text":"Print a list of all particle and decay data. Warning: this will be a long list."},{"name":"PhotonCollision:gmgm2tautau","link":"ElectroweakProcesses.html#anchor37","text":"Scattering gamma gamma &rarr; tau+ tau-. Code 266."},{"name":"Charmonium:O(3S1)[1S0(8)]","link":"OniaProcesses.html#anchor12","text":"The colour-octet long-distance matrix elements <O[1S0(8)]> for the 3S1 charmonium states."},{"name":"MultipartonInteractions:enhanceScreening","link":"MultipartonInteractions.html#anchor11","text":"Choice to activate the above screening scenario, i.e. an increasing effective pT0 for consecutive interactions. No activity-dependent screening, i.e. pT0 is fixed. The pT0 scale is increased as a function of the number of MPI's, as explained above. ISR is not affected, but note that, if SpaceShower:samePTasMPI is on, then MultipartonInteractions:pT0Ref is used also for ISR, which may or may not be desirable. Both MPI and ISR influence and are influenced by the screening. That is, the dampening is reduced based on the total number of MPI and ISR steps considered so far, including the current one. This dampening is implemented both for MPI and for ISR emissions, for the latter provided that SpaceShower:samePTasMPI is on (default)."},{"name":"LeftRightSymmmetry:ll2HL","link":"LeftRightSymmetryProcesses.html#anchor4","text":"Scatterings l_i l_j &rarr; H_L^--. Code 3121."},{"name":"Merging:usePythiaQRenHard","link":"CKKWLMerging.html#anchor50","text":"If on, this will allow the algorithm to use a dynamical renormalisation scale to evaluate the strong couplings of the core hard process in dijet and prompt photon events. This means that the value of &alpha; s used as coupling of the hard process in the matrix element generation will be replaced with a running coupling evaluated at the geometric mean of the squared transverse masses of the two outgoing particles, as is the default prescription in Pythia."},{"name":"ParticleAMPERSAND Particle::operator=(const ParticleAMPERSAND pt)","link":"ParticleProperties.html#anchor120","text":"copies the input particle."},{"name":"int DecayChannel::meMode()","link":"ParticleDataScheme.html#anchor176","text":"set or get the mode of processing this channel, possibly with matrix elements (see the particle decays and resonance decays descriptions)."},{"name":"HardQCD:hardbbbar","link":"QCDProcesses.html#anchor21","text":"Sum of the previous two event types. Codes 123 and 124."},{"name":"void Pythia8ToHepMC::set_store_pdf(bool b = true)","link":"HepMCInterface.html#anchor11","text":""},{"name":"SpaceShower:phiPolAsymHard","link":"SpacelikeShowers.html#anchor30","text":"Extend the above azimuthal asymmetry (if on) also back to gluons produced in the hard process itself, where feasible; on/off = true/false."},{"name":"Photon:Q2max","link":"Photoproduction.html#anchor4","text":"Upper limit for (quasi-)real photon virtuality in GeV^2."},{"name":"PhaseSpace:pTHat5Max","link":"PhaseSpaceCuts.html#anchor12","text":"The maximum invariant pT of the lowest- pT parton in QCD 2 &rarr; 3 processes A value below pTHat5Min means there is no upper limit."},{"name":"SigmaProcess:factorScale3VV","link":"CouplingsAndScales.html#anchor14","text":"The Q^2 factorization scale for 2 &rarr; 3 vector-boson-fusion processes, i.e. f_1 f_2 &rarr; H^0 f_3 f_4 with Z^0 or W^+- t -channel propagators. Here we again introduce the combinations mT_Vi^2 = m_V^2 + pT_i^2 as replacements for the normal squared transverse masses of the two outgoing quarks. the squared mass m_V^2 of the exchanged vector boson. the geometric mean of the two propagator virtuality estimates. the geometric mean of the three relevant squared transverse masses. the arithmetic mean of the three relevant squared transverse masses. squared invariant mass of the system, i.e. sHat. fix scale set in SigmaProcess:factorFixScale below."},{"name":"PhotonParton:qgm2qg","link":"ElectroweakProcesses.html#anchor42","text":"Scattering q gamma &rarr; q g. Code 274 (284)."},{"name":"double Info::eCMsub()","link":"EventInformation.html#anchor65","text":"Collision energy of the gamma-gamma sub-system."},{"name":"Zprime:vbPrime","link":"NewGaugeBosonProcesses.html#anchor31","text":"vector coupling of b' quarks."},{"name":"SigmaDiffractive:maxAXB","link":"TotalCrossSections.html#anchor17","text":"The above sigma_max for A + B &rarr; A + X + B in mb."},{"name":"RHadrons:allowDecay","link":"RHadrons.html#anchor6","text":"Allows the R-hadrons to decay or not. If the gluino/stop/sbottom is stable or too long-lived to decay inside the detector this switch has no real function, since then no decays will be performed anyway. If the sparticle is so short-lived that it decays before reaching the beam pipe then having the decay on is the logical choice. So the interesting region is when the decays happens after the R-hadron has passed through part of the detector, and changed its momentum and quite possibly its flavour content before it is to decay. Then normal decays should be switched off, and the R-hadron tracked through matter by a program like GEANT Kra04,Mac07. After that, the new R-hadron info can be overwritten into the event record and the Pythia::forceRHadronDecay() method can be called to force this modified R-hadron to decay."},{"name":"void Vec4::e(double eIn)","link":"FourVectors.html#anchor11","text":"sets the respective component to the input value."},{"name":"int CellJet::nError()","link":"EventAnalysis.html#anchor41","text":"tells the number of times analyze(...) failed to analyze events, i.e. returned false."},{"name":"virtual ~MyMerging()","link":"MatchingAndMerging.html#anchor4","text":"A destructor for your ME+PS class. If not defined, the base class's empty destructor will be used."},{"name":"SLHA:minMassSM","link":"SUSYLesHouchesAccord.html#anchor4","text":"This parameter provides an alternative possibility to ignore SLHA input for all particles with identity codes below 1,000,000 (which mainly means SM particle, but also includes e.g. the Higgs bosons in two-Higgs-doublet scenarios) whose default masses in PYTHIA lie below some threshold value, given by this parameter. The default value of 100.0 allows SLHA input to modify the top quark, but not, e.g., the Z^0 and W^+- bosons."},{"name":"SLHA:file","link":"SUSYLesHouchesAccord.html#anchor2","text":"Name of an SLHA (or LHEF) file containing the SUSY/BSM model definition, spectra, and (optionally) decay tables. Default void signals that no such file has been assigned."},{"name":"Main:numberOfTriedEvents","link":"MainProgramSettings.html#anchor21","text":"The number of events to be tried during generation. Any number smaller than one means that the setting will be ignored."},{"name":"bool ParticleDataEntry::isResonance()","link":"ParticleDataScheme.html#anchor123","text":"a flag telling whether a particle species are considered as a resonance or not. Here 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the b bbar bound systems in mass, i.e. for W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with m0 above 20 GeV are by default initialized to be considered as resonances."},{"name":"Diffraction:sigmaRefPomP","link":"Diffraction.html#anchor25","text":"The assumed Pomeron-proton effective cross section, as used for multiparton interactions in diffractive systems. If this cross section is made to depend on the mass of the diffractive system then the above value refers to the cross section at the reference scale, and sigma_PomP(m) = sigma_PomP(m_ref) * (m / m_ref)^p where m is the mass of the diffractive system, m_ref is the reference mass scale Diffraction:mRefPomP below and p is the mass-dependence power Diffraction:mPowPomP. Note that a larger cross section value gives less MPI activity per event. There is no point in making the cross section too big, however, since then pT0 will be adjusted downwards to ensure that the integrated perturbative cross section stays above this assumed total cross section. (The requirement of at least one perturbative interaction per event.)"},{"name":"SigmaProcess:alphaEMorder","link":"CouplingsAndScales.html#anchor3","text":"The running of alpha_em used in hard processes. first-order running, constrained to agree with StandardModel:alphaEMmZ at the Z^0 mass. zeroth order, i.e. alpha_em is kept fixed at its value at vanishing momentum transfer. zeroth order, i.e. alpha_em is kept fixed, but at StandardModel:alphaEMmZ , i.e. its value at the Z^0 mass."},{"name":"double LHAup::x2pdf()","link":"LesHouchesAccord.html#anchor63","text":""},{"name":"Photon:thetaAMax","link":"Photoproduction.html#anchor7","text":"Upper limit for scattering angle of lepton A in rad. A negative value means that no cut is applied. Since k_T depends on virtuality of the emitted photon, the Photon:Q2max cut is usually more restrictive unless a very small angle is used."},{"name":"Photoproduction","link":"Photoproduction.html","text":"Photoproduction Interactions involving one or two photons, either in photon-photon or photon-hadron collision or photons emitted from lepton beams. Includes both direct and resolved contributions and also soft QCD and MPIs for events with resolved photons. Only (quasi-)real photons are considered so virtuality of the photons is restricted. The PDF set for resolved photons is selected in the PDF selection. This page describes some of the special features related to these collisions and introduces the relevant parameters. Types of photon processes Photons can be either resolved or act as point-like particles (direct). Therefore for a photon-photon interaction there are four different contributions, resolved-resolved, resolved-direct, direct-resolved and direct-direct. In case of photon-hadron collisions there are two contributions. With the default value of the parameter below, a mix of relevant contributions is generated but each process type can also be generated individually. Note that for photon-hadron collisions the code for direct contribution depends on which of the beams is photon. The sample main program main69.cc demonstrates different possibilities. The type of the generated process can be obtained from Info class with method int Info::photonMode() which follows the conventions above. Resolved photon Photons can either interact directly as an unresolved particle or as a hadronic state ('Vector Meson Dominance'). In the latter case the hard process can be simulated using PDFs to describe the partonic structure of the resolved photon. The evolution equations for photons include an additional term that corresponds to gamma &rarr; q qbar splittings. Due to this, the PDFs are somewhat different for photons than for hadrons and some parts of event generation need special attention. Process-level generation Due to the additional term in the evolution equations the quarks in a resolved photon may carry a very large fraction (x~1) of the photon momentum. In these cases it may happen that, after the hard process, there is no energy left to construct the beam remnants. This is true especially if a heavy quark is taken out from the beam and a corresponding massive antiquark needs to be added to the remnant system to conserve flavour. Even though these events are allowed based on the PDFs alone, they are not physical and should be rejected. Therefore some amount of errors can be expected when generating events close to the edge of phase space, e.g. when collision energy is low. Spacelike showers The parton showers are generated according to the DGLAP evolution equations. Due to the gamma &rarr; q qbar splitting in the photon evolution, a few modifications are needed for the ISR algorithm. The additional term corresponds to a possibility to find the original beam photon during the backwards evolution, which is added to the QED part of the spacelike shower evolution. If this splitting happens there is no need to construct the beam remnants for the given beam. The heavy quark production threshold with photon beams is handled in a similar manner as for hadrons, but now the splitting that is forced to happen is gamma &rarr; Q Qbar. As the splittings in backwards evolution increases the x of the parton taken from the beam, the splittings can lead to a situation where there is no room left for massive beam remnants. To make sure that the required  remnants can be constructed, splittings that would not leave room for the beam remnants are not allowed. MPIs with photon beams Multiparton interactions with resolved photon beams are generated as with hadron beams. The only difference follows again from the additional gamma &rarr; q qbar splittings where the beam photon becomes unresolved. If this splitting happens during the interleaved evolution for either of the photon beams no further MPIs below the branching scale pT are allowed since the photon is not resolved anymore. If there have been multiple interactions and a gamma &rarr; q qbar splitting occur, the kinematics of this branching are not constructed in the spacelike shower. Instead the pT scale of the branching is stored and the relevant momenta are then fixed in the beam remnant handling. Therefore the status codes for the partons related to this splitting actually refer to beam remnants. If there are no MPIs before the gamma &rarr; q qbar splitting, this splitting is constructed in the spacelike shower in the usual way, but the mother beam photon is not added to the event record, since a copy of it already exists at the top of the event record. This is unlike the documentation of other ISR splittings, where the mother of the branching is shown, but consistent with the photon not being added (a second time) for events that contain several MPIs. Optionally the photon can be shown, using the following flag. Currently the default values for the parameters related to multiparton interactions are the same as in hadronic collision so no tuning for the MPIs in photon-photon or photon-hadron has been done. This holds also for the parameters related to the impact-parameter dependence. Preliminary studies indicate that a larger value of pT0Ref would be preferred for photon-photon case: The inclusive hadron pT spectra in LEP is well reproduced with pT0Ref = 3.30 GeV. The total cross section for photon-photon collisions is paramerized as in Sch97. Since the total cross section includes contribution also from elastic and diffractive events, a multiplicative factor is introduced to control the non-diffractive component. Beam Remnants To construct the beam remnants, one should know whether the parton taken from the beam is a valence parton or not. The valence partons of a photon includes the partons that originate from gamma &rarr; q qbar splittings of the original beam photon and the valence partons from the hadron-like part of the PDF. In either case, the flavour of the valence quarks can fluctuate. Unfortunately the decomposition to the different components are typically not provided in the PDF sets and some further assumptions are needed to decide the valence content. When ISR is applied for photon beams it is possible to end up to the original beam photon during the evolution. Therefore there are three possibilities for the remnants: Remnants need to be constructed for both beams. Remnants are constructed only for one side. No need for remnants on either side. The last case is the simplest as all the partons in the event are already generated by the parton showers. In the first case the remnants and primordial kT are constructed similarly as for normal hadronic interactions Sjo04. For the second case the momenta of the remnant partons can not be balanced between the two beams as the kinematics of the other side are already fixed. In these cases the momenta are balanced between the scattered system and the remnants. Since the primordial kT increases the invariant mass of the remnants and the scattered system, it may again happen that there is no room for the remnant partons after kT is added, so the kinematics can not be constructed. In this case new values for kT are sampled. If this does not work, a new shower is generated and in some rare cases the parton-level generation fails and the hard process is rejected. The inclusion of additional MPIs increases the invariant mass of the remnants and takes more momentum from the beam particles. Even though the MPIs that would not leave enough room for the remnants are rejected, these can still lead to a situation where the kinematics cannot be constructed due to the added primordial kT. This may cause some amount of errors especially when the invariant mass of gamma-gamma system is small. Photons from lepton beams Interaction of photons from leptons including photon-photon interactions in lepton-lepton collisions and photon-hadron lepton-hadron collisions can be set up as described in PDF selection. Since the current framework can handle only (quasi-)real photons, a upper limit for the photon virtuality needs to be set. This can be done with the parameter Photon:Q2max. The upper limit for virtuality will set also the upper limit for the k_T of the photon, which in turn will be the same as the k_T of the scattered lepton. Also some other cuts can be imposed. MPIs with lepton beams The invariant mass of gamma-gamma or gamma-hadron system from lepton beams will vary. Therefore, to generate MPIs and non-diffractive events in gamma-gamma and gamma-hadron collisions from lepton beams, the MPI framework is initialized with five values of W from Photon:Wmin to Photon:Wmax. The parameter values are then interpolated for the sampled W."},{"name":"HiggsBSM:ffbar2H1Z","link":"HiggsProcesses.html#anchor28","text":"Scattering f fbar &rarr; h^0(H_1^0) Z^0 via s -channel Z^0 exchange. Code 1004."},{"name":"double CoupSM::alphaS(double scale2)","link":"StandardModelParameters.html#anchor18","text":"the alpha_strong value at the quadratic scale scale2."},{"name":"bool Info::isMinBias()","link":"EventInformation.html#anchor23","text":"the same as above, retained for backwards compatibility, but to be removed in PYTHIA 8.2."},{"name":"ExcitedFermion:coupFprime","link":"CompositenessProcesses.html#anchor29","text":"Strength f' of the U(1) coupling."},{"name":"HiddenValley:rFactqv","link":"HiddenValleyProcesses.html#anchor43","text":"r_qv , i.e. the Bowler correction factor to the Lund symmetric fragmentation function, which could be made weaker or stronger than its natural value."},{"name":"void Event::popBack(int n = 1)","link":"EventRecord.html#anchor22","text":"removes the last n particle entries; must be a positive number. History (and other) information of remaning entries is untouched, and so may be internally inconsistent."},{"name":"Merging:doNL3Subt","link":"NLOMerging.html#anchor11","text":"This switch will allow the processing of tree-level events, to produce explicit phase space subtractions in the NL 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Tree and the switch Merging:doNL3Loop have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested. Furthermore, it is necessary to set the value of Merging:nRecluster to one."},{"name":"void RotBstMatrix::invert()","link":"FourVectors.html#anchor85","text":"invert the matrix, which corresponds to an opposite sequence and sign of rotations and boosts."},{"name":"keywords","link":"Variations.html#anchor8","text":""},{"name":"int SigmaProcess::idTchan1()","link":"SemiInternalProcesses.html#anchor25","text":""},{"name":"void Hist::takeSqrt()","link":"Histograms.html#anchor22","text":"take square root of current contents bin by bin, with negative contents set to zero."},{"name":"bool initAfterBeams()","link":"AlpgenEventInterface.html#anchor16","text":"This is the only UserHooks method that is overridden. It is called directly after PYTHIA has initialised the beams, and therefore the header information should be present in the PYTHIA Info object. The AlpgenPar class is used to parse ALPGEN parameters, if present, which are then used to set further PYTHIA settings."},{"name":"void CellJet::list()","link":"EventAnalysis.html#anchor40","text":"provides a listing of the above information (except pMassless , for reasons of space)."},{"name":"string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor118","text":"Return the value of the generator attribute named key for the n'th generator in the vector. Setting doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named key does not exist."},{"name":"void ParticleData::addParticle(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor23","text":"add a particle to the decay table; in the first form a particle which is its own antiparticle, in the second where a separate antiparticle exists."},{"name":"double ParticleData::resWidthOpen(int id, double mHat,  int idInFlav = 0)","link":"ParticleDataScheme.html#anchor83","text":"special case of resWidth , where only open channels are included, but results are not stored in the normal decay table."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; ParticleData::getReadHistory()","link":"ParticleDataScheme.html#anchor19","text":"Method to retrieve the history of readString commands that have been processed by the ParticleData instance, e.g. for inspection. Note that ParticleData commands read by Pythia::readString and Pythia::readFile are interpreted by readString and thus also are listed."},{"name":"Charmonium:gg2ccbar(3S1)[3S1(1)]g","link":"OniaProcesses.html#anchor14","text":"Colour-singlet production of 3S1 charmonium states via g g &rarr; ccbar[3S1(1)] g. Code 401."},{"name":"void RotBstMatrix::fromCMframe(const Vec4AMPERSAND p1, const Vec4AMPERSAND p2)","link":"FourVectors.html#anchor83","text":"rotate and boost from the rest frame of p_1 and p_2 , with p_1 along the +z axis, to the actual frame of p_1 and p_2 , i.e. the inverse of the above."},{"name":"void Particle::rot(double theta, double phi)","link":"ParticleProperties.html#anchor106","text":"rotate three-momentum and production vertex by these polar and azimuthal angles."},{"name":"HiggsH1:coup2Z","link":"HiggsProcesses.html#anchor84","text":"The h^0(H_1^0) coupling to Z^0."},{"name":"TimeShower:MEextended","link":"TimelikeShowers.html#anchor43","text":"Use matrix element corrections also for 1 &rarr; n and 2 &rarr; n processes where no matrix elements are encoded, by an attempt to match on to one of the 1 &rarr; 2 processes that are implemented. This should at least provide relevant mass dampening for massive radiators and recoilers. Only has a meaning if MEcorrections above is switched on."},{"name":"HiggsH1:coup2W","link":"HiggsProcesses.html#anchor85","text":"The h^0(H_1^0) coupling to W^+-."},{"name":"SpaceShower:factorMultFac","link":"SpacelikeShowers.html#anchor11","text":"The default pT^2 factorization scale is multiplied by this prefactor."},{"name":"double TimeShower::pTLastInShower()","link":"ImplementNewShowers.html#anchor9","text":"Can be used to return the pT evolution scale of the last branching in the cascade generated with the above shower(...) method. Is to be set in the internal pTLastInShower variable, and should be 0 if there were no branchings. Can be useful for matching studies."},{"name":"SLHA:readFrom","link":"SUSYLesHouchesAccord.html#anchor1","text":"Controls from where SLHA information is read. is not read at all. Useful when SUSY is not simulated and normal particle properties should not be overwritten. read in from the <slha>...</slha> block of a LHEF, if such a file is read during initialization, and else from the SLHA:file below. read in from the SLHA:file below."},{"name":"HelacOnia Processes","link":"HelacOniaProcesses.html","text":"HelacOnia Processes HelacOnia Sha15 is an external package which provides automated calculations for heavy quarkonia production using NRQCD, similar in style to MadGraph5 and the extension MadOnia, which is only available for MadGraph4. This can be useful when additional quarkonia processes other than the internal processes provided in Onia are needed, including matrix elements which are not spin-averaged, as well as the ability to produce n -leg matrix elements beyond the leading tree-level diagrams. The HelacOnia code can be downloaded from http://helac-phegas.web.cern.ch/helac-phegas/helac-onia.html , where only version 2 and above is compatible with PYTHIA. Within HelacOnia, events can automatically be passed to PYTHIA for additional processing, e.g. showering, MPI, and hadronization. However, in many cases it may be simpler to produce HelacOnia events directly in PYTHIA. The LHAupHelaconia class provided in Pythia8Plugins/LHAHelaconia is designed to provide such utility. Here we will describe how this can be used to wrap the HelacOnia generator as a PYTHIA Les Houches interface. Of course, HelacOnia can also output files of parton-level events according to the LHEF standard, that can be read in and processed further by PYTHIA 8. This is the most commonly used approach, and requires no further description here. HelacOnia executable inside PYTHIA The Pythia::setLHAupPtr(LHAup* lhaUpPtr) method allows a Pythia generator to accept a pointer to an object derived from the LHAup base class. Such an object will be initialized from within Pythia, and be called repeatedly to generate the next parton-level event, using the LHA specification as a standard to transfer the relevant information back to Pythia. Properly constructed, the operation of an LHAup object thus is almost completely hidden from the user, and generates events almost like an ordinary internal Pythia process. The LHAupHelaconia is precisely such a class, derived from LHAup , that contains the code needed to wrap a HelacOnia executable. Thereby the generation of HelacOnia processes from within Pythia becomes straightforward. An explicit example is provided in main35.cc. We describe some of the key elements used there and in the general case."},{"name":"bool SpaceShower::doRestart()","link":"ImplementNewShowers.html#anchor38","text":"This method is not virtual. If branch(...) above fails to construct a branching, and the conditions are such that the whole parton-level description should be restarted, then it should return true, else not. Currently only the rescattering description can give this kind of failures, and so the internal rescatterFail boolean must be set true when this should happen, and else false."},{"name":"double Event::scaleSecond()","link":"EventRecord.html#anchor11","text":"set or get the scale (in GeV) of a second hard process in the event, in those cases where such a one has been requested."},{"name":"SecondHard:GmZAndJet","link":"ASecondHardProcess.html#anchor9","text":"Scattering q qbar &rarr; gamma^*/Z^0 g and q g &rarr; gamma^*/Z^0 q."},{"name":"double SlowJet::m(int i)","link":"EventAnalysis.html#anchor50","text":"gives a Vec4 corresponding to the four-momentum sum of the particles assigned to the i 'th jet, and the invariant mass of this four-vector,"},{"name":"SigmaDiffractive:lowMEnhance","link":"TotalCrossSections.html#anchor11","text":"Normalization factor for the contribution of low-mass resonances to the diffractive cross section ( cRes in eq. (22) of Sch94 )."},{"name":"DecayChannel::DecayChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0, int prod7 = 0)","link":"ParticleDataScheme.html#anchor168","text":"the constructor for a decay channel. Internal."},{"name":"HiggsH1:coup2u","link":"HiggsProcesses.html#anchor82","text":"The h^0(H_1^0) coupling to up-type quarks."},{"name":"LesHouches:setLifetime","link":"LesHouchesAccord.html#anchor70","text":"handling of the decay time information stored in VTIMUP when the Les Houches event record is stored into the PYTHIA process one. The reason is that some matrix-element generators (like POWHEG) do not set decay times, so that it is up to PYTHIA to make that selection. This is particularly important for the tau lepton. all decay times are taken from the Les Houches input. the decay time of tau leptons is generated like for internal PYTHIA tau s, whereas all other decay times are taken from the Les Houches input. all decay times are generated by PYTHIA, thus completely disregarding the Les Houches values. This option could go wrong in BSM scenarios with long-lived particles, if PYTHIA has not been provided with the information to select those lifetimes correctly."},{"name":"HiggsH1:coup2l","link":"HiggsProcesses.html#anchor83","text":"The h^0(H_1^0) coupling to (charged) leptons."},{"name":"PhaseSpace:bias2SelectionRef","link":"PhaseSpaceCuts.html#anchor24","text":"The reference scale pTRef introduced above, such that events with this pTHat obtain unit weight in the reweighting procedure. The value of this parameter has no impact on the final result of the reweighting procedure, but is only there for convenience, i.e. to give 'reasonably-sized' weights."},{"name":"bool LHAup::useExternal()","link":"LesHouchesAccord.html#anchor79","text":"always returns false in the base class, but in LHAupLHEF it returns false if the LHAupLHEF instance is constructed to work on an input LHE file, while it returns true if the LHAupLHEF instance is constructed to use externally provided input streams instead. For the latter, the LHAupLHEF instance should have been constructed with the class constructor LHAupLHEF(Info* infoPtrIn, istream* isIn, istream* isHeadIn, bool readHeadersIn, bool setScalesFromLHEFIn)."},{"name":"HiddenValley:ffbar2TAUvTAUvbar","link":"HiddenValleyProcesses.html#anchor30","text":"Pair production f fbar &rarr; TAUv TAUvbar via intermediate gamma*/Z^*. Code 4935."},{"name":"Vec4::Vec4(const Vec4AMPERSAND v)","link":"FourVectors.html#anchor2","text":"creates a four-vector copy of the input four-vector."},{"name":"HiggsH1:coup2d","link":"HiggsProcesses.html#anchor81","text":"The h^0(H_1^0) coupling to down-type quarks."},{"name":"PhaseSpace:showSearch","link":"PhaseSpaceCuts.html#anchor19","text":"Possibility to print information on the search for phase-space coefficients that (in a multichannel approach) provides an analytical upper envelope of the differential cross section, and the corresponding upper estimate of the cross section. Of interest for crosschecks by expert users only."},{"name":"virtual TimeShower::~TimeShower()","link":"ImplementNewShowers.html#anchor2","text":"The destructor does not need to do anything."},{"name":"mapAMPERSANDlt;string, MVecAMPERSANDgt; Settings::getMVecMap(string match)","link":"SettingsScheme.html#anchor54","text":""},{"name":"Event UserHooks::workEvent","link":"UserHooks.html#anchor6","text":"This protected class member contains the outcome of the above omitResonanceDecays(...) and subEvent(...) methods. Alternatively you can use it for whatever temporary purposes you wish. You are free to use standard operations, e.g. to boost the event to its rest frame before analysis, or remove particles that should not be analyzed. The workEvent can also be sent on to a jet clustering algorithm."},{"name":"friend Hist operator/(double f, const HistAMPERSANDamp; h1)","link":"Histograms.html#anchor40","text":""},{"name":"void Vec4::px(double pxIn)","link":"FourVectors.html#anchor8","text":""},{"name":"BeamRemnants:primordialKTremnant","link":"BeamRemnants.html#anchor7","text":"The width sigma_remn , assigned as a primordial kT to beam-remnant partons."},{"name":"bool SigmaProcess::setupForME()","link":"SemiInternalProcesses.html#anchor8","text":"to be called by the user from inside sigmaHat() (or possibly sigmaKin() ) to setup alternative kinematics in the mME[5] and pME[5] arrays, better suited for matrix-element calculations. See the end of the previous section for a more detailed description. Should the method return false then the conversion did not work, and sigmaHat() (or sigmaKin() ) should be set to vanish."},{"name":"virtual bool MyHardProcess::matchesAnyOutgoing(int iPos, const  EventAMPERSAND event)","link":"MatchingAndMerging.html#anchor29","text":"This function may be used to check if the particle with position iPos in the input event should be considered an outgoing particle of the core scattering."},{"name":"Bottomonium:qqbar2bbbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor60","text":"Colour-octet production of 3S1 bottomonium states via q qbar &rarr; bbbar[3SJ(8)] g. Code 510."},{"name":"BeamRemnants:valencePowerDinP","link":"BeamRemnants.html#anchor15","text":"The abovementioned power for valence d quarks in protons."},{"name":"Charmonium:qqbar2ccbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor29","text":"Colour-singlet production of 3PJ charmonium states via q qbar &rarr; ccbar[3PJ(1)] g. Code 413."},{"name":"HiggsA3:phiParity","link":"HiggsProcesses.html#anchor119","text":"The phi value of CP-mixing in the HiggsA3:parity = 4 option."},{"name":"int ParticleDataEntry::spinType()","link":"ParticleDataScheme.html#anchor104","text":"set or get the particle spin type, i.e. 2 s + 1 , or 0 in some special cases."},{"name":"SUSY:qqbar2chi+chi-","link":"SUSYProcesses.html#anchor17","text":"Pair production of charginos by quark-antiquark annihilation. With two chargino species and maintaining mutually charge conjugate processes separate, this gives four separate processes, codes 1241 - 1244. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated."},{"name":"double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0)","link":"ParticleDataScheme.html#anchor87","text":"special case to calculate one final-state width; currently only used for Higgs decay to q qbar , g g or gamma gamma."},{"name":"Particle::Particle(int id, int status, int mother1, int mother2,  int daughter1, int daughter2, int col, int acol, Vec4 p, double m = 0.,  double scale = 0., double pol = 9.)","link":"ParticleProperties.html#anchor118","text":"constructs a particle with the input properties provided, and non-provided ones set 0 (9 for pol )."},{"name":"JetMatching:etaJetMax","link":"JetMatching.html#anchor12","text":"For both jet algorithms, this defines the maximum pseudorapidity that the detector is assumed to cover. In this context, however, it is tied to the phase space region in which partons have been generated. For the Alpgen-style matching, particles within etaJetMax + coneRadius are passed to the jet algorithm, with only jets within etaJetMax retained in the merging. For the Madgraph-style matching, only particles within etaJetMax are used."},{"name":"bool Particle::isLepton()","link":"ParticleProperties.html#anchor83","text":"true for a lepton or an antilepton (including neutrinos)."},{"name":"double Info::x2()","link":"EventInformation.html#anchor33","text":"x fractions of the two partons coming in to the hard process."},{"name":"ColourReconnection:dLambdaCut","link":"ColourReconnection.html#anchor17","text":"Restrict gluon moves and colour flips to those that reduce lambda by more than this amount. The larger this number, the fewer moves and flips will be performed, but those that remain are the ones most likely to produce large effects."},{"name":"PDF:PomSet","link":"PDFSelection.html#anchor9","text":"Parton densities that can be used for Pomeron beams. Q^2 -independent parametrizations xf(x) = N_ab x^a (1 - x)^b , where N_ab ensures unit momentum sum. The a and b parameters can be set separately for the gluon and the quark distributions. The momentum fraction of gluons and quarks can be freely mixed, and production of s quarks can be suppressed relative to that of d and u ones, with antiquarks as likely as quarks. See further below how to set the six parameters of this approach. pi0 distributions, as specified in the section above. the H1 2006 Fit A NLO Q^2 -dependent parametrization, based on a tune to their data H1P06 , rescaled by the factor PomRescale below. the H1 2006 Fit B NLO Q^2 -dependent parametrization, based on a tune to their data H1P06 , rescaled by the factor PomRescale below. the H1 2007 Jets NLO Q^2 -dependent parametrization, based on a tune to their data H1P07 , rescaled by the factor PomRescale below. the H1 2006 Fit B LO Q^2 -dependent parametrization, based on a tune to their data H1P06 , rescaled by the factor PomRescale below. the ACTW B NLO Q^2 -dependent parametrization with epsilon=0.14 , based on a tune to H1 and ZEUS data Alv99 , rescaled by the factor PomRescale below. the ACTW D NLO Q^2 -dependent parametrization with epsilon=0.14 , based on a tune to H1 and ZEUS data Alv99 , rescaled by the factor PomRescale below. the ACTW SG NLO Q^2 -dependent parametrization with epsilon=0.14 , based on a tune to H1 and ZEUS data Alv99 , rescaled by the factor PomRescale below. the ACTW D NLO Q^2 -dependent parametrization with epsilon=0.19 , based on a tune to H1 and ZEUS data Alv99 , rescaled by the factor PomRescale below. Use an external LHAPDF5 set, cf. the corresponding proton option. Use an external LHAPDF6 set, cf. the corresponding proton option. Use the internal implementation for a LHAPDF6 set, cf. the corresponding proton option."},{"name":"PartonSystems Pythia::partonSystems","link":"ProgramFlow.html#anchor44","text":"a grouping of the partons in the event record by subsystem, see here for further details."},{"name":"HiddenValley:nFlav","link":"HiddenValleyProcesses.html#anchor39","text":"number of different flavours assumed to exist in the hadronization description, leading to approximately 1/n_Flav of the produced HV-mesons being flavour-diagonal and capable to decay back to Standard Model particles."},{"name":"SlowJetHook::SlowJetHook()","link":"EventAnalysis.html#anchor66","text":""},{"name":"double ParticleData::mSel(int id)","link":"ParticleDataScheme.html#anchor65","text":"returns a mass distributed according to a truncated Breit-Wigner, with parameters as described here. Is equal to m0(id) for particles without width."},{"name":"HiggsBSM:gmgm2H1","link":"HiggsProcesses.html#anchor27","text":"Scattering gamma gamma &rarr; h^0(H_1^0) via loop contributions primarily from top and W. Code 1003."},{"name":"HiggsBSM:gmgm2H2","link":"HiggsProcesses.html#anchor37","text":"Scattering gamma gamma &rarr; H^0(H_2^0) via loop contributions primarily from top and W. Code 1023."},{"name":"virtual MergingHooks::~MergingHooks()","link":"CKKWLMerging.html#anchor16","text":"The constructor and destructor do not need to do anything."},{"name":"ExtraDimensionsLED:LambdaT","link":"ExtraDimensionalProcesses.html#anchor62","text":"Ultraviolet cutoff parameter for the virtual graviton exchange processes."},{"name":"double ClusterJet::distance(int i)","link":"EventAnalysis.html#anchor26","text":"clustering scales, with distance(0) being the most recent one, i.e. normally the highest, up to distance(4) being the fifth most recent. That is, with n being the final number of jets, ClusterJet::size() , the scales at which n+1 jets become n , n+2 become n+1 , and so on till n+5 become n+4. Nonexisting clustering scales are returned as zero. The physical interpretation of a scale is as provided by the respective distance measure (Lund, JADE, Durham)."},{"name":"virtual bool SpaceShower::allowedSplitting( const EventAMPERSAND event,  int iRad, int iEmt)","link":"ImplementNewShowers.html#anchor46","text":"This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the spacelike shower if a particular combination of radiator and emission could have resulted from a splitting. The function arguments are the event which contains the radiator and emission, and the position of the radiator ( iRad ) and emission ( iEmt ) in said event. The function should return true if the combination was possible, and false otherwise."},{"name":"Next:numberShowLHA","link":"MainProgramSettings.html#anchor10","text":"The number of events to list the Les Houches input information for, where relevant."},{"name":"HardQCD:qqbar2gg","link":"QCDProcesses.html#anchor13","text":"Scatterings q qbar &rarr; g g. Code 115."},{"name":"RHadrons:maxWidth","link":"RHadrons.html#anchor2","text":"The maximum width of the gluino for which it is possible to form R-hadrons, provided that RHadrons:allow is on."},{"name":"HiggsSM:ff2Hff(t:ZZ)","link":"HiggsProcesses.html#anchor12","text":"Scattering f f' &rarr; H^0 f f' via Z^0 Z^0 fusion. Code 906."},{"name":"virtual bool DecayHandler::chainDecay(  vectorAMPERSANDlt;intAMPERSANDgt;AMPERSANDamp; idProd, vectorAMPERSANDlt;intAMPERSANDgt;AMPERSANDamp; motherProd,  vectorAMPERSANDlt;doubleAMPERSANDgt;AMPERSANDamp; mProd, vectorAMPERSANDlt;Vec4AMPERSANDgt;AMPERSANDamp; pProd,  int iDec, const EventAMPERSANDamp; event)","link":"ExternalDecays.html#anchor2","text":"where is a list of the indices of the mother, and the other arguments are as above."},{"name":"StringFlav:BtoMratio","link":"FlavourSelection.html#anchor41","text":"Ratio of the relative rate of baryon to meson production, i.e. every baryon Clebsch-Gordan coefficient gets multiplied by this factor."},{"name":"SuppressSmallPT : public UserHooks","link":"UserHooks.html#anchor31","text":"suppress small- pT production for 2 &rarr; 2 processes only, while leaving other processes unaffected. The basic suppression factor is pT^4 / ((k*pT0)^2 + pT^2)^2 , where pT refers to the current hard subprocess and pT0 is the same energy-dependent dampening scale as used for multiparton interactions. This class contains canModifySigma() and multiplySigmaBy() methods that overload the base class ones."},{"name":"double Event::scale()","link":"EventRecord.html#anchor9","text":"set or get the scale (in GeV) of the hardest process in the event. Matches the function of the scale variable in the Les Houches Accord."},{"name":"DM:ffbar2Zp2XX","link":"DarkMatterProcesses.html#anchor1","text":"Scattering f fbar &rarr;Z'^0 &rarr; X Xbar. Code 6001."},{"name":"StandardModel:Vcb","link":"StandardModelParameters.html#anchor12","text":"The V_cb CKM matrix element."},{"name":"BeamRemnants:gluonPower","link":"BeamRemnants.html#anchor17","text":"The abovementioned power for gluons."},{"name":"bool Pythia::readString(string line, bool warn = true)","link":"ProgramFlow.html#anchor7","text":"reads in a single string, that is interpreted as an instruction to modify the value of a setting or particle data , as already described above. the string to be interpreted as an instruction. write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. Note: the method returns false if it fails to make sense out of the string."},{"name":"StandardModel:Vcd","link":"StandardModelParameters.html#anchor10","text":"The V_cd CKM matrix element."},{"name":"virtual SpaceShower::~SpaceShower()","link":"ImplementNewShowers.html#anchor28","text":"Also the destructor does not need to do anything."},{"name":"SUSY:qg2chi0squark","link":"SUSYProcesses.html#anchor18","text":"Pair production of neutralinos from quark-gluon initial states. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated."},{"name":"StringZ:epsilonH","link":"Fragmentation.html#anchor22","text":"epsilon_h , i.e. the above parameter for hypothetical heavier quarks, normalized to the case where m_h = m_b. The actually used parameter is then epsilon = epsilon_h * (m_b^2 / m_h^2). This allows a sensible scaling to a particle with an unknown higher mass without the need for a user intervention."},{"name":"virtual void MyHardProcess::storeCandidates( const EventAMPERSAND event,  string process)","link":"MatchingAndMerging.html#anchor27","text":"This function studies the input event and book-keeps the particles that may be considered as part of the core scattering process. For this, it may use the four next functions."},{"name":"POWHEG:emitted","link":"POWHEGMerging.html#anchor6","text":"Selection of emitted parton for FSR. The PYTHIA definition of emitted. The PYTHIA definition of radiator. A random selection of emitted or radiator. Both emitted and radiator are tried."},{"name":"StringZ:epsilonC","link":"Fragmentation.html#anchor20","text":"epsilon_c , i.e. the above parameter for c quarks."},{"name":"StringZ:epsilonB","link":"Fragmentation.html#anchor21","text":"epsilon_b , i.e. the above parameter for b quarks."},{"name":"ExtraDimensionsG*:Gqq","link":"ExtraDimensionalProcesses.html#anchor12","text":"Coupling between graviton and light quarks."},{"name":"Multiparton Interactions","link":"MultipartonInteractions.html","text":"Multiparton Interactions The starting point for the multiparton interactions physics scenario in PYTHIA is provided by Sjo87. Recent developments have included a more careful study of flavour and colour correlations, junction topologies and the relationship to beam remnants Sjo04 , interleaving with initial-state radiation Sjo05 , making use of transverse-momentum-ordered initial- and final-state showers, with the extension to fully interleaved evolution covered in Cor10a. A framework to handle rescattering is described in Cor09. A big unsolved issue is how the colour of all these subsystems is correlated. For sure there is a correlation coming from the colour singlet nature of the incoming beams, but in addition final-state colour rearrangements may change the picture. Indeed such extra effects appear necessary to describe data, e.g. on <pT>(n_ch). A simple implementation of colour rearrangement is found as part of the beam remnants description. Main variables Matching to hard process The maximum pT to be allowed for multiparton interactions is related to the nature of the hard process itself. It involves a delicate balance between not double-counting and not leaving any gaps in the coverage. The best procedure may depend on information only the user has: how the events were generated and mixed (e.g. with Les Houches Accord external input), and how they are intended to be used. Therefore a few options are available, with a sensible default behaviour. Cross-section parameters The rate of interactions is determined by The actual value is then regulated by the running to the scale pT^2 , at which it is evaluated QED interactions are regulated by the alpha_electromagnetic value at the pT^2 scale of an interaction. Note that the choices of alpha_strong and alpha_em made here override the ones implemented in the normal process machinery, but only for the interactions generated by the MultipartonInteractions class. In addition there is the possibility of a global rescaling of cross sections (which could not easily be accommodated by a changed alpha_strong , since alpha_strong runs) The processes used to generate multiparton interactions form a subset of the standard library of hard processes. The input is slightly different from the standard hard-process machinery, however, since incoming flavours, the alpha_strong value and most of the kinematics are already fixed when the process is called. It is possible to regulate the set of processes that are included in the multiparton-interactions framework. Cross-section regularization There are two complementary ways of regularizing the small- pT divergence, a sharp cutoff and a smooth dampening. These can be combined as desired, but it makes sense to coordinate with how the same issue is handled in spacelike showers. Actually, by default, the parameters defined here are used also for the spacelike showers, but this can be overridden. Regularization of the divergence of the QCD cross section for pT &rarr; 0 is obtained by a factor pT^4 / (pT0^2 + pT^2)^2 , and by using an alpha_s(pT0^2 + pT^2). An energy dependence of the pT0 choice is introduced by two further parameters, so that pT0Ref is the pT0 value for the reference CM energy, pT0Ref = pT0(ecmRef). Warning: if a large pT0 is picked for multiparton interactions, such that the integrated interaction cross section is below the nondiffractive inelastic one, this pT0 will automatically be scaled down to cope. The actual pT0 parameter used at a given CM energy scale, ecmNow , is obtained as pT0 = pT0(ecmNow) = pT0Ref * (ecmNow / ecmRef)^ecmPow where pT0Ref , ecmRef and ecmPow are the three parameters below. Alternatively, or in combination, a sharp cut can be used. G&ouml;sta Gustafson has proposed (private communication, unpublished) that the amount of screening, as encapsulated in the pT0 parameter, fluctuates from one event to the next. Specifically, high-activity event are more likely to lead to interactions at large pT scales, but the high activity simultaneously leads to a larger screening of interactions at smaller pT. Such a scenario can approximately be simulated by scaling up the pT0 by a factor sqrt(n) , where n is the number of interactions considered so far, including the current one. That is, for the first interaction the dampening factor is pT^4 / (pT0^2 + pT^2)^2 , for the second pT^4 / (2 pT0^2 + pT^2)^2 , for the third pT^4 / (3 pT0^2 + pT^2)^2 , and so on. Optionally the scheme may also be applied to ISR emissions. For simplicity the same alpha_s(pT0^2 + pT^2) is used throughout. Note that, in this scenario the pT0 scale must be lower than in the normal case to begin with, since it later is increased back up. Also note that the idea with this scenario is to propose an alternative to colour reconnection to understand the rise of <pT>(n_ch) , so that the amount of colour reconnection should be reduced. Impact-parameter dependence The choice of impact-parameter dependence is regulated by several parameters. The ones listed here refer to nondiffractive topologies only, while their equivalents for diffractive events are put in the Diffraction description. Note that there is currently no bProfile = 4 option for diffraction. Other parameters are assumed to agree between diffractive and nondiffractive topologies. Rescattering It is possible that a parton may rescatter, i.e. undergo a further interaction subsequent to the first one. The machinery to model this kind of physics has only recently become fully operational Cor09 , and is therefore not yet so well explored. The rescattering framework has ties with other parts of the program, notably with the beam remnants. Further variables These should normally not be touched. Their only function is for cross-checks. Technical notes Relative to the articles mentioned above, not much has happened. The main news is a technical one, that the phase space of the 2 &rarr; 2 (massless) QCD processes is now sampled in dy_3 dy_4 dpT^2 , where y_3 and y_4 are the rapidities of the two produced partons. One can show that (dx_1 / x_1) * (dx_2 / x_2) * d(tHat) = dy_3 * dy_4 * dpT^2 Furthermore, since cross sections are dominated by the 'Rutherford' one of t -channel gluon exchange, which is enhanced by a factor of 9/4 for each incoming gluon, effective structure functions are defined as F(x, pT2) = (9/4) * xg(x, pT2) + sum_i xq_i(x, pT2) With this technical shift of factors 9/4 from cross sections to parton densities, a common upper estimate of d(sigmaHat)/d(pT2) < pi * alpha_strong^2 / pT^4 is obtained. In fact this estimate can be reduced by a factor of 1/2 for the following reason: for any configuration (y_3, y_4, pT2) also one with (y_4, y_3, pT2) lies in the phase space. Not both of those can enjoy being enhanced by the tHat &rarr; 0 singularity of d(sigmaHat) propto 1/tHat^2. Or if they are, which is possible with identical partons like q q &rarr; q q and g g &rarr; g g , each singularity comes with half the strength. So, when integrating/averaging over the two configurations, the estimated d(sigmaHat)/d(pT2) drops. Actually, it drops even further, since the naive estimate above is based on (4 /9) * (1 + (uHat/sHat)^2) < 8/9 < 1 The 8/9 value would be approached for tHat &rarr; 0 , which implies sHat >> pT2 and thus a heavy parton-distribution penalty, while parton distributions are largest for tHat = uHat = -sHat/2 , where the above expression evaluates to 5/9. A fudge factor is therefore introduced to go the final step, so it can easily be modified when further non-Rutherford processes are added, or should parton distributions change significantly. At initialization, it is assumed that d(sigma)/d(pT2) < d(sigmaHat)/d(pT2) * F(x_T, pT2) * F(x_T, pT2)      * (2 y_max(pT))^2 where the first factor is the upper estimate as above, the second two the parton density sum evaluated at y_3 = y_ 4 = 0 so that x_1 = x_2 = x_T = 2 pT / E_cm , where the product is expected to be maximal, and the final is the phase space for -y_max < y_{3,4} < y_max. The right-hand side expression is scanned logarithmically in y , and a N is determined such that it always is below N/pT^4. To describe the dampening of the cross section at pT &rarr; 0 by colour screening, the actual cross section is multiplied by a regularization factor (pT^2 / (pT^2 + pT0^2))^2 , and the alpha_s is evaluated at a scale pT^2 + pT0^2 , where pT0 is a free parameter of the order of 2 - 4 GeV. Since pT0 can be energy-dependent,  an ansatz pT0(ecm) = pT0Ref * (ecm/ecmRef)^ecmPow is used, where ecm is the current CM frame energy, ecmRef is an arbitrary reference energy where pT0Ref is defined, and ecmPow gives the energy rescaling pace. For technical reasons, also an absolute lower pT scale pTmin , by default 0.2 GeV, is introduced. In principle, it is possible to recover older scenarios with a sharp pT cutoff by setting pT0 = 0 and letting pTmin be a larger number. The above scanning strategy is then slightly modified: instead of an upper estimate N/pT^4 one of the form N/(pT^2 + r * pT0^2)^2 is used. At first glance, r = 1 would seem to be fixed by the form of the regularization procedure, but this does not take into account the nontrivial dependence on alpha_s , parton distributions and phase space. A better Monte Carlo efficiency is obtained for r somewhat below unity, and currently r = 0.25 is hardcoded.  In the generation a trial pT2 is then selected according to d(Prob)/d(pT2) = (1/sigma_ND) * N/(pT^2 + r * pT0^2)^2 * ('Sudakov') For the trial pT2 , a y_3 and a y_4 are then selected, and incoming flavours according to the respective F(x_i, pT2) , and then the cross section is evaluated for this flavour combination. The ratio of trial/upper estimate gives the probability of survival. Actually, to profit from the factor 1/2 mentioned above, the cross section for the combination with y_3 and y_4 interchanged is also tried, which corresponds to exchanging tHat and uHat , and the average formed, while the final kinematics is given by the relative importance of the two. Furthermore, since large y values are disfavoured by dropping PDF's, a factor WT_y = (1 - (y_3/y_max)^2) * (1 - (y_4/y_max)^2) is evaluated, and used as a survival probability before the more time-consuming PDF+ME evaluation, with surviving events given a compensating weight 1/WT_y. An impact-parameter dependence is also allowed. Based on the hard pT scale of the first interaction, and enhancement/depletion factor is picked, which multiplies the rate of subsequent interactions. Parton densities are rescaled and modified to take into account the energy-momentum and flavours kicked out by already-considered interactions."},{"name":"Vec4::Vec4(double x = 0., double y = 0., double z = 0.,  double t = 0.)","link":"FourVectors.html#anchor1","text":"creates a four-vector, by default with all components set to 0."},{"name":"void Settings::listAll()","link":"SettingsScheme.html#anchor10","text":""},{"name":"int SlowJet::sizeJet()","link":"EventAnalysis.html#anchor45","text":"gives the number of jets found, with jets numbered 0 through sizeJet() - 1 , and ordered in terms of decreasing transverse momentum values w.r.t. the beam axis,"},{"name":"Merging:mayRemoveDecayProducts","link":"CKKWLMerging.html#anchor52","text":"Remove products of resonances in the hard process, in case Pythia generates decay products before merging. This makes merging possible even for an indeterminate final state, if Pythia itself has produced the decay products. The merging methods will instead be invoked on the 'non-decayed' event, thus removing the limitation to only one decay channel when performing the merging. This switch is necessary e.g. for slepton pair production in association with additional QCD jets, if the input LHE file contains the resonant sleptons, and Pythia decides on a decay according to the branching fractions read from SLHA input."},{"name":"Charmonium:qg2ccbar(3PJ)[3S1(8)]q","link":"OniaProcesses.html#anchor31","text":"Colour-octet production of 3PJ charmonium states via q g &rarr; ccbar[3S1(8)] q. Code 415."},{"name":"bool ParticleData::init(const ParticleDataAMPERSAND particleDataIn","link":"ParticleDataScheme.html#anchor5","text":"copy particle data from information stored in an existing ParticleData instance."},{"name":"Beams:pxB","link":"BeamParameters.html#anchor10","text":"The p_x component of the second incoming particle, to be set if Beams:frameType = 3."},{"name":"Beams:pxA","link":"BeamParameters.html#anchor7","text":"The p_x component of the first incoming particle, to be set if Beams:frameType = 3."},{"name":"WeakDoubleBoson:ffbar2gmZgmZ","link":"ElectroweakProcesses.html#anchor19","text":"Scattering f fbar' &rarr; gamma^*/Z^0 gamma^*/Z^0. Code 231."},{"name":"HiggsBSM:allH1","link":"HiggsProcesses.html#anchor24","text":"Common switch for the group of h^0(H_1^0) production processes."},{"name":"HiggsBSM:allH2","link":"HiggsProcesses.html#anchor34","text":"Common switch for the group of H^0(H_2^0) production processes."},{"name":"double Particle::eT()","link":"ParticleProperties.html#anchor47","text":""},{"name":"void ParticleDataEntry::setIsResonance(bool isResonance)","link":"ParticleDataScheme.html#anchor122","text":""},{"name":"ExtraDimensionsG*:kappaMG","link":"ExtraDimensionalProcesses.html#anchor10","text":"dimensionless coupling, which enters quadratically in all on-shell partial widths of the G^*. Is kappa m_G* = sqrt(2) x_1 k / Mbar_Pl , where x_1 = 3.83 is the first zero of the J_1 Bessel function and Mbar_Pl is the modified Planck mass. In width and cross section calculations, kappa is fixed by the on-shell G^* mass and kappaMG , i.e. kappaMG scales with the off-shell G^* mass."},{"name":"WeakZ0:gmZmode","link":"ElectroweakProcesses.html#anchor8","text":"Choice of full gamma^*/Z^0 structure or not in relevant processes. full gamma^*/Z^0 structure, with interference included. only pure gamma^* contribution. only pure Z^0 contribution. Note : irrespective of the option used, the particle produced will always be assigned code 23 for Z^0 , and open decay channels is purely dictated by what is set for the Z^0."},{"name":"JetMatching:eTjetMin","link":"JetMatching.html#anchor10","text":"For the CellJet algorithm, this gives the minimum transverse energy inside a cone for a jet to be accepted. For the SlowJet algorithm, this is instead the minimum transverse momentum required for a cluster to be accepted as a jet. For Madgraph-style matching, this parameter should match the qCut parameter described later."},{"name":"Diffraction:MBRdyminSigCD","link":"Diffraction.html#anchor17","text":"the parameter sigma_S , used for the cross section suppression at low dy (non-diffractive region)."},{"name":"int Info::lhaStrategy()","link":"EventInformation.html#anchor75","text":"normally 0, but if Les Houches events are input then it gives the event weighting strategy, see Les Houches Accord."},{"name":"double CoupSM::alphaS1Ord(double scale2)","link":"StandardModelParameters.html#anchor19","text":"a first-order overestimate of the full second-order alpha_strong value at the quadratic scale scale2."},{"name":"RHadrons:diquarkSpin1","link":"RHadrons.html#anchor11","text":"Probability that a diquark extracted from the flavour code of a gluino R-hadron should be assigned spin 1, with the rest being spin 0. Does not apply for two identical quarks, where spin 1 is only possibility. Note that gluino R-hadron codes for simplicity are assigned as if spin is 1 always, and so give no guidance. For stop and sbottom the diquark spin is preserved in the particle code, so there is no corresponding issue."},{"name":"MultipartonInteractions:pTmin","link":"MultipartonInteractions.html#anchor10","text":"Lower cutoff in pT , below which no further interactions are allowed. Normally pT0 above would be used to provide the main regularization of the cross section for pT &rarr; 0 , in which case pTmin is used  mainly for technical reasons. It is possible, however, to set pT0Ref = 0 and use pTmin to provide a step-function regularization, or to combine them in intermediate approaches. Currently pTmin is taken to be energy-independent."},{"name":"void LHAupMadgraph::setSeed(int seed, int runs = 30081)","link":"MadGraph5Processes.html#anchor4","text":"the random seed (sequence), normally not needed to be set explicitly. If the random seed is negative (default of -1), then the MadGraph seed is taken as the Pythia parameter 'Random:seed' , which must be greater than 0. If the maximum number of allowed runs is exceeded (default of 30081) an error is thrown. The seed for a MadGraph run is set as: (random seed - 1) * (maximum runs) + (number of runs) + 1. MadGraph can only handle random seeds up to 30081 * 30081. So, with this strategy, one can generate Pythia jobs with seeds from 1 to 30081, with each job running MadGraph less than 30081 times, and ensure a fully statistically independent sample. If more than 30081 jobs are needed, then the maximum allowed runs can be lowered accordingly, and if need be, setEvents can be used to increase the number of events generated per run."},{"name":"PDF:useHard","link":"PDFSelection.html#anchor4","text":"If on then select a separate PDF set for the hard process, using the variables below. If off then use the same PDF set for everything, as already chosen above."},{"name":"virtual bool MyMergingHooks::doVetoStep( const EventAMPERSAND process,  const EventAMPERSAND event, bool doResonance = false )","link":"MatchingAndMerging.html#anchor11","text":"This function will be used to implement the check of a CKKW-L-style event veto after the first parton shower emission, i.e. to check if the first parton shower emission is above the merging scale. If the input event event after emission should be kept, then false should be returned. If you want instead to veto the event and continue with a completely now hard scattering event, true should be returned."},{"name":"SpaceShower:nQuarkIn","link":"SpacelikeShowers.html#anchor33","text":"Number of allowed quark flavours in g &rarr; q qbar branchings, when kinematically allowed, and thereby also in incoming beams. Changing it to 4 would forbid g &rarr; b bbar , etc."},{"name":"PhaseSpace:increaseMaximum","link":"PhaseSpaceCuts.html#anchor21","text":"Strategy for handling cases where a larger cross section is obtained during the event generation than was assumed at initialization, i.e. when a violation occurs. off: each event comes with a weight, which normally is unity (as a consequence of the acceptance/rejection step), and is found in Info::weight(). For events which exceed the maximum instead the true-to-simple ratio is stored as event weight, which then is above unity. If the user so wishes this weight can then be carried along when event properties are histogrammed. Since normally such violations should be rare and not too much above unity one could expect most users to ignore such issues be default. Should maximum violations turn out to be frequent (visible in the Pythia::stat() output) the option exists to use the information. on: the maximum is increased whenever it is exceeded. Thus events generated after this point will be 'correctly' distributed, while ones generated previously obviously then have had too high a relative weight. If violations occur early on and/or are small this strategy should do a good job of correcting to the desired phase-space distribution. This strategy may be more convenient for the normal user, who would not wish to worry about event weights. It does have the disadvantage that the raised maximum introduces an extra amount of 'history memory' to the generation sequence, so that it becomes less easy to save-and-restore the random-number state for debugging purposes."},{"name":"ParticleDecays:xBsMix","link":"ParticleDecays.html#anchor12","text":"The mixing parameter x_s = Delta(m_B_s^0)/Gamma_B_s^0 in the B_s^0 - B_s^0bar system. (Delta-m from CDF hep-ex-0609040, Gamma from RPP2006.)"},{"name":"Event JetMatchingMadgraph::getWorkEventJet()","link":"JetMatching.html#anchor29","text":"Return the event after parton showering, without resonance decay products and particles that should not be included in the jet matching, as necessary to implement the vetoes in the kT-MLM scheme."},{"name":"StandardModel:sin2thetaW","link":"StandardModelParameters.html#anchor4","text":"The sine-squared of the weak mixing angle, as used in all Z^0 and W^+- masses and couplings, except for the vector couplings of fermions to the Z^0 , see below. Default is the MSbar value from Yao06."},{"name":"HiddenValley:gg2CvCvbar","link":"HiddenValleyProcesses.html#anchor11","text":"Pair production g g &rarr; Cv Cvbar. Code 4904."},{"name":"POWHEG:MPIveto","link":"POWHEGMerging.html#anchor8","text":"MPI vetoing. No MPI vetoing is done. When there is no radiation, MPIs with a scale above pT_1 are vetoed, else MPIs with a scale above sum_i pT_i / 2 = (pT_1 + pT_2 + pT_3) / 2 are vetoed. This option is intended specifically for POWHEG simulations of 2 &rarr; 2 + 2 &rarr; 3 QCD processes."},{"name":"HiggsBSM:qg2H2q(l:t)","link":"HiggsProcesses.html#anchor73","text":"Scattering q g &rarr; H^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1035."},{"name":"ColourReconnection:flipMode","link":"ColourReconnection.html#anchor18","text":"Performing the flip step or not. Also possibility to omit the move step. No flip handling. Allow flips, but not for strings in junction topologies. Allow flips, including for strings in junction topologies. No move handling. Allow flips, but not for strings in junction topologies. No move handling. Allow flips, including for strings in junction topologies."},{"name":"ExcitedFermion:Lambda","link":"CompositenessProcesses.html#anchor27","text":"Compositeness scale Lambda in GeV."},{"name":"ColourReconnection:nColours","link":"ColourReconnection.html#anchor8","text":"The number of reconnection colours, this should not be confused with the standard number of QCD colours. Each string is given an integer number between 0 and nColours - 1. Only strings with the same number are allowed to do a normal string reconnection. The default value provides the standard QCD probability that a triplet and an anti-triplet is in a singlet state. The probability for two strings to form a junction structure is in QCD given by the product of two triplets, which gives a probability of 1/3. Therefore the number of reconnection colours for junction formation is iColours % 3 , where iColours refer to the integer of the string. The behaviour of junction formation therefore only changes slightly with this variable."},{"name":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  Vec4 p, double m = 0., double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor26","text":"appends a particle to the bottom of the event record and returns the index of this position, as above but with four-momentum as a Vec4."},{"name":"double Info::xPomeronA()","link":"EventInformation.html#anchor61","text":""},{"name":"Histograms","link":"Histograms.html","text":"Histograms The Hist class gives a simple implementation of one-dimensional histograms, useful for quick-and-dirty testing, without the need to link to more sophisticated packages. For this reason it is used in many of the sample main programs found in the examples subdirectory. Basic principles We here provide a simple overview of what is involved. As a first step you need to declare a histogram, with name, title, number of bins and x range (from, to). Hist ZpT( 'Z0 pT spectrum', 100, 0., 100.); Alternatively you can first declare it and later define it: Hist ZpT;   ZpT.book( 'Z0 pT spectrum', 100, 0., 100.); Once declared, its contents can be added by repeated calls to fill , ZpT.fill( 22.7, 1.); where the first argument is the x value and the second the weight. Since the weight defaults to 1 the last argument could have been omitted in this case. A set of overloaded operators have been defined, so that histograms can be added, subtracted, divided or multiplied by each other. Then the contents are modified accordingly bin by bin. Thus the relative deviation between two histograms data and theory can be found as diff = (data - theory) / (data + theory); assuming that diff , data and theory have been booked with the same number of bins and x range. That responsibility rests on the user; some checks are made for compatibility, but not enough to catch all possible mistakes. Also overloaded operations with double real numbers are available. Again these four operations are defined bin by bin, i.e. the corresponding amount is added to, subtracted from, multiplied by or divided by each bin. The double number can come before or after the histograms, with obvious results. Thus the inverse of a histogram result is given by 1. / result. The two kind of operations can be combined, e.g. allpT = ZpT + 2. * WpT Finally, also the +=, -+, *=, /= are overloaded, with the right-hand side being either a histogram or a real number. Output format A histogram can be printed by making use of the overloaded << operator, e.g.: cout << ZpT; The printout format is inspired by the old HBOOK one. To understand how to read this format, consider the simplified example 3.50*10^ 2  9      3.00*10^ 2  X  7      2.50*10^ 2  X  1X      2.00*10^ 2  X6 XX      1.50*10^ 2  XX5XX      1.00*10^ 2  XXXXX      0.50*10^ 2  XXXXX        Contents         *10^ 2  31122         *10^ 1  47208         *10^ 0  79373        Low edge  --         *10^ 1  10001         *10^ 0  05050 The key feature is that the Contents and Low edge have to be read vertically. For instance, the first bin has the contents 3 * 10^2 + 4 * 10^1 + 7 * 10^0 = 347. Correspondingly, the other bins have contents 179, 123, 207 and 283. The first bin stretches from -(1 * 10^1 + 0 * 10^0) = -10 to the beginning of the second bin, at -(0 * 10^1 + 5 * 10^0) = -5. The visual representation above the contents give a simple impression of the shape. An X means that the contents are filled up to this level, a digit in the topmost row the fraction to which the last level is filled. So the 9 of the first column indicates this bin is filled 9/10 of the way from 3.00*10^2 = 300 to 3.50*10^2 = 350 , i.e. somewhere close to 345, or more precisely in the range 342.5 to 347.5. The printout also provides some other information, such as the number of entries, i.e. how many times the histogram has been filled, the total weight inside the histogram, the total weight in underflow and overflow, and the mean value and root-mean-square width (disregarding underflow and overflow). The mean and width assumes that all the contents is in the middle of the respective bin. This is especially relevant when you plot a integer quantity, such as a multiplicity. Then it makes sense to book with limits that are half-integers, e.g. Hist multMPI( 'number of multiparton interactions', 20, -0.5, 19.5); so that the bins are centered at 0, 1, 2, ..., respectively.  This also avoids ambiguities which bin gets to be filled if entries are exactly at the border between two bins. Also note that the fill( xValue) method automatically performs a cast to double precision where necessary, i.e. xValue can be an integer. The methods We here collect a more complete and formal overview of the methods."},{"name":"void Vec4::bstback(const Vec4AMPERSAND p)","link":"FourVectors.html#anchor70","text":"boost the four-momentum by beta = (-p_x/E, -p_y/E, -p_z/E)."},{"name":"Merging:enforceStrongOrdering","link":"CKKWLMerging.html#anchor34","text":"If on, preferably pick parton shower histories of the matrix element which  have strongly ordered consecutive splittings, i.e. paths in which consecutive reclustered evolution scales are separated by a user-defined factor."},{"name":"double CoupSM::V2CKMgen(int genU, int genD)","link":"StandardModelParameters.html#anchor41","text":"the CKM mixing element,or the square of it, for up-type generation index genU ( 1 = u, 2 = c, 3 = t, 4 = t' ) and down-type generation index genD ( 1 = d, 2 = s, 3 = b, 4 = b' )."},{"name":"TimeShower:allowMPIdipole","link":"TimelikeShowers.html#anchor19","text":"If on, and if interleaving is off, then dipoles are allowed to be formed between matching final-state colour-anticolour pairs also between two different MPIs. Else dipoles can normally only form inside the same MPI, and the could-have-been dipoles between different MPIs instead appear as dipoles stretched to the beam remnants. In either case a dipole can still form between two MPIs if a final-state colour cannot be matched inside the same MPI. This should normally not happen, except if rescattering is allowed, whereby two or more MPIs get interconnected."},{"name":"double ParticleDataEntry::mWidth()","link":"ParticleDataScheme.html#anchor113","text":"the width Gamma of the Breit-Wigner distribution (in GeV)."},{"name":"double Particle::y()","link":"ParticleProperties.html#anchor54","text":""},{"name":"double CellJet::phiCenter(int i)","link":"EventAnalysis.html#anchor33","text":"gives the eta and phi coordinates of the geometrical center of the i 'th jet,"},{"name":"Zprime:gmZmode","link":"NewGaugeBosonProcesses.html#anchor2","text":"Choice of full gamma^*/Z^0/Z'^0 structure or not in the above process. Note that, with the Z'^0 part switched off, this process is reduced to what already exists among electroweak processes , so those options are here only for crosschecks. full gamma^*/Z^0/Z'^0 structure, with interference included. only pure gamma^* contribution. only pure Z^0 contribution. only pure Z'^0 contribution. only the gamma^*/Z^0 contribution, including interference. only the gamma^*/Z'^0 contribution, including interference. only the Z^0/Z'^0 contribution, including interference. Note : irrespective of the option used, the particle produced will always be assigned code 32 for Z'^0 , and open decay channels is purely dictated by what is set for the Z'^0."},{"name":"SUSY:qq2squarksquark","link":"SUSYProcesses.html#anchor13","text":"Pair production of scalar quarks (squark-squark and its charge conjugate process; for squark-antisquark production see above) by t - and u -channel gluino, neutralino, and chargino exchange. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: PYTHIA 6 only included the gluino exchange contribution, which typically dominates due to the size of the strong coupling; for counterchecks, the flag SUSY:qq2squarksquark:onlyQCD below can be switched on to eliminate the chargino and neutralino contributions.)"},{"name":"Particle::Particle(int id, int status = 0, int mother1 = 0,  int mother2 = 0, int daughter1 = 0, int daughter2 = 0, int col = 0,  int acol = 0, double px = 0., double py = 0., double pz = 0., double e = 0.,  double m = 0., double scale = 0., double pol = 9.)","link":"ParticleProperties.html#anchor117","text":"constructs a particle with the input properties provided, and non-provided ones set 0 (9 for pol )."},{"name":"bool ResonanceWidths::allowCalc()","link":"SemiInternalResonances.html#anchor5","text":"can normally be left dummy (and then always returns true ) but can optionally be used to determine whether to force dynamical width calculation to be switched off (return false ). An example is provided by the SUSYResonanceWidths class, in which the implementation of this method checks for the existence of SLHA decay tables for the particular resonance in question, and checks if those tables should be given precedence over the internal width calculation."},{"name":"virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent)","link":"UserHooks.html#anchor30","text":"when called this method should provide the factor by which you want to see the cross section weight of the current event modified. If you return unity then the normal cross section is obtained. Note that, unlike the methods above, these modifications do not lead to a difference between the number of 'selected' events and the number of 'accepted' ones, since the modifications occur already before the 'selected' level. The integrated cross section of a process is modified, of course. Note that the cross section is only modifiable for normal hard processes. It does not affect the cross section in further multiparton interactions, nor in elastic/diffractive/minimum-bias events. : what makes this routine somewhat tricky to write is that the hard-process event has not yet been constructed, so one is restricted to use the information available in the phase-space and cross-section objects currently being accessed. Which of their  methods are applicable depends on the process, in particular the number of final-state particles. The multiplySigmaBy code in UserHooks.cc contains explicit instructions about which methods provide meaningful information, and so offers a convenient starting point. : this flag is true when the method is called from within the event-generation machinery and false when it is called at the initialization stage of the run, when the cross section is explored to find a maximum for later Monte Carlo usage. Cross-section modifications should be independent of this flag, for consistency, but if multiplySigmaBy(...) is used to collect statistics on the original kinematics distributions before cuts, then it is important to be able to exclude the initialization stage from comparisons."},{"name":"TimeShower::TimeShower()","link":"ImplementNewShowers.html#anchor1","text":"The constructor does not need to do anything."},{"name":"bool Settings::isMode(string key)","link":"SettingsScheme.html#anchor18","text":""},{"name":"FourthBottom:qq2bPrimeq(t:W)","link":"FourthGenerationProcesses.html#anchor4","text":"Scatterings q q' &rarr; b' q'' by t -channel exchange of a W^+- boson. Code 803."},{"name":"void ParticleData::doExternalDecays(int id,  bool doExternalDecays)","link":"ParticleDataScheme.html#anchor55","text":""},{"name":"double Info::pTMPI(int i)","link":"EventInformation.html#anchor91","text":"the process code and transverse momentum of the i 'th subprocess, with i in the range from 0 to nMPI() - 1. The values for subprocess 0 is redundant with information already provided above."},{"name":"Charmonium:qg2ccbar(3DJ)[3PJ(8)]q","link":"OniaProcesses.html#anchor38","text":"Colour-octet production of 3DJ charmonium states via q g &rarr; ccbar[3PJ(8)] q. Code 419."},{"name":"void LHAup::setStrategy( int strategy)","link":"LesHouchesAccord.html#anchor7","text":"sets the event weighting and cross section strategy. The default, provided in the class constructor, is 3, which is the natural value e.g. for an LHEF. chosen strategy (cf. IDWTUP ; see Sjo06 section 9.9.1 for extensive comments). events come with non-negative weight, given in units of pb, with an average that converges towards the cross section of the process. PYTHIA is in charge of the event mixing, i.e. for each new try decides which process should be generated, and then decides whether is should be kept, based on a comparison with xMax. Accepted events therefore have unit weight. as option 1, except that cross sections can now be negative and events after unweighting have weight +-1. You can use Info::weight() to find the weight of the current event. A correct event mixing requires that a process that can take both signs should be split in two, one limited to positive or zero and the other to negative or zero values, with xMax chosen appropriately for the two. events come with non-negative weight, in unspecified units, but such that xMax can be used to unweight the events to unit weight. Again PYTHIA is in charge of the event mixing. The total cross section of a process is stored in xSec. as option 2, except that cross sections can now be negative and events after unweighting have weight +-1. As for option -1 processes with indeterminate sign should be split in two. events come with unit weight, and are thus accepted as is. The total cross section of the process is stored in xSec. as option 3, except that events now come with weight +-1. Unlike options -1 and -2 processes with indeterminate sign need not be split in two, unless you intend to mix with internal PYTHIA processes (see below). events come with non-negative weight, given in units of pb, with an average that converges towards the cross section of the process, like for option 1. No attempt is made to unweight the events, however, but all are generated in full, and retain their original weight. For consistency with normal PYTHIA units, the weight stored in Info::weight() has been converted to mb, however. as option 4, except that events now can come either with positive or negative weights. Note 1 : if several processes have already been mixed and stored in a common event file, either LHEF or some private format, it would be problematical to read back events in a different order. Since it is then not feasible to let PYTHIA pick the next process type, strategies +-1 and +-2 would not work. Instead strategy 3 would be the recommended choice, or -3 if negative-weight events are required. Note 2 : it is possible to switch on internally implemented processes and have PYTHIA mix these with LHA ones according to their relative cross sections for strategies +-1, +-2 and 3. It does not work for strategy -3 unless the positive and negative sectors of the cross sections are in separate subprocesses (as must always be the case for -1 and -2), since otherwise the overall mixture of PYTHIA and LHA processes will be off. Mixing is not possible for strategies +-4, since the weighting procedure is not specified by the standard. (For instance, the intention may be to have events biased towards larger pT values in some particular functional form.)"},{"name":"double Thrust::thrust()","link":"EventAnalysis.html#anchor11","text":""},{"name":"void Info::zNowISR(bool zNowIn)","link":"EventInformation.html#anchor110","text":""},{"name":"friend pairAMPERSANDlt;Vec4,Vec4AMPERSANDgt; getTwoPerpendicular(const Vec4AMPERSAND v1,  const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor47","text":"create a pair of four-vectors that are perpendicular to both input vectors and to each other, and have the squared norm -1."},{"name":"BeamRemnants:valenceDiqEnhance","link":"BeamRemnants.html#anchor16","text":"Enhancement factor for valence diquarks in baryons, relative to the simple sum of the two constituent quarks."},{"name":"UncertaintyBands:deltaAlphaSmax","link":"Variations.html#anchor2","text":"The allowed range of variation of alphaS, interpreted as abs(alphaSprime  - alphaS) < deltaAlphaSmax."},{"name":"BeamRemnants:halfScaleForKT","link":"BeamRemnants.html#anchor4","text":"The scale Q_half in the equation above, defining the half-way point between hard and soft interactions."},{"name":"Bottomonium:O(3PJ)[3P0(1)]","link":"OniaProcesses.html#anchor62","text":"The color-singlet long-distance matrix elements <O[3P0(1)]>/m_Q^2 for the 3PJ bottomonium states. The remaining <O[3PJ(1)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"TimeShower:globalRecoil","link":"TimelikeShowers.html#anchor20","text":"Alternative approach as above, where all final-state particles share the recoil of an emission. If off, then use the standard dipole-recoil approach. If on, use the alternative global recoil, but only for the first interaction, and only while the number of particles in the final state is at most TimeShower:nMaxGlobalRecoil before the branching."},{"name":"ResonanceWidths* ParticleDataEntry::getResonancePtr()","link":"ParticleDataScheme.html#anchor160","text":"set or get a pointer to an object that can be used for dynamic calculation of partial and total resonance widths. Here a resonance is a particle such as top, Z^0 , W^+- , Higgs, and new unstable states beyond the Standard Model."},{"name":"virtual double UserHooks::biasedSelectionWeight()","link":"UserHooks.html#anchor35","text":"Returns the weight you should assign to the event, to use e.g. when you histogram results. It is the exact inverse of the weight you used to modify the phase-space sampling, a weight that must be stored in the selBias member variable, such that this routine can return 1/selBias. The weight is also returned by the Info::weight() method, which may be more convenient to use."},{"name":"void setResonancePtr(int id, ResonanceWidths* resonancePtr)","link":"ParticleDataScheme.html#anchor80","text":"set a pointer for a particle kind to a ResonanceWidths object. This is done, from inside ParticleData::initWidths , only for resonances, i.e. for particles such as Z^0 , W^+- , top, Higgs, and new unstable states beyond the Standard Model. The presence of such an object will allow a more dynamic calculation of partial and total widths, as illustrated by the following methods."},{"name":"HiddenValley:ffbar2TvTvbar","link":"HiddenValleyProcesses.html#anchor25","text":"Pair production f fbar &rarr; Tv Tvbar via intermediate gamma*/Z^*. Code 4926."},{"name":"int Info::nMPI()","link":"EventInformation.html#anchor89","text":"The number of hard interactions in the current event. Is 0 for elastic and diffractive events, and else at least 1, with more possible from multiparton interactions."},{"name":"HistAMPERSANDamp; Hist::operator*=(double f)","link":"Histograms.html#anchor29","text":"multiplies or divides each bin content by the common factor f."},{"name":"  virtual bool doVetoTrialEmission( const EventAMPERSAND, const  EventAMPERSAND )","link":"MatchingAndMerging.html#anchor19","text":""},{"name":"void Settings::forceMode(string key, int now)","link":"SettingsScheme.html#anchor65","text":""},{"name":"TimeShower:fixedFacScale","link":"TimelikeShowers.html#anchor49","text":"The fixed factorization scale, in GeV, that would be used in the evaluation of parton densities if the flag above is on."},{"name":"FragmentationSystems:mJoinJunction","link":"Fragmentation.html#anchor40","text":"When the invariant mass of two of the quarks in a three-quark junction string system becomes too small, the system is simplified to a quark-diquark simple string. The requirement for this simplification is that the diquark mass, minus the two quark masses, falls below mJoinJunction. Gluons on the string between the junction and the respective quark, if any, are counted as part of the quark four-momentum. Those on the two combined legs are clustered with the diquark when it is formed."},{"name":"bool ParticleData::canDecay(int id)","link":"ParticleDataScheme.html#anchor67","text":"true for a particle with at least one decay channel defined."},{"name":"JetMatching:merge","link":"JetMatching.html#anchor2","text":"Master switch to activate parton-jet matching. When off, all external events are accepted (unless they are rejected due to weighting or event processing problems)."},{"name":"void Vec4::rotaxis(double phi, Vec4AMPERSAND n)","link":"FourVectors.html#anchor65","text":"rotate the three-momentum with the azimuthal angle phi around the direction defined by the three-vector part of n."},{"name":"int LHAup::id1pdf()","link":"LesHouchesAccord.html#anchor60","text":""},{"name":"double Particle::tau0()","link":"ParticleProperties.html#anchor77","text":"the nominal lifetime tau_0 > 0 , in mm/c, of the particle species. It is used to assign the actual lifetime tau."},{"name":"ProcessLevel:all","link":"MasterSwitches.html#anchor1","text":"If off, do not attempt to carry out any generation at all on the process level. For the parton level only final-state radiation is possible, using the Pythia::forceTimeShower(...) method. Do allow parton configurations stored in the event record to hadronize and hadrons to decay, however, as set by the HadronLevel switches. Further details are found here."},{"name":"double LHAup::py(int i)","link":"LesHouchesAccord.html#anchor46","text":""},{"name":"void RotBstMatrix::bst(double betaX = 0., double betaY = 0.,  double betaZ = 0.)","link":"FourVectors.html#anchor78","text":"boost by this beta vector."},{"name":"friend double cosphi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor41","text":"the (cosine) of the azimuthal angle between the vectors around the z axis, in the range 0 through pi."},{"name":"Error Checks","link":"ErrorChecks.html","text":"Error Checks There is a few settings related to error checking during program execution. Many other checks are performed as well, but do not have any specific setting related to themselves."},{"name":"void Event::bst(double betaX, double betaY,  double betaZ, double gamma)","link":"EventRecord.html#anchor34","text":""},{"name":"TimeShower:phiPolAsymHard","link":"TimelikeShowers.html#anchor46","text":"Extend the above azimuthal asymmetry (if on) also back to gluons produced in the hard process itself, where feasible; on/off = true/false."},{"name":"Bottomonium:gg2bbbar(3S1)[3S1(1)]g","link":"OniaProcesses.html#anchor51","text":"Colour-singlet production of 3S1 bottomonium states via g g &rarr; bbbar[3S1(1)] g. Code 501."},{"name":"ExcitedFermion:all","link":"CompositenessProcesses.html#anchor1","text":"Common switch for the group of implemented processes that produce an excited fermion."},{"name":"Thrust::Thrust(int select = 2)","link":"EventAnalysis.html#anchor9","text":"create a thrust analysis object, where tells which particles are analyzed, all final-state particles, all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the isVisible() particle method), and only charged final-state particles."},{"name":"Spacelike Showers","link":"SpacelikeShowers.html","text":"Spacelike Showers The PYTHIA algorithm for spacelike initial-state showers is based on the article Sjo05 , where a transverse-momentum-ordered backwards evolution scheme is introduced, with the extension to fully interleaved evolution covered in Cor10a. This algorithm is a further development of the virtuality-ordered one presented in Sj085 , with matching to first-order matrix element for Z^0 , W^+- and Higgs (in the m_t &rarr; infinity limit) production as introduced in Miu99. The normal user is not expected to call SpaceShower directly, but only have it called from Pythia , via PartonLevel. Nonetheless, some of the parameters below, in particular SpaceShower:alphaSvalue , would be of interest for uncertainty estimates and tuning exercises. Note that PYTHIA also incorporates an automated framework for shower uncertainty variations. Main variables The maximum pT to be allowed in the shower evolution is related to the nature of the hard process itself. It involves a delicate balance between not double-counting and not leaving any gaps in the coverage. The best procedure may depend on information only the user has: how the events were generated and mixed (e.g. with Les Houches Accord external input), and how they are intended to be used. Therefore a few options are available, with a sensible default behaviour. The amount of QCD radiation in the shower is determined by The actual value is then regulated by the running to the scale pT^2 , at which it is evaluated The CMW rescaling of Lambda_QCD (see the section on StandardModelParameters ) can be applied to the alpha_strong values used for spacelike showers. Note that tunes using this option need lower values of alpha_strong(m_Z^2) than tunes that do not. QED radiation is regulated by the alpha_electromagnetic value at the pT^2 scale of a branching. The natural scale for couplings and PDFs is pT^2. To explore uncertainties it is possibly to vary around this value, however, in analogy with what can be done for hard processes. (Note that there is also an automated framework for shower uncertainties.) There are two complementary ways of regularizing the small- pT divergence, a sharp cutoff and a smooth dampening. These can be combined as desired but it makes sense to coordinate with how the same issue is handled in multiparton interactions. The actual pT0 parameter used at a given CM energy scale, ecmNow , is obtained as pT0 = pT0(ecmNow) = pT0Ref * (ecmNow / ecmRef)^ecmPow where pT0Ref , ecmRef and ecmPow are the three parameters below. Weak showers The emission of weak gauge bosons is an integrated part of the initial- and final-state radiation, see Weak Showers. The following settings are those specifically related to the initial-state weak radiation, while common settings are found in the Weak Showers description. Further variables These should normally not be touched. Their only function is for cross-checks. There are three flags you can use to switch on or off selected branchings in the shower: There are some further possibilities to modify the shower: Technical notes Almost everything is equivalent to the algorithm in [1]. Minor changes are as follows. It is now possible to have a second-order running alpha_s , in addition to fixed or first-order running. The description of heavy flavour production in the threshold region has been modified, so as to be more forgiving about mismatches between the c/b masses used in Pythia relative to those used in a respective PDF parametrization. The basic idea is that, in the threshold region of a heavy quark Q , Q = c/b , the effect of subsequent Q &rarr; Q g branchings is negligible. If so, then f_Q(x, pT2) = integral_mQ2^pT2  dpT'2/pT'2 * alpha_s(pT'2)/2pi     * integral P(z) g(x', pT'2) delta(x - z x') so use this to select the pT2 of the g &rarr; Q Qbar branching. In the old formalism the same kind of behaviour should be obtained, but by a cancellation of a 1/f_Q that diverges at the threshold and a Sudakov that vanishes. The strategy therefore is that, once pT2 < f * mQ2 , with f a parameter of the order of 2, a pT2 is chosen like dpT2/pT2 between mQ2 and f * mQ2 , a nd a z flat in the allowed range. Thereafter acceptance is based on the product of three factors, representing the running of alpha_strong , the splitting kernel (including the mass term) and the gluon density weight. At failure, a new pT2 is chosen in the same  range, i.e. is not required to be lower since no Sudakov is involved. The QED algorithm now allows for hadron beams with non-zero photon content. The backwards-evolution of a photon in a hadron is identical to that of a gluon, with CF &rarr; eq^2 and CA &rarr; 0. Note that this will only work in conjunction with parton distributions that explicitly include photons as part of the hadron structure, such as the NNPDF2.3 QCD+QED sets. The possibility of a fermion backwards-evolving to a photon has not yet been included, nor has photon backwards-evolution in lepton beams."},{"name":"friend double operator*(const Vec4AMPERSAND v1, const Vec4 v2)","link":"FourVectors.html#anchor58","text":"four-vector product."},{"name":"virtual double UserHooks::enhanceFactor( string name)","link":"UserHooks.html#anchor43","text":"This function should return the enhancement factor for the splitting probability with identifier name. It should return 1. by default, i.e. for all input strings it does not propose to handle. the name of the splitting that can enhanced. Currently, the following input names are recognized by the PYTHIA showers, and can thus be used to enhance the respective splittings. ISR QCD branchings: isr:G2GG for g &rarr; g + g , isr:G2QQ for g &rarr; q + qbar , isr:Q2QG for q &rarr; q + g , isr:Q2GQ for q &rarr; g + q ; ISR QED branchings: isr:Q2QA for q &rarr; q + photon , isr:Q2AQ for q &rarr; photon + q ; ISR weak shower branchings: isr:Q2QW for q &rarr; q + W or q &rarr; q + Z ; FSR QCD branchings: fsr:G2GG for g &rarr; g + g , fsr:G2QQ for g &rarr; q + qbar , fsr:Q2QG for q &rarr; q + g ; FSR QED branchings: fsr:Q2QA for q &rarr; q + photon , fsr:A2QQ for photon &rarr; q + qbar , fsr:A2LL for photon &rarr; lepton + antilepton , FSR weak shower branchings: fsr:Q2QW for q &rarr; q + W or q &rarr; q + Z ; FSR hidden valley branchings: fsr:Q2QHV for all hidden valley branchings. Charge-conjugated branchings are included whenever relevant. Note that the order of the daughters matters: in the backwards evolution machinery the step is from the first daughter to the mother by the emission of the second daughter. Let's consider some examples. The evolution step changing the partonic state from q qbar &rarr; e+ e- to g qbar &rarr; e+ e- qbar through an initial state splitting can be enhanced by allowing a non-unity return value for the splitting with name equalling isr:G2QQ. Another evolution step changing g qbar &rarr; e+ e- qbar to g qbar &rarr; e+ e- qbar gluon through FSR (ISR) can be enhanced by allowing a non-unity return value for the splitting with name equalling fsr:Q2QG ( isr:Q2QG ). Yet another ISR branching converting g qbar &rarr; e+ e- qbar to q qbar &rarr; e+ e- qbar q can be enhanced by non-unity return value for the splitting with name equalling isr:Q2GQ (note the ordering in the branching name)."},{"name":"ExcitedFermion:dg2dStar","link":"CompositenessProcesses.html#anchor2","text":"Scatterings d g &rarr; d^*. Code 4001."},{"name":"Diffraction:MBRdyminSDflux","link":"Diffraction.html#anchor9","text":""},{"name":"HiddenValley:spinqv","link":"HiddenValleyProcesses.html#anchor3","text":"The spin of qv when the Fv (the HV partners of the SM fermions) have spin 1/2. (While, if they have spin 0 or 1, the qv spin is fixed at 1/2.) spin 0. spin 1."},{"name":"virtual bool UserHooks::canVetoMPIEmission()","link":"UserHooks.html#anchor27","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoMPIEmission(...) will interrupt the MPI machinery immediately after each multiparton interaction and allow it to be vetoed."},{"name":"JetMatching:jetAlgorithm","link":"JetMatching.html#anchor4","text":"The choice of jet algorithm to use when merging against hard partons. Currently, only SlowJet with the k T algorithm (and useStandardR = false ) is supported for Madgraph-style matching, while there is full freedom for the ALPGEN-style matching. The CellJet cone algorithm. The SlowJet clustering algorithm."},{"name":"StandardModel:alphaEMmZ","link":"StandardModelParameters.html#anchor3","text":"The alpha_em value at the M_Z mass scale. Default is taken from Yao06."},{"name":"PhaseSpace:bias2Selection","link":"PhaseSpaceCuts.html#anchor22","text":"Possibility to switch on a biased phase space sampling, with compensatingly weighted events, for 2 &rarr; 2 processes. Can only be used under the specific conditions explained in the paragraph above; under other conditions the initialization will abort."},{"name":"ParticleData:mbRun","link":"ParticleData.html#anchor7","text":"the b quark MSbar mass at the mass scale itself."},{"name":"HadronScatter:rMax","link":"HadronScattering.html#anchor25","text":"rMax parameter as above."},{"name":"double ParticleData::tau0(int id)","link":"ParticleDataScheme.html#anchor50","text":"the nominal proper lifetime tau_0 (in mm/c)."},{"name":"ContactInteractions:nQuarkNew","link":"CompositenessProcesses.html#anchor37","text":"Number of allowed outgoing new quark flavours in the above q qbar &rarr; q' qbar' process. Similar to HardQCD:nQuarkNew for the QCD processes."},{"name":"HiggsSM:NLOWidths","link":"HiggsProcesses.html#anchor5","text":"The partial width of the SM Higgs particle are multiplied by the respective factors needed to bring the LO widths encoded in PYTHIA to the NLO ones recommended by the LHCXSWG. The multiplicative factors have been derived for a 125 GeV Higgs, but should apply for a reasonable mass range around that value."},{"name":"Tune:preferLHAPDF","link":"Tunes.html#anchor2","text":"Tunes made by experimental collaborations typically use the LHAPDF package to obtain their PDF values, and so PYTHIA must be built accordingly. See the PDF documentation for more information. For PDFs implemented natively in PYTHIA it is possible to use the respective tunes, without having to use LHAPDF, if you set Tune:preferLHAPDF = 0 before the Tune:pp choice. Use the internal PYTHIA PDFs. Use LHAPDF5 PDFs. Use LHAPDF6 PDFs."},{"name":"Charmonium:O(3S1)[3S1(8)]","link":"OniaProcesses.html#anchor11","text":"The colour-octet long-distance matrix elements <O[3S1(8)]> for the 3S1 charmonium states."},{"name":"void Pythia8ToHepMC::set_print_inconsistency(bool b = true)","link":"HepMCInterface.html#anchor5","text":""},{"name":"friend ostreamAMPERSAND operatorAMPERSANDlt;AMPERSANDlt;(ostreamAMPERSAND,  const RotBstMatrixAMPERSAND M)","link":"FourVectors.html#anchor88","text":"writes out the values of the sixteen components of a RotBstMatrix , on four consecutive lines and ended with a newline."},{"name":"double Particle::tDec()","link":"ParticleProperties.html#anchor59","text":""},{"name":"int LHAup::sizePart()","link":"LesHouchesAccord.html#anchor38","text":"the size of the particle array, which is one larger than the number of particles in the event, since the zeroth entry is kept empty (see above)."},{"name":"  virtual double hardProcessME( const EventAMPERSAND inEvent )","link":"MatchingAndMerging.html#anchor20","text":""},{"name":"StringFlav:mesonUDL1S1J0","link":"FlavourSelection.html#anchor15","text":"the relative scalar production ratio (L=1,S=1,J=0) /pseudoscalar for light ( u , d ) mesons."},{"name":"StringFlav:mesonUDL1S1J1","link":"FlavourSelection.html#anchor16","text":"the relative pseudovector production ratio (L=1,S=1,J=1) /pseudoscalar for light ( u , d ) mesons."},{"name":"StringFlav:mesonUDL1S1J2","link":"FlavourSelection.html#anchor17","text":"the relative tensor production ratio (L=1,S=1,J=2) /pseudoscalar for light ( u , d ) mesons."},{"name":"SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true)","link":"EventAnalysis.html#anchor42","text":"create a SlowJet instance, where tells (half) the power of the transverse-momentum dependence of the distance measure, the anti- kT algorithm, the Cambridge/Aachen algorithm, and the kT algorithm. the R size parameter, which is crudely related to the radius of the jet cone in (y, phi) space around the center of the jet. the minimum transverse momentum required for a cluster to become a jet. By default all clusters become jets, and therefore all analyzed particles are assigned to a jet. For comparisons with perturbative QCD, however, it is only meaningful to consider jets with a significant pT. the maximum +-pseudorapidity that the detector is assumed to cover. If you pick a value above 20 there is assumed to be full coverage (obviously only meaningful for theoretical studies). tells which particles are analyzed, all final-state particles, all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the isVisible() particle method), and only charged final-state particles. masses assumed for the particles used in the analysis all massless, photons are massless while all others are assigned the pi+- mass, and all given their correct masses. gives the possibility to send in your own selection routine for which particles should be part of the analysis; see further below on the SlowJetHook class. If this pointer is sent in nonzero, etaMax and massSet are disregarded, and select only gives the basic selection, to which the user can add further requirements. choice of code used for finding the jets. Does not affect the outcome of the analysis, but only the speed, and some more specialized options. use the fjcore package of FastJet 3.0.5. use the native SlowJet implementation, which gives a slower jet finding, but allows some extra options of step-by-step jet joining. definition of R distance between two jets. This switch is only meaningful for useFJcore = false ; within the fjcore package the standard option below is always used. standard, as described above, DeltaR_ij^2 = (y_i - y_j)^2 + (phi_i - phi_j)^2. alternative, DeltaR_ij^2 = 2 (cosh(y_i - y_j) - cos(phi_i - phi_j)) , which corresponds to the rim of the 'deformed cone' giving a constant invariant mass between the two partons considered (for fixed masses and transverse momenta)."},{"name":"void LHAup::closeFile(istream *AMPERSANDis, ifstream AMPERSANDifs)","link":"LesHouchesAccord.html#anchor83","text":"open and close a file, also gzip files, where an intermediate decompression layer is needed."},{"name":"SLHA:verbose","link":"SUSYLesHouchesAccord.html#anchor8","text":"Controls amount of text output written by the SLHA interface, with a value of 0 corresponding to the most quiet mode. The following variables are used internally by PYTHIA as local copies of SLHA information. User changes will generally have no effect, since these variables will be reset by the SLHA reader during initialization."},{"name":"double Particle::zDec()","link":"ParticleProperties.html#anchor58","text":""},{"name":"void ParticleData::colType(int id, int colType)","link":"ParticleDataScheme.html#anchor37","text":""},{"name":"Diffraction:pickQuarkPower","link":"Diffraction.html#anchor22","text":"The abovementioned mass-dependence power p for the relative quark rate in diffractive systems."},{"name":"bool Settings::isWVec(string key)","link":"SettingsScheme.html#anchor24","text":"return true if an entry of the given name and kind exists, else false."},{"name":"vectorAMPERSANDlt;doubleAMPERSANDgt; Settings::pvecDefault(string key)","link":"SettingsScheme.html#anchor47","text":""},{"name":"void ParticleData::mWidth(int id, double mWidth)","link":"ParticleDataScheme.html#anchor41","text":""},{"name":"TimeShower:phiPolAsym","link":"TimelikeShowers.html#anchor45","text":"Azimuthal asymmetry induced by gluon polarization; on/off = true/false."},{"name":"bool LHAup::closeLHEF(bool updateInit = false)","link":"LesHouchesAccord.html#anchor88","text":"Writes the closing tag and closes the file. Optionally, if updateInit = true , this routine will reopen the file from the beginning, rewrite the same header as openLHEF() did, and then call initLHEF() again to overwrite the old information. This is especially geared towards programs, such as PYTHIA itself, where the cross section information is not available at the beginning of the run, but only is obtained by Monte Carlo integration in parallel with the event generation itself. Then the setXSec( i, xSec) , setXErr( i, xSec) and setXMax( i, xSec) can be used to update the relevant information before closeLHEF is called. Warning: overwriting the beginning of a file without upsetting anything is a delicate operation. It only works when the new lines require exactly as much space as the old ones did. Thus, if you add another process in between, the file will be corrupted."},{"name":"Merging:orderInRapidity","link":"CKKWLMerging.html#anchor36","text":"If on, preferably pick parton shower histories of the matrix element with  consecutive splittings ordered in rapidity and pT."},{"name":"ExtraDimensionsLED:qg2Gq","link":"ExtraDimensionalProcesses.html#anchor44","text":"Scatterings q g &rarr; G q. Code 5022."},{"name":"HistAMPERSANDamp; Hist::operator=(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor5","text":"copies all properties of the histogram in the argument, except that the original histogram title is retained."},{"name":"StringPT:thermalModel","link":"Fragmentation.html#anchor23","text":"If switched off the quark pT is generated according to the traditional Gaussion distribution in p_x and p_y separately. If switched on, the new 'thermal model' Fis16 is instead used, wherein the quark pT is generated such that the resulting hadron receives a pT according to an exponential distribution. Also the hadronic composition is affected, see further below."},{"name":"Main:numberOfAcceptedEvents","link":"MainProgramSettings.html#anchor23","text":"The number of events to be accepted during generation. Any number smaller than one means that the setting will be ignored."},{"name":"int Info::nFSRinRes()","link":"EventInformation.html#anchor78","text":"the number of emissions in the initial-state showering, in the final-state showering excluding resonance decays, and in the final-state showering inside resonance decays, respectively."},{"name":"double CoupSM::af(int idAbs)","link":"StandardModelParameters.html#anchor31","text":"the vector and axial charges of a fermion, by the absolute sign of the PDF code ( a_f = +-1, v_f = a_f - 4. * sin2thetaWbar * e_f )."},{"name":"void LHAup::setXErr( int i, double xErr)","link":"LesHouchesAccord.html#anchor10","text":"update the xErr value of the i 'th process added with addProcess method."},{"name":"void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor12","text":"print a two-column table, where the first column gives the center of each bin and the second one the corresponding bin contents. The table may be useful for plotting e.g. with Gnuplot. The desired output stream or file name can be provided as argument. The former is more flexible (e.g., it allows easy append to an existing file), whereas the latter is simpler for the case that each histogram should be a file of its own. An optional printOverUnder = true argument allows also underflow and overflow contents to be printed. (The arbitrary x coordinates for these are placed as if corresponding to same-size bins just below or above the regular histogram bins.) An optional xMidBin = false argument will have the x value at the beginning of each bin printed, rather than the default midpoint value."},{"name":"ExtraDimensionsLED:ffbar2gammagamma","link":"ExtraDimensionalProcesses.html#anchor48","text":"Scatterings f fbar &rarr; (LED G*) &rarr; gamma gamma. If the graviton contribution is zero, the results corresponds to the SM contribution, i.e. equivalent to PromptPhoton:ffbar2gammagamma. Code 5026."},{"name":"void ParticleDataEntry::hasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor133","text":"keep track of whether the data for a particle has been changed in any respect between initialization and the current status. Is used e.g. by the ParticleData::listChanged method to determine which particles to list."},{"name":"bool ParticleData::doExternalDecay(int id)","link":"ParticleDataScheme.html#anchor56","text":"a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the pythia.decayPtr method should be provided with the list of relevant particles."},{"name":"SecondHard:TwoBJets","link":"ASecondHardProcess.html#anchor13","text":"The q qbar &rarr; b bbar and g g &rarr; b bbar processes. These are already included in the TwoJets sample above, so it would be double-counting to include both, but we assume there may be cases where the b subsample will be of special interest. This subsample does not include flavour-excitation or gluon-splitting contributions to the b rate, however, so, depending on the topology if interest, it may or may not be a good approximation."},{"name":"bool Pythia::flag(string key)","link":"ProgramFlow.html#anchor31","text":"read in a boolean variable from the Settings database. the name of the variable to be read."},{"name":"Couplings and Scales","link":"CouplingsAndScales.html","text":"Couplings and Scales Here is collected some possibilities to modify the scale choices of couplings and parton densities for all internally implemented hard processes. This is based on them all being derived from the SigmaProcess base class. The matrix-element coding is also used by the multiparton-interactions machinery, but there with a separate choice of alpha_strong(M_Z^2) value and running, and separate PDF scale choices. Also, in 2 &rarr; 2 and 2 &rarr; 3 processes where resonances are produced, their couplings and thereby their Breit-Wigner shapes are always evaluated with the resonance mass as scale, irrespective of the choices below. We stress that couplings and scales are set separately from the values on this page for multiparton interactions , timelike showers , and spacelike showers. This allows a bigger flexibility, but also requires a bit more work e.g. if you insist on using the same alpha_s everywhere. Couplings and K factor The size of QCD cross sections is mainly determined by The actual value is then regulated by the running to the Q^2 renormalization scale, at which alpha_strong is evaluated QED interactions are regulated by the alpha_electromagnetic value at the Q^2 renormalization scale of an interaction. In addition there is the possibility of a global rescaling of cross sections (which could not easily be accommodated by a changed alpha_strong , since alpha_strong runs) Renormalization scales The Q^2 renormalization scale can be chosen among a few different alternatives, separately for 2 &rarr; 1 , 2 &rarr; 2 and two different kinds of 2 &rarr; 3 processes. In addition a common multiplicative factor may be imposed. Factorization scales Corresponding options exist for the Q^2 factorization scale used as argument in PDF's. Again there is a choice of form for 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes separately. For simplicity we have let the numbering of options agree, for each event class separately, between normalization and factorization scales, and the description has therefore been slightly shortened. The default values are not necessarily the same, however."},{"name":"ParticleDecays:rMax","link":"ParticleDecays.html#anchor6","text":"The above rMax , expressed in mm."},{"name":"HiggsBSM:gg2A3ttbar","link":"HiggsProcesses.html#anchor52","text":"Scattering g g &rarr; A^0(A_3^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1048."},{"name":"HardQCD:qq2qqgSame","link":"QCDProcesses.html#anchor27","text":"Scatterings q q &rarr; q q g and qbar qbar &rarr; qbar qbar g ( q qbar &rarr; q qbar g scatterings are considered separately below, see HardQCD:qqbar2qqbargSame ). Code 135."},{"name":"double Info::alphaS()","link":"EventInformation.html#anchor46","text":""},{"name":"double Info::pTHat()","link":"EventInformation.html#anchor55","text":""},{"name":"bool LHAup::initLHEF()","link":"LesHouchesAccord.html#anchor86","text":"Writes initialization information to the file above. Such information should already have been set with the methods described in the 'Initialization' section above."},{"name":"void Rndm::init(int seed = 0)","link":"RandomNumbers.html#anchor4","text":"initialize, or reinitialize, the random number generator for the given seed number. Not necessary if the seed was already set in the constructor."},{"name":"ColourReconnection:blowT","link":"ColourReconnection.html#anchor25","text":"Technical parameter used in the Monte Carlo sampling of the temporal phase space volume in SK I. There is no real reason to change this number."},{"name":"ColourReconnection:blowR","link":"ColourReconnection.html#anchor24","text":"Technical parameter used in the Monte Carlo sampling of the spatial phase space volume in SK I. There is no real reason to change this number."},{"name":"ParticleDecays:sigmaSoft","link":"ParticleDecays.html#anchor19","text":"In semileptonic decays to more than one hadron, such as B &rarr; nu l D pi , decay products after the first three are dampened in momentum by an explicit weight factor exp(-p^2/sigmaSoft^2) , where p is the three-momentum in the rest frame of the decaying particle. This takes into account that such further particles come from the fragmentation of the spectator parton and thus should be soft."},{"name":"HiddenValley:spinFv","link":"HiddenValleyProcesses.html#anchor2","text":"The spin of the HV partners of the SM fermions, e.g. Dv , Uv , Ev and nuEv. spin 0. spin 1/2. spin 1."},{"name":"Merging:doUNLOPSTilde","link":"NLOMerging.html#anchor16","text":"This flag allows the UNLOPS machinery to produce the event weights if exclusive NLO input is used for the merging. This flag should be set to 'on' directly after the cross section estimates have been produced."},{"name":"DecayChannelAMPERSAND operator=( const DecayChannelAMPERSAND decayChannelIn)","link":"ParticleDataScheme.html#anchor169","text":"copy the values stored in an existing DecayChannel object."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; Settings::getReadHistory()","link":"SettingsScheme.html#anchor14","text":"Method to retrieve the history of readString commands that have been processed by the Settings instance, e.g. for inspection. Note that readFile command lines are interpreted by readString and thus also are listed, as are the Settings commands read by Pythia::readString and Pythia::readFile."},{"name":"double Particle::phi()","link":"ParticleProperties.html#anchor50","text":"polar and azimuthal angle."},{"name":"friend Hist operator+(const HistAMPERSANDamp; h1, const Hist h2)","link":"Histograms.html#anchor33","text":"add a constant to a histogram or two histograms to each other, bin by bin."},{"name":"PhaseSpace:pTHatMinDiverge","link":"PhaseSpaceCuts.html#anchor5","text":"Extra pT cut to avoid the divergences of some processes in the limit pT &rarr; 0. Specifically, if either or both produced particles have a mass below pTHatMinDiverge then pT is limited from below by the larger of pTHatMin and pTHatMinDiverge."},{"name":"ParticleDecays:mSafety","link":"ParticleDecays.html#anchor18","text":"Minimum mass difference required between the decaying mother mass and the sum of the daughter masses, kept as a safety margin to avoid numerical problems in the decay generation."},{"name":"Onia Processes","link":"OniaProcesses.html","text":"Onia Processes Production of any 3S1 , 3PJ , and 3DJ charmonium and bottomonium states via the colour-singlet and colour-octet mechanisms. This includes by default, but is not limited to, production of the 3S1 J/psi and Upsilon and their radially excited states, as well as the 3PJ chi states and the 3D1 psi(3770). In each process the heavy quark content, either ccbar or bbbar , is followed by a round-bracketed expression which specifies the physical state in spectroscopic notation, (2S+1) L J. Proceding this is a square-bracketed expression, also in spectroscopic notation, which specifies the Fock state through which the process occurs, where (1) indicates a colour-singlet state and (8) a colour-octet state. The unphysical colour-octet states follow the id scheme of 99 n_q n_s n_r n_L n_J where n_q is the quark flavour of the state and n_s is the colour-octet state type. Here 0 is 3S1 , 1 is 1S0 , and 2 is 3PJ. All remaining numbers follow the standard PDG numbering scheme. If a physical state is requested without a corresponding colour-octet state, a colour-octet state is automatically added to the ParticleData when a colour-octet process is selected. The colour-octet state is created with a mass given by the mass of the physical state plus the singlet-octet mass splitting parameter Onia:massSplit , which is by default set at 200 MeV, and decays exclusively to a gluon and the physical state. If the user wishes to manually set the mass splitting for each colour-octet state individually then Onia:forceMassSplit can be set to off. By default the widths of the octet states are set to vanish. This is not realistic, given their presumably rather rapid decay, but a nonvanishing width is not likely to have any measurable consequences that go beyond what comes from viewing the singlet-octet mass splitting as an effective parameter. The original Fortran code for these processes has been contributed by Stefan Wolf [unpublished]. For the C++ version only the unpolarized expressions are retained, since the theoretical predictions of the colour-octet model anyway do not agree with the experimental observations. Furthermore, the polarization effects are modest, so isotropic decay is not a bad starting point. Such an event sample can afterwards be reweighted at will by the user, to test various assumptions. The expressions for the colour-singlet production of the 3S1 and 3PJ states can be found in Bai83 and Gas87. Colour-octet expressions can be found in Cho96 for the 1S0 , 3S1 , and 3PJ states, and the matrix elements for the 3DJ states are taken from Yua98. The implementation of charmonium and bottomonium production, including the colour-octet production mechanism, requires information on long-distance NRQCD matrix elements for the various wavefunctions involved. Default values for these are encoded in the O parameters and are taken from Nas00 ; see also Bar07. The 3DJ long-distance matrix elements are extracted from Yua98. Note that states that differ only by the radial excitation number n_r share the same short-distance matrix elements. The program has therefore been written such that further radial excitations can be easily added by editing this file, without requiring a recompilation of the code. All related arrays must be expanded in exactly the same way, however, i.e. the code of the colour singlet state, the long-distance matrix elements and the individual process on/off switches. Double production of charmonium and bottomonium 3S1 states is also available, but with only the colour-singlet processes included. The short-distance matrix elements for these processes can be found in Hum83 and Qia02. Arrays seperate to those used for single charmonium and bottomonium production set the long-distance NRQCD matrix elements. For consistency these values should be the same as those provided for single charmonium and bottomonium production, but are seperated to allow further control by the user if needed. The description of final-state radiation is in this case based on some further model assumptions. Most of the processes below are divergent in the limit pT &rarr; 0 , and therefore a pTmin scale should be set. Comparisons with data indicate that this divergence can be tamed the same way as for the normal QCD 2 &rarr; 2 cross sections Bar07,Kra08 , which makes sense, since they are all dominated by the same kind of t -channel gluon exchange. It is therefore possible to use the SuppressSmallPT user hook to impose a reweighting that cancels the low- pT divergence. An eikonalized description of these processes, excluding double onia production, is included in the multiparton-interactions framework. Here the low- pT damping is automatic, and additionally the framework is more consistent (e.g. with respect to energy-momentum constraints and the impact-parameter description) for events where the onium production is not the hardest subprocess, as would often be the case in the low- pT limit. Charmonium 3S1 States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Charmonium 3PJ States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Charmonium 3DJ States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Double Charmonium 3S1 States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Bottomonium 3S1 States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Bottomonium 3PJ States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Bottomonium 3DJ States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Double Bottomonium 3S1 States Warning : changed fvec , mvec or pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list."},{"name":"bool ParticleDataEntry::isHadron()","link":"ParticleDataScheme.html#anchor145","text":"true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"void RotBstMatrix::bst(const Vec4AMPERSAND)","link":"FourVectors.html#anchor79","text":""},{"name":"Matching and Merging","link":"MatchingAndMerging.html","text":"Matching and Merging Starting from a Born-level leading-order (LO) process, higher orders can be included in various ways. The three basic approaches would be A formal order-by-order perturbative calculation, in each order higher including graphs both with one particle more in the final state and with one loop more in the intermediate state. This is accurate to the order of the calculation, but gives no hint of event structures beyond that, with more particles in the final state. Today next-to-leading order (NLO) is standard, while next-to-next-to-leading order (NNLO) is coming. This approach thus is limited to few orders, and also breaks down in soft and collinear regions, which makes it unsuitable for matching to hadronization. Real emissions to several higher orders, but neglecting the virtual/loop corrections that should go with it at any given order. Thereby it is possible to allow for topologies with a large and varying number of partons, at the prize of not being accurate to any particular order. The approach also opens up for doublecounting, and as above breaks down in soft and colliner regions. The parton shower provides an approximation to higher orders, both real and virtual contributions for the emission of arbitrarily many particles. As such it is less accurate than either of the two above, at least for topologies of well separated partons, but it contains a physically sensible behaviour in the soft and collinear limits, and therefore matches well onto the hadronization stage. Given the pros and cons, much of the effort in recent years has involved the development of different prescriptions to combine the methods above in various ways. The common traits of all combination methods are that matrix elements are used to describe the production of hard and well separated particles, and parton showers for the production of soft or collinear particles. What differs between the various approaches that have been proposed are which matrix elements are being used, how doublecounting is avoided, and how the transition from the hard to the soft regime is handled. These combination methods are typically referred to as 'matching' or 'merging' algorithms. There is some confusion about the distinction between the two terms, and so we leave it to the inventor/implementor of a particular scheme to choose and motivate the name given to that scheme. PYTHIA comes with methods, to be described next, that implement or support several different kind of algorithms. The field is open-ended, however: any external program can feed in Les Houches events that PYTHIA subsequently showers, adds multiparton interactions to, and hadronizes. These events afterwards can be reweighted and combined in any desired way. The maximum pT of the shower evolution is set by the Les Houches scale , on the one hand, and by the values of the SpaceShower:pTmaxMatch , TimeShower:pTmaxMatch and other parton-shower settings, on the other. Typically it is not possible to achieve perfect matching this way, given that the PYTHIA pT evolution variables are not likely to agree with the variables used for cuts in the external program. Often one can get close enough with simple means but, for an improved matching, User Hooks can be inserted to control the steps taken on the way, e.g. to veto those parton shower branchings that would doublecount emissions included in the matrix elements. Zooming in from the 'anything goes' perspective, the list of relevent approaches actively supported is as follows. For many/most resonance decays the first branching in the shower is merged with first-order matrix elements Ben87, Nor01. This means that the emission rate is accurate to NLO, similarly to the POWHEG strategy (see below), but built into the timelike showers. The angular orientation of the event after the first emission is only handled by the parton shower kinematics, however. Needless to say, this formalism is precisely what is tested by Z^0 decays at LEP1, and it is known to do a pretty good job there. Also the spacelike showers contain a correction to first-order matrix elements, but only for the one-body-final-state processes q qbar &rarr; gamma^*/Z^0/W^+-/h^0/H^0/A0/Z'0/W'+-/R0 Miu99 and g g &rarr; h^0/H^0/A0 , and only to leading order. That is, it is equivalent to the POWHEG formalism for the real emission, but the prefactor 'cross section normalization' is LO rather than NLO. Therefore this framework is less relevant, and has been superseded the following ones. The POWHEG strategy Nas04 provides a cross section accurate to NLO. The hardest emission is constructed with unit probability, based on the ratio of the real-emission matrix element to the Born-level cross section, and with a Sudakov factor derived from this ratio, i.e. the philosophy introduced in Ben87. While POWHEG is a generic strategy, the POWHEG BOX Ali10 is an explicit framework, within which several processes are available. The code required for merging the PYTHIA showers with POWHEG input can be found in include/Pythia8Plugins/PowHegHooks.h , and is further described on a separate page. A user example is found in examples/main31. The other traditional approach for NLO calculations is the MC\@NLO one Fri02. In it the shower emission probability, without its Sudakov factor, is subtracted from the real-emission matrix element to regularize divergences. It therefore requires a analytic knowledge of the way the shower populates phase space. The aMC\@NLO package Fre11 offers an implementation for PYTHIA 8, developed by Paolo Torrielli and Stefano Frixione. The global-recoil option of the PYTHIA final-state shower has been constructed to be used for the above-mentioned subtraction. Multi-jet merging in the CKKW-L approach Lon01 is directly available. Its implementation, relevant parameters and test programs are documented on a separate page. Multi-jet matching in the MLM approach Man02, Man07 is also available, either based on the ALPGEN or on the Madgraph variant, and with input events either from ALPGEN or from Madgraph. For details see separate page. Unitarised matrix element + parton shower merging (UMEPS) is directly available. Its implementation, relevant parameters and test programs are documented on a separate page. Next-to-leading order multi-jet merging (in the NL3 and UNLOPS approaches) is directly available. Its implementation, relevant parameters and test programs are documented on a separate page. Next-to-leading order jet matching in the FxFx approach is also available. For details see separate page. MC\@NLO, jet matching, multi-jet merging and NLO merging with main89.cc A common Pythia main program for MC\@NLO NLO+PS matching, MLM jet matching, FxFx (NLO) jet matching, CKKW-L merging, UMEPS merging and UNLOPS (NLO) merging is available through main89.cc , together with the input files main89mlm.cmnd , main89fxfx.cmnd , main89ckkwl.cmnd , main89umeps.cmnd and main89unlops.cmnd. The interface to MLM jet matching relies on MadGraph, while all other options of main89.cc use aMC\@NLO input. main89.cc produces HepMC events Dob01 , that can be histogrammed (e.g. using RIVET Buc10 ), or used as input for a detector simulation. If the user is not familiar with HepMC analysis tools, it is possible to instead use Pythia's histogramming routines. For this, remove the lines referring to HepMC, and histogram events as illustrated (for CKKW-L) for the histogram histPTFirstSum in main84.cc , i.e. using weight*normhepmc as weight. All settings can be transferred to main89.cc through an input file. The input file is part of the command line input of main89.cc , i.e. you can execute main89 with the command ./main89 myInputFile.cmnd myhepmc.hepmc to read the input myInputFile.cmnd and produce the output file myhepmc.hepmc. Since main89.cc is currently a 'front-end' for different types of matching/merging, we will briefly discuss the inputs for this sample program in the following. Inputs In its current form, main89.cc uses LHEF input to transfer (weighted) phase space points to Pythia. It is possible to include all parton multiplicities in one LHEF sample. If e.g. UMEPS merging for W-boson + up to two additional partons is to be performed, one LHE file containing W+zero, W+one and W+two parton events is required. All input settings are handed to main89.cc in the form of an input file. We have included the input settings files &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; main89mlm.cmnd , which illustrates the MLM jet matching interface, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; main89ckkwl.cmnd , which illustrates the CKKW-L multi-jet merging interface, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; main89umeps.cmnd , which illustrates the UMEPS multi-jet merging interface, and &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; main89fxfx.cmnd , which illustrates the FxFx NLO jet matching interface, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; main89unlops.cmnd , which illustrates the UNLOPS multi-jet NLO merging interface. Other settings (e.g. using main89.cc as simple LO+PS or as MC\@NLO interface) are of course possible. In the following, we will briefly explain how input for the five choices above are generated and handled. MLM jet matching with main89.cc For MLM jet matching, main89.cc currently relies on LHEF input from MadGraph. Due to the particular unweighting strategy performed in the generation of these inputs, the sample program starts by estimating the cross section. After this estimate, MLM jet matching within the Madgraph approach is performed in a second Pythia run. Example MLM settings can be found in main89mlm.cmnd. Please consult Jet Matching for more details. CKKW-L merging with main89.cc For CKKW-L merging, main89.cc currently relies on LHEF inputs generated with the leading-order mode of aMC\@NLO (i.e. events should be generated with ./bin/generate_events aMC\@LO ). No run to estimate the cross section estimate is needed. Example CKKW-L settings can be found in main89ckkwl.cmnd. Please consult CKKW-L merging for more details. UMEPS merging with main89.cc For UMEPS merging, main89.cc currently relies on LHEF inputs generated with the leading-order mode of aMC\@NLO as well (see above). main89.cc automatically assigns if an event will be used as 'standard' event or as 'subtractive' contribution. Example UMEPS settings can be found in main89umeps.cmnd. Please consult UMEPS merging and CKKW-L merging for more details. FxFx (NLO) jet matching with main89.cc For FxFx jet matching, main89.cc relies on MC\@NLO input LHE files generated with aMC\@NLO. To produce FxFx outputs in aMC\@NLO, the settings PYTHIA8  = parton_shower , 3 = ickkw and x = ptj are necessary in your aMC\@NLO run card. Here, x is the value of the matching scale in FxFx, i.e. has be identical to JetMatching:qCutME in the Pythia inputs. Example FxFx settings for Pythia can be found in main89fxfx.cmnd. Please consult Jet Matching and aMC\@NLO matching for more details. UNLOPS (NLO) merging with main89.cc For UNLOPS merging, main89.cc currently relies on LHEF inputs generated with the aMC\@NLO. The UNLOPS interface in main89.cc requires a) leading-order inputs generated with the leading-order mode of aMC\@NLO, using the UNLOPS prescription, and b) next-to-leading-order inputs generated with the NLO mode of aMC\@NLO, using the UNLOPS prescription. To produce UNLOPS outputs in aMC\@NLO, the settings PYTHIA8  = parton_shower , 4 = ickkw and x = ptj are necessary in your aMC\@NLO run card. Here, x is the value of the merging scale in UNLOPS, i.e. has be identical to Merging:TMS in the Pythia inputs. main89.cc will then process NLO inputs and LO inputs consecutively, and will automatically assign if an event will be used as 'standard' event or as 'subtractive' contribution. Example UNLOPS settings can be found in main89umeps.cmnd. Please consult UMEPS merging and CKKW-L merging for more details. Implementing an external ME+PS combination scheme and interfacing this plugin with Pythia For experts and developers of new matching/merging schemes, Pythia also offers the possibility to completely replace its internal merging machinery with a user-defined plugin code (much in the same way that parton shower plugins (cf. Implement New Showers ) are possible). This allows for maximum flexibility while still benefiting from the full Pythia event generation machinery. Note that the ME+PS merging with the VINCIA and DIRE shower plugins make use of this flexibility, and might thus provide helpful clarifications.  Of course, implementing your own, new matching/merging scheme is a non-trivial task, and comprehensive guidelines on how to proceed are impossible to set. However, it is important that an external matching/merging plugin interfaces to Pythia in a simple and well-defined manner. Here, we will document which C++ functions are necessary to be able to use an external matching/merging (MM) plugin within Pythia. To understand how to design a MM plugin for Pythia, it is useful to review how Pythia's internal merging machinery is structured. The interaction between the core Pythia and the merging code is governed by the Merging and MergingHooks classes. Note that for moderately complex requirements, it may be sufficient to only replace Pythia's instance of MergingHooks with a pointer to an external class (cf. CKKW-L merging ). The latter two classes are supplemented with the helper classes History and HardProcess. The latter gathers information on the (user-supplied information about the) hard core scattering process to which hard jets are added by ME+PS merging. It is only used as a helper to the MergingHooks class. The History class contains the implementation of all internal (LO or NLO) merging schemes. The Merging class acts as a bridge between the implementation in the History class and the rest of the Pythia code. To implement an external MM plugin, you will have to write classes that derive from the Merging , MergingHooks and HardProcess classes of Pythia. For special cases, it might also be permissible to only implement a replacement of the Merging class, while still using Pythia's implementation of the other two classes.  The external MM plugin can then be transferred to and used by Pythia much in the same way as UserHooks classes or shower plugins. More concretely, an external MM code will be used if a pointer to an instance of the external classes is transferred to Pythia via the methods The option to only use a user-defined MergingHooks instance is already documented in the item CKKW-L merging and will not be discussed further. We will now focus on how to implement external Merging , MergingHooks and HardProcess classes that can be used as a complete replacement of the Pythia methods.  Let us assume that you want to create a class of type MyMerging , and you call its instance myMerging. For this external ME+PS merging class to be interfaced to Pythia, the class needs to inherit from the Pythia8::Merging base class. It is further necessary to define the following functions that serve as interface to Pythia: For more details on how to design your MyMerging class, and to understand the interface to Pythia, studying Pythia's internal code is unavoidable. Each potential developer of a MM plugin should do so. The other main ingredient of the interface to MM plugins is a new implementation of the MergingHooks class. Let us assume that you want to create a class of type MyMergingHooks , and you call its instance myMergingHooks. For this class to be interfaced to Pythia, it will need to inherit from the Pythia8::MergingHooks base class. The MergingHooks base class allows for further virtual functions that are not directly called by Pythia, and are hence not necessary to define. Th usage of these functions within Pythia's Merging and History classes is documented in CKKW-L merging. The additional (optional) virtual functions are: The internal implementation of MergingHooks in Pythia heavily relies on the HardProcess helper class. It is in principle not necessary to follow the same strategy when implementing a derived MyMergingHooks class. However, to benefit from the Pythia implementation, and to allow for a structure similar to the internal code also for an external MM plugin, it is also possible to effectively replace (in the MergingHooks class) the pointer to an instance of HardProcess with a pointer to an external implementation. Let us assume that you want to create a class of type MyHardProcess , and you call its instance myHardProcess. For this class to be interfaced to MergingHooks (or the derived MyMergingHooks class), it will need to inherit from the Pythia8::HardProcess base class."},{"name":"Diffraction:MBRalpha","link":"Diffraction.html#anchor5","text":"the parameters of the Pomeron trajectory."},{"name":"Vec4 ClusterJet::p(int i)","link":"EventAnalysis.html#anchor21","text":"gives a Vec4 corresponding to the four-momentum defined by the sum of all the contributing particles to the i 'th jet."},{"name":"void AlpgenPar::void printParams()","link":"AlpgenEventInterface.html#anchor14","text":"Method to print a list of stored parameters."},{"name":"Beam Shape","link":"BeamShape.html","text":"Beam Shape The Beam Parameters page explains how you can set a momentum spread of the two incoming beams, and a spread and offset for the location of the interaction vertex. The spread is based on a simple parametrization in terms of independent Gaussians, however, which is likely to be too primitive for realistic applications. It is therefore possible to define your own class, derived from the BeamShape base class, and hand it in to Pythia with the pythia.setBeamShapePtr( BeamShape*) method. Below we describe what such a class has to do. An explicit toy example is shown in main23.cc. The BeamShape base class has a very simple structure. It only has two main virtual methods. The first, init() , is used for initialization. The second, pick() , selects beam momentum and production vertex in the current event."},{"name":"PhaseSpace:mHatMax","link":"PhaseSpaceCuts.html#anchor2","text":"The maximum invariant mass. A value below mHatMin means there is no upper limit."},{"name":"WeakSingleBoson:all","link":"ElectroweakProcesses.html#anchor12","text":"Common switch for the group of a single gamma^*/Z^0 or W^+- production."},{"name":"double Vec4::mCalc()","link":"FourVectors.html#anchor17","text":""},{"name":"void Settings::addPVec(string key,  vectorAMPERSANDlt;doubleAMPERSANDgt; default, bool hasMin, bool hasMax,  double min, double max)","link":"SettingsScheme.html#anchor31","text":""},{"name":"void Event::bst(double betaX, double betaY, double betaZ)","link":"EventRecord.html#anchor33","text":""},{"name":"Merging:applyVeto","link":"CKKWLMerging.html#anchor55","text":"If off, no event veto based on the merging scale is applied in CKKW-L merging. This means that the user has to implement the veto by hand in the Pythia main program. It can be useful to postpone event vetoes for the purpose of merging scale variations."},{"name":"virtual double SpaceShower::getSplittingProb( const  EventAMPERSAND event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor45","text":"This function should return the probability of an emission of the particle with index iEmt from the particle with index iRad and iRec. All indices are relative to the input event. The identifier name can be used for additional flexibility."},{"name":"Check:epTolWarn","link":"ErrorChecks.html#anchor8","text":"A check on the same summed deviation as above, but counted as a warning rather than an error, and not leading to the event being classified as aborted."},{"name":"int SlowJet::iNext()","link":"EventAnalysis.html#anchor63","text":""},{"name":"Charmonium:O(3DJ)[3P0(8)]","link":"OniaProcesses.html#anchor35","text":"The colour-octet long-distance matrix elements <O[3P0(8)]>/m_Q^2 for the 3DJ charmonium states. The remaining <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Diffraction:PomFluxAlphaPrime","link":"Diffraction.html#anchor3","text":"The Pomeron trajectory slope alpha' above for the 1, 3 and 4 flux options. Values are fixed in options 6 and 7."},{"name":"Charmonium:qqbar2ccbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor17","text":"Colour-octet production of 3S1 charmonium states via q qbar &rarr; ccbar[3S1(8)] g. Code 404."},{"name":"StringFlav:popcornSpair","link":"FlavourSelection.html#anchor36","text":"extra suppression for having an s sbar pair shared between the B and Bbar in a B M Bbar configuration."},{"name":"BeamRemnants:saturation","link":"BeamRemnants.html#anchor10","text":"Controls the suppresion due to saturation in the new model. The exact formula used is exp(-M / k) , where M is the multiplet size and k is this parameter. Thus a small number will result in a large saturation."},{"name":"bool SigmaProcess::isSChannel()","link":"SemiInternalProcesses.html#anchor22","text":"normally the choice of renormalization and factorization scales in 2 &rarr; 2 and 2 &rarr; 3 processes is based on the assumption that t - and u -channel exchanges dominates the cross section. In cases such as f fbar &rarr; gamma* &rarr; f' fbar' a 2 &rarr; 2 process actually ought to be given scales as a 2 &rarr; 1 one, in the sense that it proceeds entirely through an s -channel resonance. This can be achieved if you override the default false to return true. See further the page on couplings and scales."},{"name":"void ParticleDataEntry::setResonancePtr(ResonanceWidths*  resonancePtr)","link":"ParticleDataScheme.html#anchor159","text":""},{"name":"void DecayChannel::bRatio(double bRatio,  bool countAsChanged = true)","link":"ParticleDataScheme.html#anchor172","text":""},{"name":"SUSY:qqbar2squarkantisquark:onlyQCD","link":"SUSYProcesses.html#anchor12","text":"When switched on this flag switches off all but the s -channel gluon contribution in the calculation of same-isospin squark-antisquark production cross sections. Intended for reference only. For the most accurate physics simulation, leave this flag in the off position."},{"name":"double Particle::eta()","link":"ParticleProperties.html#anchor55","text":"rapidity and pseudorapidity."},{"name":"double Info::sigmaErr(int i = 0)","link":"EventInformation.html#anchor104","text":"the estimated cross section and its estimated error, summed over all allowed processes ( i = 0 ) or for the given process, in units of mb. The numbers refer to the accepted event sample above, i.e. after any user veto."},{"name":"bool LHAup::pdfIsSet()","link":"LesHouchesAccord.html#anchor59","text":""},{"name":"virtual bool UserHooks::initAfterBeams()","link":"UserHooks.html#anchor7","text":"This routine is called by Pythia::init(), after the beams have been set up, but before any other initialisation. Therefore, at this stage, it is still possible to modify settings (apart from Beams:* ) and particle data. This is mainly intended to be used in conjunction with Les Houches Event files, where headers are read in during beam initialisation, see the header functions in the Info class. In the base class this method returns true. By returning false, PYTHIA initialisation will be aborted."},{"name":"double CoupSM::VCKMid(int id1, int id2)","link":"StandardModelParameters.html#anchor42","text":""},{"name":"void Settings::resetFlag(string key)","link":"SettingsScheme.html#anchor69","text":""},{"name":"void ParticleDataEntry::addChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0,  int prod7 = 0,)","link":"ParticleDataScheme.html#anchor152","text":"adds a decay channel with up to 8 products."},{"name":"WeakSingleBoson:ffbar2ffbar(s:W)","link":"ElectroweakProcesses.html#anchor17","text":"Scattering f_1 fbar_2 &rarr; W+- &rarr; f_3 f_4. Almost equivalent to process 222, but written as a 2 &rarr; 2 process, so that pT could be used as cut or ordering variable. Final-state flavour selection is based on the W allowed decay modes. There are two simplifications relative to the implementation in process 222. Firstly, it is not possible to set different decay modes for the W^+ and the W^- ; instead the allowed W^+ ones will be used throughout, with charge conjugation for the W^-. Secondly, quark mass corrections are neglected in the decay angular distribution. Not included in the WeakSingleBoson:all set. Code 225."},{"name":"virtual Event TimeShower::clustered( const EventAMPERSAND event, int  iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor21","text":"This function should return a PYTHIA event record in which the emission of the particle with index iEmt in the input event (also changing the particles with index iRad and iRec ) is undone. The identifier name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist. Reclustered events are crucial in setting up consistent parton shower histories."},{"name":"Higgs:runningLoopMass","link":"HiggsProcesses.html#anchor2","text":"The partial width of a Higgs particle to a pair of gluons or photons, or a gamma Z^0 pair, proceeds in part through quark loops, mainly b and t. There is some ambiguity what kind of masses to use. Default is running MSbar ones, but alternatively fixed pole masses are allowed (as was standard in PYTHIA 6), which typically gives a noticeably higher cross section for these channels. (For a decay to a pair of fermions, such as top, the running mass is used for couplings and the fixed one for phase space.)"},{"name":"Merging:muRen","link":"NLOMerging.html#anchor3","text":"The fixed renormalisation scale used in the hard process cross section, as needed to generate the leading-order weight, in case the renormalisation scale cannot be inferred from Les Houches event input. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the SCALUP variable of the current LH event will be used instead."},{"name":"bool ParticleData::isQuark(int id)","link":"ParticleDataScheme.html#anchor69","text":"true for a quark or an antiquark."},{"name":"const ParticleAMPERSAND Event::operator[](int i)","link":"EventRecord.html#anchor2","text":"returns a ( const ) reference to the i 'th particle in the event record, which can be used to get (or set) all the properties of this particle."},{"name":"void Hist::rivetTable(ostreamAMPERSANDamp; os = cout,  bool printError = false)","link":"Histograms.html#anchor13","text":""},{"name":"Init:showProcesses","link":"MainProgramSettings.html#anchor1","text":"Print a list of all processes that will be simulated, with their estimated cross section maxima, as used for the subsequent Monte Carlo selection. Also print corresponding Les Houches initialization data, where relevant."},{"name":"double LHAup::eBeamA()","link":"LesHouchesAccord.html#anchor15","text":""},{"name":"int SigmaProcess::resonanceB()","link":"SemiInternalProcesses.html#anchor21","text":"are the codes of up to two s -channel resonances contributing to the matrix elements. These are used by the program to improve the phase-space selection efficiency, by partly sampling according to the relevant Breit-Wigner distributions. Massless resonances (the gluon and photon) need not be specified."},{"name":"bool ParticleData::isParton()","link":"ParticleDataScheme.html#anchor72","text":"true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"FourthTop:ffbar2tPrimeqbar(s:W)","link":"FourthGenerationProcesses.html#anchor13","text":"Scatterings f fbar' &rarr; t' qbar'' by s -channel exchange of a W^+- boson. Code 825."},{"name":"Charmonium:qqbar2ccbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor23","text":"Colour-octet production of 3S1 charmonium states via q qbar &rarr; ccbar[3SJ(8)] g. Code 410."},{"name":"double Particle::mCalc()","link":"ParticleProperties.html#anchor38","text":""},{"name":"virtual void TimeShower::prepare( int iSys, EventAMPERSAND event,  bool limitPTmaxIn = true)","link":"ImplementNewShowers.html#anchor11","text":"This method is called immediately after a new interaction (or the products of a resonance decay) has been added, and should then be used to prepare the subsystem of partons for subsequent evolution. In the current code this involves identifying all colour and charge dipole ends: the position of radiating and recoiling partons, maximum pT scales, possible higher-order matrix elements matchings to apply, and so on. The iSys parameter specifies which parton system is to be prepared. It is used to extract the set of partons to be treated, with rules as described in the above section on subsystems. Specifically, the first two partons represent the incoming state, or are 0 for resonance decays unrelated to the beams, while the rest are not required to be in any particular order. The limitPTmaxIn switch conveys the choice made on maximum scale for the dipole-ends evolution associated with the hard interaction of the event (while scales for subsequent MPIs by default are set to respect pT ordering). If true then this scale is set by the user choice options, see the TimeShower::limitPTmax method above, while if false emissions are allowed to go up to the kinematical limit. For the two-hard-interactions scenario, the two class variables dopTlimit1 and dopTlimit2 instead convey the choice made."},{"name":"bool ParticleData::init(string  startFile = AMPERSANDquot;../share/Pythia8/xmldoc/ParticleData.xmlAMPERSANDquot;)","link":"ParticleDataScheme.html#anchor4","text":"read in an XML-style file with particle data and initialize the particle data tables accordingly. This command is executed in the Pythia constructor, i.e. is mainly for internal use. the name of the data file to be read. When called from the Pythia constructor the directory is provided by the PYTHIA8DATA environment variable, if set, else by the argument of this constructor, which has the default value &quot;../share/Pythia8/xmldoc&quot;."},{"name":"void Particle::bst(const Vec4AMPERSAND pBst, double mBst)","link":"ParticleProperties.html#anchor110","text":"as above, but also use gamma> = e/m to reduce roundoff errors."},{"name":"ExcitedFermion:contactDec","link":"CompositenessProcesses.html#anchor31","text":"Strength of contact-interaction decay channels, implemented as three-body decays l^* &rarr; l f fbar for excited leptons and neutrinos, where unity corresponds to the same normalization as for the production channels."},{"name":"JetMatching:qCutME","link":"JetMatching.html#anchor28","text":"The cut applied to regulate multi-jet matrix elements. Note that this cut can differ from the matching scale."},{"name":"RIVET usage","link":"RIVETusage.html","text":"RIVET usage RIVET is a toolkit for the validation of Monte Carlo event generators Buc10. It contains the results of many experimental analyses, so that generator output can easily be compared to data, as well as providing a framework to implement your own analyses.  Although using PYTHIA with RIVET is not officially supported, some helpful hints are given below. The full RIVET manual is available online. Using PYTHIA with RIVET The following assumes that you already have RIVET installed. Instructions for this may be found here. Events are passed from PYTHIA to RIVET using the HepMC format. PYTHIA must be compiled with HepMC support, using the same version of HepMC used when compiling RIVET. This is setup through the PYTHIA configure script e.g. ./configure --with-hepmc=/path/to/HepMC --with-hepmcversion=HepMC.version.number The PYTHIA library itself does not need to be recompiled. The examples/main42.cc sample program can then be used to generate events in HepMC format (which examples/main43.cc extends by allowing subruns). When in the examples directory, the main program can be built and used as follows make main42  ./main42 main42.cmnd main42.hepmc The first argument is the input file which provides the options for event generation, while the second is the output file where the HepMC events should be written. This HepMC file may now be read and processed by RIVET rivet --analysis=ANALYSIS_NAME main42.hepmc where ANALYSIS_NAME is a built-in RIVET analysis , or one you have created yourself. The output of RIVET is in the form of .aida files, containing the histograms for the analysis, which can be processed further with RIVET (see the RIVET documentation for more details). The above examples requires that (potentially large) HepMC events are stored to disk before being read by RIVET. It is possible, instead, to pass the events directly to RIVET as they are produced by using a FIFO pipe. This is done with the mkfifo command mkfifo my_fifo  ./main42.exe main42.cmnd my_fifo &  rivet --analysis=ANALYSIS_NAME my_fifo Note that main42 is run in the background."},{"name":"void Event::rotbst(const RotBstMatrixAMPERSAND M)","link":"EventRecord.html#anchor36","text":"rotate and boost by the combined action encoded in the RotBstMatrix M."},{"name":"StringZ:bLund","link":"Fragmentation.html#anchor2","text":"The b parameter of the Lund symmetric fragmentation function."},{"name":"StringFlav:thetaL1S1J2","link":"FlavourSelection.html#anchor33","text":"gives the mixing angle theta in the (L=1,S=1,J=2) tensor meson sector, expressed in degrees."},{"name":"StringFlav:thetaL1S1J1","link":"FlavourSelection.html#anchor32","text":"gives the mixing angle theta in the (L=1,S=1,J=1) pseudovector meson sector, expressed in degrees."},{"name":"StringFlav:thetaL1S1J0","link":"FlavourSelection.html#anchor31","text":"gives the mixing angle theta in the (L=1,S=1,J=0) scalar meson sector, expressed in degrees."},{"name":"int Info::id1pdf()","link":"EventInformation.html#anchor38","text":""},{"name":"void Vec4::flip3()","link":"FourVectors.html#anchor61","text":"flip the sign of the three-vector components, but keep the fourth component unchanged."},{"name":"void DecayChannel::onShellWidthFactor(double factor)","link":"ParticleDataScheme.html#anchor190","text":"multiply the current partial width by factor."},{"name":"HiggsBSM:ffbar2H+H-","link":"HiggsProcesses.html#anchor62","text":"Scattering f fbar &rarr; H+ H-. Code 1085."},{"name":"ColourReconnection:forceHadronLevelCR","link":"ColourReconnection.html#anchor3","text":"This flag switches on colour reconnection in the forceHadronLevel function. The function is called when only the hadron level of PYTHIA is used (see Hadron-level Standalone ). The MPI-based model is not available for this setup and any resonance decays not already decayed are not included in the CR."},{"name":"bool LHAup::eventLHEF(bool verbose = true)","link":"LesHouchesAccord.html#anchor87","text":"Writes event information to the file above. Such information should already have been set with the methods described in the 'Event input' section above. This call should be repeated once for each event to be stored. By default the event information is lined up in columns. To save space, the alternative verbose = false only leaves a single blank between the information fields."},{"name":"virtual bool MyMergingHooks::canVetoStep()","link":"MatchingAndMerging.html#anchor10","text":"This function will be used to tell Pythia if a CKKW-L-style event veto after the first parton shower emission should be checked. If so, the function should return true, and false otherwise."},{"name":"StringFlav:suppressLeadingB","link":"FlavourSelection.html#anchor38","text":"Suppress leading-baryon production. No suppression. Suppress the production of a diquark in the string breaking closest to a quark end of a string, by either of the factors below. This suppresses the production of first-rank baryons by the same amount. Indirectly also the second-rank and, if popcorn production is switched on, third-rank (anti)baryon production is affected."},{"name":"Zprime:anutau","link":"NewGaugeBosonProcesses.html#anchor27","text":"axial coupling of nu_tau neutrinos."},{"name":"bool Particle::isResonance()","link":"ParticleProperties.html#anchor81","text":"particles where the decay is to be treated as part of the hard process, typically with nominal mass above 20 GeV ( W^+-, Z^0, t, ... )."},{"name":"virtual bool MyMergingHooks::canVetoEmission()","link":"MatchingAndMerging.html#anchor12","text":"This function will be used to tell Pythia if a veto of emissions should potentially be applied."},{"name":"StringFlav:mesonSL1S1J2","link":"FlavourSelection.html#anchor21","text":"the relative tensor production ratio (L=1,S=1,J=2) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSL1S1J1","link":"FlavourSelection.html#anchor20","text":"the relative pseudovector production ratio (L=1,S=1,J=1) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSL1S1J0","link":"FlavourSelection.html#anchor19","text":"the relative scalar production ratio (L=1,S=1,J=0) /pseudoscalar for strange mesons."},{"name":"ParticleAMPERSAND Event::operator[](int i)","link":"EventRecord.html#anchor1","text":""},{"name":"void Pythia8ToHepMC::set_store_proc(bool b = true)","link":"HepMCInterface.html#anchor13","text":""},{"name":"void LHAup::setBeamA( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0)","link":"LesHouchesAccord.html#anchor5","text":""},{"name":"void SigmaProcess::sigmaKin()","link":"SemiInternalProcesses.html#anchor6","text":"is called once a kinematical configuration has been determined, but before the two incoming flavours are known. This routine can therefore be used to perform calculations that otherwise might have to be repeated over and over again in sigmaHat below. For instance a flavour-independent cross section calculation for a q g initial state would be repeated 20 times in sigmaHat , five times for the five quark flavours allowed in the incoming beams, times twice to include antiquarks, times twice since the (anti)quark could be in either of the two beams. You could therefore calculate the result once only and store it as a private data member of the class. It is optional whether you want to use this method, however, or put everything in sigmaHat."},{"name":"double Pythia::parm(string key)","link":"ProgramFlow.html#anchor33","text":"read in a double-precision variable from the Settings database. the name of the variable to be read."},{"name":"void Vec4::p(double pxIn, double pyIn, double pzIn,  double eIn)","link":"FourVectors.html#anchor6","text":"sets all components to their input values."},{"name":"BeamRemnants:valencePowerMeson","link":"BeamRemnants.html#anchor13","text":"The abovementioned power for valence quarks in mesons."},{"name":"void ParticleDataEntry::setMWidth(double mWidth)","link":"ParticleDataScheme.html#anchor112","text":""},{"name":"virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const EventAMPERSAND event)","link":"UserHooks.html#anchor19","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of Pythia::next(). is the position/status when the routine is called, information that can help you decide your course of action. Agrees with options 2 - 5 of the doVetoPT(...) routine above, while options 0 and 1 are not relevant here. is the number of ISR emissions in the hardest process so far. For resonance decays, iPos = 5 , it is 0. is the number of FSR emissions in the hardest process so far. For resonance decays, iPos = 5 , it is the number of emissions in the currently studied system. the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', and also those from further multiparton interactions. This may not be desirable for comparisons with matrix-element calculations. You may want to make use of the subEvent(...) method above to obtain a simplified event record."},{"name":"int LHAup::idBeamA()","link":"LesHouchesAccord.html#anchor13","text":""},{"name":"HadronScatter:mode","link":"HadronScattering.html#anchor1","text":"The first two options are variations of the same model, whereas option 2 respresents a different model. The new model, based on separation in rapidity as described in Fis16. Further options are found here. The new model, based on separation in rapidity and azimuthal angle as described in Fis16. Further options are found here. The old model. Further options are found here. Warning: Option 2 is still at an experimental level, and should not be used unless you know what you are doing."},{"name":"Hadron-Level Standalone","link":"HadronLevelStandalone.html","text":"Hadron-Level Standalone The Les Houches Accord allows external process-level configurations to be fed in, for subsequent parton-level and hadron-level generation to be handled internally by PYTHIA. There is no correspondingly standardized interface if you have external events that have also been generated through the parton-level stage, so that only the hadron-level remains to be handled. A non-standard way to achieve this exists, however, and can be useful both for real applications and for various tests of the hadronization model on its own. The key trick is to set the flag ProcessLevel:all = off. When pythia.next() is called it then does not try to generate a hard process. Since there are no beams, it is also not possible to perform the normal PartonLevel step. (It is still possible to generate final-state radiation, but this is not automatic. It would have to be done by hand, using the pythia.forceTimeShower(...) method, before pythia.next() is called.) Thus only the HadronLevel methods are called, to take the current content of the event record stored in pythia.event as a starting point for any hadronization and decays that are allowed by the normal parameters of this step. Often the input would consist solely of partons grouped into colour singlets, but also (colour-singlet) particles are allowed. To set up all the parameters, a pythia.init() call has to be used, without any arguments. In brief, the structure of the main program therefore should be something like Pythia pythia;                     // Declare generator.  Event& event = pythia.event            // Convenient shorthand.  pythia.readString('ProcessLevel:all = off'); // The trick!  pythia.init();                     // Initialization.  for (int iEvent = 0; iEvent < nEvent; ++iEvent) {    // Insert filling of event here!    pythia.next();                    // Do the hadron level.  } Of course this should be supplemented by analysis of events, error checks, and so on, as for a normal PYTHIA run. The unique aspect is how to fill the event inside the loop, before pythia.next() is called. Input configuration To set up a new configuration the first step is to throw away the current one, with event.reset(). This routine will also reserve the zeroth entry in the even record to represent the event as a whole. With the event.append(...) methods a new entry is added at the bottom of the current record, i.e. the first time it is called entry number 1 is filled, and so on. The append method basically exists in four variants, either without or with history information, and with four-momentum provided either as a Vec4 four-vector or as four individual components: append( id, status, col, acol, p, m)  append( id, status, col, acol, px, py, pz, e, m)  append( id, status, mother1, mother2, daughter1, daughter2, col, acol, p, m)  append( id, status, mother1, mother2, daughter1, daughter2, col, acol, px, py, pz, e, m) The methods return the index at which the entry has been stored, but normally you would not use this feature. All the four methods have two final, optional arguments. The scale one is highly relevant if you want to perform parton showers in addition to hadronization; see the pythia.forceTimeShower() description below. The final pol one denotes polarization, and could be used to perform polarized tau decays. You can find descriptions of the input variables here. The PDG particle code id and the Les Houches Accord colour col and anticolour acol tags must be set correctly. The four-momentum and mass have to be provided in units of GeV; if you omit the mass it defaults to 0. Outgoing particles that should hadronize should be given status code 23. Often this is the only status code you need. You could e.g. also fill in incoming partons with -21 and intermediate ones with -22, if you so wish. Usually the choice of status codes is not crucial, so long as you recall that positive numbers correspond to particles that are still around, while negative numbers denote ones that already hadronized or decayed. However, so as not to run into contradictions with the internal PYTHIA checks (when Check:event = on ), or with external formats such as HepMC, we do recommend the above codes. When pythia.next() is called the positive-status particles that hadronize/decay get the sign of the status code flipped to negative but the absolute value is retained. The new particles are added with normal PYTHIA status codes. For normal hadronization/decays in pythia.next() the history encoded in the mother and daughter indices is not used. Therefore the first two append methods, which set all these indices vanishing, should suffice. The subsequent hadronization/decays will still be properly documented. The exception is when you want to include junctions in your string topology, i.e. have three string pieces meet. Then you must insert in your event record the (decayed) particle that is the reason for the presence of a junction, e.g. a baryon beam remnant from which several valence quarks have been kicked out, or a neutralino that underwent a baryon-number-violating decay. This particle must have as daughters the three partons that together carry the baryon number. When ProcessLevel:all = off the pythia.next() call applied to a parton-level confguration will hadronize it, without generating any parton showers. Indeed, the point of the framework described here is to be able to feed in complete showered parton topologies for hadronization. (The exception is if you feed in a resonance, see next section.) As an option, however, it is possible to generate a shower before the pythia.next() step by using the pythia.forceTimeShower( int iBeg, int iEnd, double pTmax, int nBranchMax = 0) method. Here iBeg and iEnd give the range of partons that should be allowed to shower, pTmax the maximum pT scale of emissions, and a nonzero nBranchMax a maximum number of allowed branchings. Additionally, a scale has to be set for each parton that should shower, which requires an additional final argument to the append methods above, or alternatively separately with the pythia.event[i].scale(...) method. This scale limits the maximum pT allowed for each parton, in addition to the global pTmax. When not set the scale defaults to 0, meaning no radiation for that parton. The sample program in main21.cc illustrates how you can work with this facility, both for simple parton configurations and for more complicated ones with junctions, and also how to force a shower. As an alternative to setting up a topology with the methods above, a Les Houches Event File (LHEF) can also provide the configurations, using the 'no-beams' extension. For parsing reasons the <init> and </init> tags need to be present as two separate lines, but there need not be anything between them. If there is, then the beam identities should be picked to be 0. A standard <LesHouchesEvents version='1.0'> line must also be at the top of the file. For the rest only the <event>....</event> blocks need to be present, one for each event. You should select Beams:frameType = 4 and provide the file name in Beams:LHEF , but setting ProcessLevel:all = off here is superfluous since the absence of beams is enough to make this apparent. Needless to say, an externally linked LHAup class works as well as an LHEF, with Beams:frameType = 5. The event information to store in the LHEF, or provide by the LHAup , is essentially the same as above. The only difference is in status codes: outgoing particles should have 1 instead of 23, and intermediate resonances 2 instead of -22. Incoming partons, if any, are -1 instead of -21. Extensions to resonance decays With the above scheme, pythia.next() will generate hadronization, i.e. string fragmentation and subsequent decays of normal unstable particles. Alternatively it could be used to decay resonances , i.e. W, Z , top, Higgs, SUSY and other massive particles. The default when a resonance is encountered is to decay it, let the decay products shower, and finally hadronize the partons. Should a decay sequence already be provided at input, this sequence will be used as input for the showers, which are handled consecutively, followed by hadronization. Thus, a Higgs could be provided alone, or decaying to a pair of W bosons, or the same with the W 's decaying further to fermion pairs. Needless to say, correct process-specific angular correlations in decays should not be expected when the process is unspecified. If you do not want resonances to decay then you can use the ProcessLevel:resonanceDecays = off setting. If instead you want them to decay but not shower, you can use either PartonLevel:FSR = off or PartonLevel:FSRinResonances = off. A warning here is that, generally, it is not a good idea to provide a part of the shower history but not all, e.g. Z^0 &rarr; q qbar g : it is not straightforward to avoid doublecouning or other problems within this simpler alternative to a full-scale event generation. The input configuration has to follow the rules described above, i.e. ProcessLevel:all = off should be set for internal input, but is not necessary for LHEF input. It is possible to combine several resonances, and other coloured or uncoloured particles into the same event. Partonic daughters of resonances would then shower, but other partons not. It may be possible to fool the program, however, since this is not a fully tested core functionality, so don't combine wildly if there is no reason to. Repeated hadronization or decay An alternative approach is possible with the pythia.forceHadronLevel() routine. This method does a call to the HadronLevel methods, irrespective of the value of the HadronLevel:all flag. If you hadronize externally generated events it is equivalent to a pythia.next() call with ProcessLevel:all = off. This method truly sticks to the hadron level, and thus cannot handle resonance decays. The real application instead is for repeated hadronization of the same PYTHIA process- and parton-level event. This may for some studies help to save time, given that these two first step are more time-consuming than the hadronization one. For repeated hadronization you should first generate an event as usual, but with HadronLevel:all = off. This event you can save in a temporary copy, e.g. Event savedEvent = pythia.event. Inside a loop you copy back with pythia.event = savedEvent , and call pythia.forceHadronLevel() to obtain a new hadronization history. A more limited form of repetition is if you want to decay a given kind of particle repeatedly, without having to generate the rest of the event anew. This could be the case e.g. in B physics applications. Then you can use the pythia.moreDecays() method, which decays all particles in the event record that have not been decayed but should have been done so. The pythia.particleData.mayDecay( id, false/true) method may be used to switch off/on the decays of a particle species id , so that it is not decayed in the pythia.next() call but only inside a loop over a number of tries. Between each loop the newly produced decay products must be removed and the decayed particle status restored to undecayed. The former is simple, since the new products are appended to the end of the event record: event.saveSize() saves the initial size of the event record, and event.restoreSize() can later be used repeatedly to restore this original size, which means that the new particles at the end are thrown away. The latter is more complicated, and requires the user to identify the positions of all particles of the species and restore a positive status code with event[i].statusPos(). The main15.cc program illustrates both these methods, i.e. either repeated hadronization or repeated decay of PYTHIA events."},{"name":"Sphericity::Sphericity(double power = 2., int select = 2)","link":"EventAnalysis.html#anchor1","text":"create a sphericity analysis object, where is the power r defined above, i.e. gives Sphericity, and gives the linear form. tells which particles are analyzed, all final-state particles, all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the isVisible() particle method), and only charged final-state particles."},{"name":"int LHAup::mother2(int i)","link":"LesHouchesAccord.html#anchor42","text":""},{"name":"Vec4 Sphericity::eventAxis(i)","link":"EventAnalysis.html#anchor6","text":"gives the matching normalized eigenvector, as a Vec4 with vanishing time/energy component."},{"name":"HiggsA3:coup2Hchg","link":"HiggsProcesses.html#anchor106","text":"The A^0(H_3^0) coupling to H^+-. Vanishes in the MSSM."},{"name":"Tune:ee","link":"Tunes.html#anchor1","text":"Choice of tune to e^+e^- data, mainly for the hadronization and timelike-showering aspects of PYTHIA. You should study the Settings::initTuneEE(...) method to find exactly which are the settings for the respective tune. reset all values that are affected by any of the e^+e^- tunes to the default values. This option can be used on its own, but is also automatically used as a first step for either of the positive tune values below, to undo the effect of previous tune settings. no values are overwritten during the initial setup, step 2 above. Note that changing to 0 in the user code has no effect; if you want to restore the individual settings you should instead use -1. the original PYTHIA 8 parameter set, based on some very old flavour studies (with JETSET around 1990) and a simple tune of alpha_strong to three-jet shapes to the new pT -ordered shower. These were the default values before version 8.125. a tune by Marc Montull to the LEP 1 particle composition, as published in the RPP (August 2007). No related (re)tune to event shapes has been performed, however. a tune to a wide selection of LEP1 data by Hendrik Hoeth within the Rivet + Professor framework, both to hadronization and timelike-shower parameters (June 2009). These were the default values starting from version 8.125. a tune to LEP data by Peter Skands, by hand, both to hadronization and timelike-shower parameters (September 2013). Note the use of the CMW convention for the shower alpha_s scale. first tune to LEP data by Nadine Fischer (September 2013), based on the default flavour-composition parameters. Input is event shapes (ALEPH and DELPHI), identified particle spectra (ALEPH), multiplicities (PDG), and B hadron fragmentation functions (ALEPH). second tune to LEP data by Nadine Fischer (September 2013). Similar to the first one, but event shapes are weighted up significantly, and multiplicites not included. the Monash 2013 tune by Peter Skands at al. Ska14 , to both e^+e^- and pp/pbarp data."},{"name":"int DecayChannel::product(int i)","link":"ParticleDataScheme.html#anchor180","text":"set or get a list of the decay products, 8 products 0 <= i < 8, with trailing unused ones set to 0."},{"name":"friend Hist operator/(const HistAMPERSANDamp; h1, const Hist h2)","link":"Histograms.html#anchor42","text":"divide a constant by a histogram, a histogram by a constant, or two histograms by each other, bin by bin."},{"name":"bool SlowJet::setup( const EventAMPERSAND event)","link":"EventAnalysis.html#anchor57","text":"selects the particles to be analyzed, calculates initial distances, and finds the initial smallest distance. is an object of the Event class, most likely the pythia.event one. If the routine returns false the setup failed, but currently this is not foreseen ever to happen."},{"name":"int Info::nFinalSub()","link":"EventInformation.html#anchor29","text":"the name, code and number of final-state partons in the subprocess that occurred when hasSub() is true. For a minimum-bias event the code would always be 101, while codeSub() would vary depending on the actual hardest interaction, e.g. 111 for g g &rarr; g g. For a Les Houches event the code would always be 9999, while codeSub() would be the external user-defined classification code. The methods below would also provide information for such particular subcollisions."},{"name":"bool Pythia8ToHepMC::store_xsec()","link":"HepMCInterface.html#anchor16","text":"for each event store information on the Pythia cross section and its error, in pb, and the event weight. If events also come with a dimensional weight, like in some Les Houches strategies, this weight is in units of pb."},{"name":"BeamRemnants:allowBeamJunction","link":"BeamRemnants.html#anchor21","text":"This parameter is only relevant if the new Beam remnant model is used. This parameter tells whether to allow the formation of junction structures in the colour configuration of the scattered partons."},{"name":"Wprime:vq","link":"NewGaugeBosonProcesses.html#anchor40","text":"vector coupling of quarks."},{"name":"Onia:all(3S1)","link":"OniaProcesses.html#anchor4","text":"Common switch for the group of 3S1 onia production, e.g. J/psi and Upsilon."},{"name":"HiggsSM:gg2Hbbbar","link":"HiggsProcesses.html#anchor17","text":"Scattering g g &rarr; H^0 b bbar. This process is yet one order higher of the b bbar &rarr; H^0 and b g &rarr; H^0 b chain, where now two quarks should be required above some large pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 912."},{"name":"double Sphericity::aplanarity()","link":"EventAnalysis.html#anchor4","text":"gives the aplanarity (with the same comment),"},{"name":"CoupSM::CoupSM()","link":"StandardModelParameters.html#anchor16","text":"the constructor does nothing. Internal."},{"name":"JetMatching:coneRadius","link":"JetMatching.html#anchor11","text":"For the CellJet algorithm, this gives the size of the cone in (eta, phi) space drawn around the geometric center of the jet. For the SlowJet algorithm, this gives the R parameter."},{"name":"ExtraDimensionsUnpart:gg2gammagamma","link":"ExtraDimensionalProcesses.html#anchor77","text":"Scatterings g g &rarr; (U*) &rarr; gamma gamma. Code 5044."},{"name":"void Info::list()","link":"EventInformation.html#anchor1","text":"a listing of most of the information set for the current event."},{"name":"StringFlav:popcornRate","link":"FlavourSelection.html#anchor35","text":"gives the relative rates of B Bbar and B M Bbar production, roughly as Prob(B M Bbar) / (Prob(B Bbar) + Prob(B M Bbar)) = popcornRate / (0.5 + popcornRate) (the complete expression depends on all the quark and diquark production parameters and is therefore not so useful)."},{"name":"void Settings::list(string match)","link":"SettingsScheme.html#anchor12","text":"list all or changed settings, or a group of them. list all those settings where the name contains the match (sub)string (case-insensitive)."},{"name":"double Info::weightSum()","link":"EventInformation.html#anchor74","text":"Sum of weights accumulated during the run. For unweighted events this agrees with the number of generated events. In order to obtain histograms normalized 'per event', at the end of a run, histogram contents should be divided by this weight. (And additionally divided by the bin width.) Normalization to cross section also required multiplication by sigmaGen() below."},{"name":"void ParticleData::m0(int id, double m0)","link":"ParticleDataScheme.html#anchor39","text":""},{"name":"HiggsH2:coup2HchgW","link":"HiggsProcesses.html#anchor97","text":"The H^0(H_2^0) coupling to a H^+- W-+ pair. Is sin(beta - alpha) in the MSSM."},{"name":"TimeShower:pTmaxMatch","link":"TimelikeShowers.html#anchor1","text":"Way in which the maximum shower evolution scale is set to match the scale of the hard process itself. (i) if the final state of the hard process (not counting subsequent resonance decays) contains at least one quark ( u, d, s, c ,b ), gluon or photon then pT_max is chosen to be the factorization scale for internal processes and the scale value for Les Houches input; (ii) if not, emissions are allowed to go all the way up to the kinematical limit (i.e. to half the dipole mass). This option agrees with the corresponding one for spacelike showers. There the reasoning is that in the former set of processes the ISR emission of yet another quark, gluon or photon could lead to double-counting, while no such danger exists in the latter case. The argument is less compelling for timelike showers, but could be a reasonable starting point. always use the factorization scale for an internal process and the scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some emissions that ought to have been simulated. (Also known as wimpy showers.) always allow emissions up to the kinematical limit (i.e. to half the dipole mass). This will simulate all possible event topologies, but may lead to double-counting. (Also known as power showers.) Note 1: as enumerated in the text, these options take effect both for internal and external processes. Whether a particular option makes sense depends on the context. For instance, if events for the same basic process to different orders are to be matched, then option 1 would be a reasonable first guess. But in more sophisticated descriptions option 2 could be combined with UserHooks vetoes on emissions that would lead to double-counting, using more flexible phase space boundaries. Further details are found in the Matching and Merging description, with an example in examples/main31. Option 0, finally, may be most realistic when only Born-level processes are involved, possibly in combination with a nonzero TimeShower:pTdampMatch. Note 2: These options only apply to the hard interaction. If a 'second hard' process is present, the two are analyzed and set separately for the default 0 option, while both are affected the same way for non-default options 1 and 2. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of each process itself. The options also assume that you use interleaved evolution, so that FSR is in direct competition with ISR for the hardest emission. If you already generated a number of ISR partons at low pT , it would not make sense to have a later FSR shower up to the kinematical limit for all of them. Note 3: Recall that resonance decays are not affected by this mode, but that showers there are always set to fill the full phase space, often with built-in matrix-element-matching that give a NLO accuracy. A modification of this behaviour would require you to work with UserHooks. However, for Les Houches input the optional Beams:strictLHEFscale = on setting restricts all emissions, also in resonance decays, to be below the input scale value."},{"name":"double Info::enhanceMPIoldavg()","link":"EventInformation.html#anchor97","text":"These methods are only relevant for hard diffraction with the requirement of no MPI in the hadron-hadron collision. Then an impact parameter and associated enhancement factor is picked for this collision, but afterwards overwritten when the Pomeron-hadron subcollision is considered. In such cases the old hadron-hadron values can be found here, while bMPI , enhanceMPI and enhanceMPIavg provide the new Pomeron-hadron ones."},{"name":"bool Settings::isParm(string key)","link":"SettingsScheme.html#anchor19","text":""},{"name":"Dark Matter Processes","link":"DarkMatterProcesses.html","text":"Dark Matter Processes This page contains the production of Dark Matter via new s -channel mediators.  Currently only vector-like mediator i.e. Z'^0 for Dirac DM is implemented. Note that the mediator in this case carries the PDG id 55. Z'^0 This group currently contains only one subprocess. The couplings of the Z'^0 to quarks and leptons are be assumed universal, i.e. generation-independent. Currently only vector couplings are implemented.  The choice of fixed axial and vector couplings implies a resonance width that increases linearly with the Z'^0 mass. Note that cross sections strongly depend on the choice of mediator and Dark Matter masses. Here are the couplings"},{"name":"void Particle::offsetCol( int addCol)","link":"ParticleProperties.html#anchor115","text":"add a positive offset to colour indices, i.e. if col is positive then addCol is added to it, same with acol."},{"name":"virtual double SpaceShower::pTnext( EventAMPERSAND event,  double pTbegAll, double pTendAll, int nRadIn = -1)","link":"ImplementNewShowers.html#anchor35","text":"This is the main driver routine for the downwards evolution. A new pT is to be selected based on the current information set up by the routines above, and along with that a branching parton or dipole. The pTbegAll scale is the maximum scale allowed, from which the downwards evolution should be begun (usually respecting the maximum scale of each individual parton). If no emission is found above pTendAll (and above the respective shower cutoff scales) then 0. should be returned and no emissions will be allowed. Both scales can vary from one event to the next: if a scale has already been selected for MPI or ISR it makes no sense to look for a scale smaller than that from FSR, since it would not be able to compete, so pTendAll is set correspondingly. As it happens, FSR is tried before ISR and MPI in the interleaved evolution, but this is an implementation detail that could well change. Typically the implementation of this routine would be to set up a loop over all possible radiating objects (dipoles, dipole ends, ...), for each pick its possible branching scale and then pick the one with largest scale as possible winner. At this stage no branching should actually be carried out, since MPI, ISR and FSR still have to be compared to assign the winner. The input nRadIn provides the total number of ISR and FSR emissions already generated in the event, and so allows a special treatment for the very first emission, if desired."},{"name":"HardQCD:qqbar2qqbargSame","link":"QCDProcesses.html#anchor29","text":"Scatterings q qbar &rarr; q qbar g. Code 137."},{"name":"virtual int TimeShower::shower( int iBeg, int iEnd,  EventAMPERSAND event, double pTmax, int nBranchMax = 0)","link":"ImplementNewShowers.html#anchor7","text":"This is an all-in-one call for shower evolution, and as such cannot be used for the normal interleaved evolution, where only the routines below are used. It also cannot be used in resonance decays that form part of the hard process, since there the user hooks insert a potential veto step. Currently this routine is therefore only used in the hadron-level decays, e.g. Upsilon &rarr; g g g. iBeg and iEnd is the position of the first and last parton of a separate system, typically produced by a resonance decay. Such a system only evolves in isolation, and in particular does not relate to the beams. The pTmax value sets the maximum scale for evolution, but normally you would restrict that further for each individual parton based on its respective scale value. The nBranchMax value, if positive, gives the maximum number of allowed branchings in the call, as useful for matching studies. The routine is expected to return the number of FSR branchings that were generated, but only for non-critical statistics purposes. Since the real action typically is delegated to the routines below, it may well be that the existing code need not be replaced."},{"name":"Rndm Pythia::rndm","link":"ProgramFlow.html#anchor41","text":"the random number generator, see here and here for further details."},{"name":"void Particle::statusCode(int code)","link":"ParticleProperties.html#anchor25","text":"changes the absolute value but retains the original sign."},{"name":"bool ParticleDataEntry::isGluon()","link":"ParticleDataScheme.html#anchor142","text":"true for a gluon."},{"name":"Top:ffbar2tqbar(s:W)","link":"TopProcesses.html#anchor6","text":"Scatterings f fbar' &rarr; t q'' by s -channel exchange of a W^+- boson. Code 605."},{"name":"double DecayChannel::bRatio()","link":"ParticleDataScheme.html#anchor173","text":"set or get the branching ratio of the channel. Second argument only for internal use."},{"name":"Merging:doUserMerging","link":"CKKWLMerging.html#anchor14","text":"General user defined merging on/off."},{"name":"double Info::thetaScatLepA()","link":"EventInformation.html#anchor70","text":""},{"name":"double Particle::pT()","link":"ParticleProperties.html#anchor41","text":""},{"name":"FourthBottom:gg2bPrimebPrimebar","link":"FourthGenerationProcesses.html#anchor2","text":"Scatterings g g &rarr; b' b'bar. Code 801."},{"name":"PDF:piSet","link":"PDFSelection.html#anchor7","text":"Parton densities that can be used for pion beams, currently with only one internal choice. GRV 92 L. Use an external LHAPDF set where set is the name of the set to use and member is the member of the set to use. The value for set can either be a relative path to the LHAPDF path, or an absolute path. The value for member must be an integer. Same as for LHAPDF5:set/member but now the LHAPDF6 library is used instead. Use the internal implementation of interpolation in .dat files in the default 'lhagrid1' LHAPDF6 format, cf. the corresponding proton option."},{"name":"HadronLevel:BoseEinstein","link":"MasterSwitches.html#anchor15","text":"Master switch for the simulation of Bose-Einstein effects; on/off = true/false. Further options are found here."},{"name":"StringFlav:etaSup","link":"FlavourSelection.html#anchor12","text":"the additional suppression of eta production, multiplying the normal production probability. Thus 0 means no eta at all are produced, while 1 means full rate."},{"name":"double Particle::zProd()","link":"ParticleProperties.html#anchor19","text":""},{"name":"Bottomonium:gg2bbbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor55","text":"Colour-octet production of 3S1 bottomonium states via g g &rarr; bbbar[1S0(8)] g. Code 505."},{"name":"HiggsHchg:coup2H1W","link":"HiggsProcesses.html#anchor109","text":"The H^+- coupling to a h^0(H_1^0) W^+- pair. Is cos(beta - alpha) in the MSSM."},{"name":"int SlowJet::jNext()","link":"EventAnalysis.html#anchor64","text":""},{"name":"void SigmaProcess::initProc()","link":"SemiInternalProcesses.html#anchor5","text":"is called once during initialization, and can then be used to set up parameters, such as masses and couplings, and perform calculations that need not be repeated for each new event, thereby saving time. This method needs not be implemented, since in principle all calculations can be done in sigmaHat below."},{"name":"ExcitedFermion:sg2sStar","link":"CompositenessProcesses.html#anchor4","text":"Scatterings s g &rarr; s^*. Code 4003."},{"name":"HadronScatter:neighbourNear","link":"HadronScattering.html#anchor11","text":"If scattering of hadrons within the same string is allowed this  parameter gives the closest neighbour that is allowed. The value 1  corresponds to the direct neighbour. The probability associated  with this potential scattering partner is minProbSS."},{"name":"Higgs Processes","link":"HiggsProcesses.html","text":"Higgs Processes This page documents Higgs production within and beyond the Standard Model (SM and BSM for short). This includes several different processes and, for the BSM scenarios, a large set of parameters that would only be fixed within a more specific framework such as MSSM. Some choices can be made irrespective of the particular model: One setting is specific to the Standard Model: Standard-Model Higgs, basic processes This section provides the standard set of processes that can be run together to provide a reasonably complete overview of possible production channels for a single SM Higgs. The main parameter is the choice of Higgs mass, which can be set in the normal ParticleData database; thereafter the properties within the SM are essentially fixed. Standard-Model Higgs, further processes A number of further production processes has been implemented, that are specializations of some of the above ones to the high- pT region. The sets therefore could not be used simultaneously without unphysical double-counting, as further explained below. They are not switched on by the HiggsSM:all flag, but have to be switched on for each separate process after due consideration. The first three processes in this section are related to the Higgs point coupling to fermions, and so primarily are of interest for b quarks. It is here useful to begin by reminding that a process like b bbar &rarr; H^0 implies that a b/bbar is taken from each incoming hadron, leaving behind its respective antiparticle. The initial-state showers will then add one g &rarr; b bbar branching on either side, so that effectively the process becomes g g &rarr; H0 b bbar. This would be the same basic process as the g g &rarr; H^0 t tbar one used for top. The difference is that (a) no PDF's are defined for top and (b) the shower approach would not be good enough to provide sensible kinematics for the H^0 t tbar subsystem. By contrast, owing to the b being much lighter than the Higgs, multiple gluon emissions must be resummed for b , as is done by PDF's and showers, in order to obtain a sensible description of the total production rate,  when the b quarks predominantly are produced at small pT values. The second set of processes are predominantly first-order corrections to the g g &rarr; H^0 process, again dominated by the top loop. We here only provide the kinematical expressions obtained in the limit that the top quark goes to infinity, but scaled to the finite-top-mass coupling in g g &rarr; H^0. (Complete loop expressions are available e.g. in PYTHIA 6.4 but are very lengthy.) This provides a reasonably accurate description for 'intermediate' pT values, but fails when the pT scale approaches the top mass. Beyond-the-Standard-Model Higgs, introduction Further Higgs multiplets arise in a number of scenarios. We here concentrate on the MSSM scenario with two Higgs doublets, but with flexibility enough that also other two-Higgs-doublet scenarios could be represented by a suitable choice of parameters. Conventionally the Higgs states are labeled h^0, H^0, A^0 and H^+-. If the scalar and pseudocalar states mix the resulting states are labeled H_1^0, H_2^0, H_3^0. In process names and parameter explanations both notations will be used, but for settings labels we have adapted the shorthand hybrid notation H1 for h^0(H_1^0) , H2 for H^0(H_2^0) and A3 for A^0(H_3^0). (Recall that the Settings database does not distinguish upper- and lowercase characters, so that the user has one thing less to worry about, but here it causes problems with h^0 vs. H^0 .) We leave the issue of mass ordering between H^0 and A^0 open, and thereby also that of H_2^0 and H_3^0. Beyond-the-Standard-Model Higgs, basic processes This section provides the standard set of processes that can be run together to provide a reasonably complete overview of possible production channels for a single neutral Higgs state in a two-doublet scenarios such as MSSM. The list of processes for neutral states closely mimics the one found for the SM Higgs. Some of the processes vanish for a pure pseudoscalar A^0 , but are kept for flexibility in cases of mixing with the scalar h^0 and H^0 states, or for use in the context of non-MSSM models. This should work well to represent e.g. that a small admixture of the 'wrong' parity would allow a process such as q qbar &rarr; A^0 Z^0 , which otherwise is forbidden. However, note that the loop integrals e.g. for g g &rarr; h^0/H^0/A^0 are hardcoded to be for scalars for the former two particles and for a pseudoscalar for the latter one, so absolute rates would not be correctly represented in the case of large scalar/pseudoscalar mixing. 1) h^0(H_1^0) processes 2) H^0(H_2^0) processes 3) A^0(H_3^0) processes 4) H+- processes 5) Higgs-pair processes Beyond-the-Standard-Model Higgs, further processes This section mimics the above section on 'Standard-Model Higgs, further processes', i.e. it contains higher-order corrections to the processes already listed. The two sets therefore could not be used simultaneously without unphysical double-counting. They are not controlled by any group flag, but have to be switched on for each separate process after due consideration. We refer to the standard-model description for a set of further comments on the processes. 1) h^0(H_1^0) processes 2) H^0(H_2^0) processes 3) A^0(H_3^0) processes Parameters for Beyond-the-Standard-Model Higgs production and decay This section offers a big flexibility to set couplings of the various Higgs states to fermions and gauge bosons, and also to each other. The intention is that, for scenarios like MSSM, you should use standard input from the SUSY Les Houches Accord , rather than having to set it all yourself. In other cases, however, the freedom is there for you to use. Kindly note that some of the internal calculations of partial widths from the parameters provided do not include mixing between the scalar and pseudoscalar states. Masses would be set in the ParticleData database, while couplings are set below. When possible, the couplings of the Higgs states are normalized to the corresponding coupling within the SM. When not, their values within the MSSM are indicated, from which it should be straightforward to understand what to use instead. The exception is some couplings that vanish also in the MSSM, where the normalization has been defined in close analogy with nonvanishing ones. Some parameter names are asymmetric but crossing can always be used, i.e. the coupling for A^0 &rarr; H^0 Z^0 obviously is also valid for H^0 &rarr; A^0 Z^0 and Z^0 &rarr; H^0 A^0. Note that couplings usually appear quadratically in matrix elements. Another set of parameters are not used in the production stage but exclusively for the description of angular distributions in decays."},{"name":"void LHAup::listInit()","link":"LesHouchesAccord.html#anchor29","text":"prints the above initialization information. This method is automatically called from Pythia::init() , so would normally not need to be called directly by the user."},{"name":"double Particle::xDec()","link":"ParticleProperties.html#anchor56","text":""},{"name":"SpaceShower:strengthIntAsym","link":"SpacelikeShowers.html#anchor32","text":"Size of asymmetry induced by interference. Natural value of order 0.5; expression would blow up for a value of 1."},{"name":"Event Pythia::process","link":"ProgramFlow.html#anchor36","text":"the hard-process event record, see here for further details."},{"name":"double Info::tHat()","link":"EventInformation.html#anchor53","text":""},{"name":"int Info::idB()","link":"EventInformation.html#anchor3","text":"the identities of the two beam particles."},{"name":"ExtraDimensionsTEV:ffbar2ddbar","link":"ExtraDimensionalProcesses.html#anchor27","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; d dbar , Code 5061."},{"name":"bool ParticleDataEntry::preparePick(int idSgn,  double mHat = 0., int idInFlav = 0)","link":"ParticleDataScheme.html#anchor157","text":"prepare to pick a decay channel."},{"name":"PartonLevel:all","link":"MasterSwitches.html#anchor3","text":"If off then stop the generation after the hard process has been generated, but before the parton-level and hadron-level steps. The process record is filled, but the event one is then not."},{"name":"virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const EventAMPERSAND event)","link":"UserHooks.html#anchor28","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the MPI, true, or not, false. If you veto, then the latest MPI is removed from the event record. In either case the interleaved evolution will continue from the point where it was left off. is the size of the event record before the latest MPI was added to it. It will also become the new size if the MPI is vetoed. the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent MPI, which are stored in entries from sizeOld through event.size() - 1 inclusive. If you veto the MPI these entries will be removed."},{"name":"double ParticleDataEntry::resWidthRescaleFactor()","link":"ParticleDataScheme.html#anchor166","text":"the factor used to rescale all partial widths in case the total width is being forced to a specific value by the user."},{"name":"PhaseSpace:pTHatMax","link":"PhaseSpaceCuts.html#anchor4","text":"The maximum invariant pT. A value below pTHatMin means there is no upper limit."},{"name":"Main:LHEFskipInit","link":"MainProgramSettings.html#anchor26","text":"If you read several Les Houches Event Files that you want to see considered as one single combined event sample you can set this flag on after the first subrun to skip (most of) the (re-)initialization step."},{"name":"TimeShower:mMaxGamma","link":"TimelikeShowers.html#anchor15","text":"Maximum invariant mass allowed for the created fermion pair in a gamma &rarr; f fbar branching in the shower."},{"name":"void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0)","link":"LesHouchesAccord.html#anchor6","text":"sets the properties of the first and second incoming beam, respectively (cf. the Fortran IDBMUP(1), EBMUP(i), PDFGUP(i), PDFSUP(i) , with i 1 or 2). These numbers can be used to tell which PDF sets were used when the hard process was generated, while the normal PDF Selection is used for the further event generation in PYTHIA."},{"name":"BeamRemnants:beamJunction","link":"BeamRemnants.html#anchor20","text":"This parameter is only relevant if the new colour reconnection scheme is used. (see colour reconnection ) This parameter tells whether to form a junction or a di-quark if more than two valence quarks are found in the beam remnants. If off a di-quark is formed and if on a junction will be formed."},{"name":"Check:history","link":"ErrorChecks.html#anchor5","text":"When Check:event = on and the event is checked as above, further checks are made that all mother and daughter pointers are consistently set. Specifically that all daughters in the daughterlist (or motherList ) have the particle in their respective motherList (or daughterlist ). This operation takes a bit more time than the other error tests (of the order of 10% of what it takes to generate the event in the first place), and so could be switched off to save time."},{"name":"virtual void MyHardProcess::translateProcessString( string  process)","link":"MatchingAndMerging.html#anchor26","text":"This function will use the string argument to set up the hard process bookkeeping, e.g. how many incoming/outgoing particles of which flavour are contained in the core (lowest multiplicity) scattering process."},{"name":"void ParticleData::chargeType(int id, int chargeType)","link":"ParticleDataScheme.html#anchor34","text":""},{"name":"StringFlav:mesonBL1S0J1","link":"FlavourSelection.html#anchor26","text":"the relative pseudovector production ratio (L=1,S=0,J=1) /pseudoscalar for bottom mesons."},{"name":"double ResonanceWidths::widthChan( double mHat,  int idAbs1, int idAbs2)","link":"SemiInternalResonances.html#anchor4","text":"is not normally used. In PYTHIA the only exception is Higgs decays, where it is used to define the width (except for colour factors) associated with a specific incoming/outgoing state. It allows the results of some loop expressions to be pretabulated."},{"name":"ExtraDimensionsG*:Ggmgm","link":"ExtraDimensionalProcesses.html#anchor16","text":"Coupling between graviton and gamma."},{"name":"Next:numberShowEvent","link":"MainProgramSettings.html#anchor13","text":"The number of events to list the event record for, where relevant."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Particle::sisterList(bool traceTopBot  = false)","link":"ParticleProperties.html#anchor98","text":"returns a vector of all the sister indices of the particle, i.e. all the daughters of the first mother, except the particle itself. If the argument traceTopBot = true the particle is first traced up with iTopCopy() before its mother is found, and then all the particles in the daughterList() of this mother are traced down with iBotCopy() , omitting the original particle itself. The method is not meaningful for the 0 entry, with status code -11, and there returns an empty list."},{"name":"double Rndm::exp()","link":"RandomNumbers.html#anchor6","text":"generate random numbers according to exp(-x)."},{"name":"StandardModel:Vcs","link":"StandardModelParameters.html#anchor11","text":"The V_cs CKM matrix element."},{"name":"PDF:PomQuarkFrac","link":"PDFSelection.html#anchor14","text":"the fraction of the Pomeron momentum carried by quarks for option 1 above, with the rest carried by gluons."},{"name":"HiggsBSM:gg2A3bbbar","link":"HiggsProcesses.html#anchor76","text":"Scattering g g &rarr; A^0 b bbar. This process is yet one order higher of the b bbar &rarr; A^0 and b g &rarr; A^0 b chain, where now two quarks should be required above some large pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1052."},{"name":"TimeShower:octetOniumFraction","link":"TimelikeShowers.html#anchor26","text":"Allow colour-octet charmonium and bottomonium states to radiate gluons. 0 means that no octet-onium states radiate, 1 that all do, with possibility to interpolate between these two extremes."},{"name":"WeakBosonAndParton:qqbar2Wg","link":"ElectroweakProcesses.html#anchor27","text":"Scattering q qbar &rarr; W^+- g. Code 251."},{"name":"virtual double RndmEngine::flat()","link":"RandomNumbers.html#anchor13","text":"if you want to construct an external random number generator (or generator interface) then you must implement this method in your class derived from the RndmEningen base class, to give a random number between 0 and 1."},{"name":"BeamRemnants:companionPower","link":"BeamRemnants.html#anchor12","text":"When a sea quark has been found, a companion antisea quark ought to be nearby in x. The shape of this distribution can be derived from the gluon mother distribution convoluted with the g &rarr; q qbar splitting kernel. In practice, simple solutions are only feasible if the gluon shape is assumed to be of the form g(x) ~ (1 - x)^p / x , where p is an integer power, the parameter above. Allowed values correspond to the cases programmed. Since the whole framework is approximate anyway, this should be good enough. Note that companions typically are found at small Q^2 , if at all, so the form is supposed to represent g(x) at small Q^2 scales, close to the lower cutoff for multiparton interactions."},{"name":"HadronScatter:pMax","link":"HadronScattering.html#anchor3","text":""},{"name":"ExcitedFermion:qq2sStarq","link":"CompositenessProcesses.html#anchor12","text":"Scatterings q q(bar) &rarr; s^* q(bar). Code 4023."},{"name":"double Vec4::m2Calc()","link":"FourVectors.html#anchor18","text":"the (squared) mass, calculated from the four-vectors. If m^2 < 0 the mass is given with a minus sign, -sqrt(-m^2).  Note the possible loss of precision in the calculation of E^2 - p^2 ; for particles the correct mass is stored separately to avoid such problems."},{"name":"Beams:newLHEFsameInit","link":"BeamParameters.html#anchor15","text":"Allow to begin reading events from a new LHEF or or a new LHAup instance without a completely new initialization. Only useful when Beams:frameType = 4 or 5."},{"name":"ParticleDecays:multIncrease","link":"ParticleDecays.html#anchor20","text":"The above multIncrease parameter, except for meMode = 23."},{"name":"ParticleDecays:multGoffset","link":"ParticleDecays.html#anchor23","text":"The above multGoffset parameter."},{"name":"void ParticleDataEntry::initBWmass()","link":"ParticleDataScheme.html#anchor134","text":"Prepare the Breit-Wigner mass selection by precalculating frequently-used expressions."},{"name":"WeakDoubleBoson:all","link":"ElectroweakProcesses.html#anchor18","text":"Common switch for the group of pair production of gamma^*/Z^0 and W^+-."},{"name":"Semi-Internal Resonances","link":"SemiInternalResonances.html","text":"Semi-Internal Resonances The introduction of a new semi-internal process may also involve a new particle, not currently implemented in PYTHIA. Often it is then enough to use the standard machinery to introduce a new particle ( id:all = ... ) and new decay channels ( id:addChannel = ... ). By default this only allows you to define a fixed total width and fixed branching ratios. Using meMode values 100 or bigger provides the possibility of a very simple threshold behaviour. If you want to have complete freedom, however, there are two ways to go. One is that you make the resonance decay part of the hard process itself, either using the Les Houches interface or a semi-internal process. The other is for you to create a new ResonanceWidths object, where you write the code needed for a calculation of the partial width of a particular channel. Here we will explain what is involved in setting up a resonance. Should you actually go ahead with this, it is strongly recommended to use an existing resonance as a template, to get the correct structure. There also exists a sample main program, main22.cc , that illustrates how you could combine a new process and a new resonance. There are three steps involved in implementing a new resonance: 1) providing the standard particle information, as already outlined above ( id:all = ... , id:addChannel = ... ), except that now branching ratios need not be specified, since they anyway will be overwritten by the dynamically calculated values. 2) writing the class that calculates the partial widths. 3) handing in a pointer to an instance of this class to PYTHIA. We consider the latter two aspects in turn. The ResonanceWidths Class The resonance-width calculation has to be encoded in a new class. The relevant code could either be put before the main program in the same file, or be stored separately, e.g. in a matched pair of .h and .cc files. The latter may be more convenient, in particular if the calculations are lengthy, or likely to be used in many different runs, but of course requires that these additional files are correctly compiled and linked. The class has to be derived  from the ResonanceWidths base class. It can implement a number of methods. The constructor and the calcWidth ones are always needed, while others are for convenience. Much of the administrative machinery is handled by methods in the base class. Thus, in particular, you must implement expressions for all possible final states, whether switched on in the current run or not, since all contribute to the total width needed in the denominator of the Breit-Wigner expression. Then the methods in the base class take care of selecting only allowed channels where that is required, and also of including effects of closed channels in secondary decays. These methods can be accessed indirectly via the res... methods of the normal particle database. A constructor for the derived class obviously must be available. Here you are quite free to allow a list of arguments, to set the parameters of your model. The constructor must call the base-class initBasic(idResIn) method, where the argument idResIn is the PDG-style identity code you have chosen for the new resonance. When you create several related resonances as instances of the same class you would naturally make idResIn an argument of the constructor; for the PYTHIA classes this convention is used also in cases when it is not needed. The initBasic(...) method will hook up the ResonanceWidths object with the corresponding entry in the generic particle database, i.e. with the normal particle information you set up in point 1) above. It will store, in base-class member variables, a number of quantities that you later may find useful: idRes : the identity code you provide; hasAntiRes : whether there is an antiparticle; mRes : resonance mass; GammaRes resonance width; m2Res : the squared mass; GamMRat : the ratio of width to mass. A destructor is only needed if you plan to delete the resonance before the natural end of the run, and require some special behaviour at that point. If you call such a destructor you will leave a pointer dangling inside the Pythia object you gave it in to, if that still exists. Access to resonance widths Once you have implemented a class, it is straightforward to make use of it in a run. Assume you have written a new class MyResonance , which inherits from ResonanceWidths. You then create an instance of this class and hand it in to a pythia object with ResonanceWidths* myResonance = new MyResonance();     pythia.setResonancePtr( myResonance); If you have several resonances you can repeat the procedure any number of times. When pythia.init() is called these resonances are initialized along with all the internal resonances, and treated in exactly the same manner. See also the Program Flow description. If the code should be of good quality and general usefulness, it would be simple to include it as a permanently available process in the standard program distribution. The final step of that integration ought to be left for the PYTHIA authors, but basically all that is needed is to add one line in ParticleData::initResonances , where one creates an instance of the resonance in the same way as for the resonances already there. In addition, the particle data and decay table for the new resonance has to be added to the permanent particle database , and the code itself to include/ResonanceWidths.h and src/ResonanceWidths.cc."},{"name":"Merging:nQuarksMerge","link":"CKKWLMerging.html#anchor32","text":"This switch controls which quarks flavours (labelled by PDG id's) are considered additional partons. If e.g. set to 4, then u-, d-, c- and s-quarks will be merged, while b-quarks will not be considered in the merging (corresponding to a 4-flavour merging scheme). We advise caution when changing this number. In particular, please ensure that the allowed flavour for additional partons in the input LHE file does not exceed this value, since unnecessary double-counting might occur otherwise."},{"name":"LeptoQuark:kCoup","link":"LeptoquarkProcesses.html#anchor6","text":"multiplicative factor in the LQ &rarr; q l squared Yukawa coupling, and thereby in the LQ width and the q l &rarr; LQ and other cross sections. Specifically, lambda^2/(4 pi) = k alpha_em , i.e. it corresponds to the $k$ factor of Hew88."},{"name":"double CoupSM::Lambda5()","link":"StandardModelParameters.html#anchor23","text":"the three-, four-, and five-flavour Lambda scale."},{"name":"Merging:includeWeightInXsection","link":"CKKWLMerging.html#anchor56","text":"If on, then the reweighting of events in the CKKW-L scheme is included in the event weight Info::weight() , the merging weight Info:mergingWeight() is unity, and the cross section printed by Info::sigmaGen() includes the effect of CKKW-L merging."},{"name":"void Info::pT2NowISR(bool pT2NowIn)","link":"EventInformation.html#anchor112","text":""},{"name":"friend double REtaPhi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor45","text":"the R distance measure, in (y, phi) or (eta, phi) cylindrical coordinates, i.e. R^2 = (y_1 - y_2)^2 + (phi_1 - phi_2)^2 and equivalent."},{"name":"ExtraDimensionsG*:all","link":"ExtraDimensionalProcesses.html#anchor1","text":"Common switch for the group of lowest-order G^* production processes, i.e. the two ones below."},{"name":"bool Rndm::readState(string fileName)","link":"RandomNumbers.html#anchor12","text":"set the state of the random number generator by reading in a binary file saved by the above command. Comments as above."},{"name":"int Particle::iTopCopy()","link":"ParticleProperties.html#anchor91","text":""},{"name":"void Vec4::bst(double betaX, double betaY, double betaZ)","link":"FourVectors.html#anchor66","text":"boost the four-momentum by beta = (beta_x, beta_y, beta_z)."},{"name":"StringZ:useNonstandardC","link":"Fragmentation.html#anchor8","text":"use the above nonstandard Lund ansatz for c quarks."},{"name":"StringZ:useNonstandardB","link":"Fragmentation.html#anchor9","text":"use the above nonstandard Lund ansatz for b quarks."},{"name":"friend bool pShift( Vec4AMPERSAND p1Move, Vec4AMPERSAND p2Move,  double m1New, double m2New)","link":"FourVectors.html#anchor46","text":"transfer four-momentum between the two four-vectors so that they get the masses m1New and m2New , respectively. Note that p1Move and p2Move act both as input and output arguments. The method will return false if the invariant mass of the four-vectors is too small to accommodate the new masses, and then the four-vectors are not changed."},{"name":"StringZ:useNonstandardH","link":"Fragmentation.html#anchor10","text":"use the above nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"int Info::codeSub()","link":"EventInformation.html#anchor28","text":""},{"name":"bool Info::isDiffractiveB()","link":"EventInformation.html#anchor18","text":"is either beam soft diffractively excited?"},{"name":"int ParticleData::spinType(int id)","link":"ParticleDataScheme.html#anchor33","text":"the spin type, of the form 2 s + 1 , with special code 0 for entries of unknown or indeterminate spin."},{"name":"double SlowJet::y(int i)","link":"EventAnalysis.html#anchor47","text":""},{"name":"TimeShower:octetOniumColFac","link":"TimelikeShowers.html#anchor27","text":"The colour factor used used in the splitting kernel for those octet onium states that are allowed to radiate, normalized to the q &rarr; q g splitting kernel. Thus the default corresponds to twice the radiation off a quark. The physically preferred range would be between 1 and 9/4."},{"name":"DecayChannelAMPERSAND ParticleDataEntry::channel(int i)","link":"ParticleDataScheme.html#anchor154","text":""},{"name":"string SigmaProcess::name()","link":"SemiInternalProcesses.html#anchor12","text":"returns the name of the process, as you want it to be shown in listings."},{"name":"Bottomonium:states(3S1)","link":"OniaProcesses.html#anchor46","text":"The 3S1 bottomonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Vec4AMPERSAND Vec4::operator/=(double f)","link":"FourVectors.html#anchor52","text":"divide all four-vector components by a real number."},{"name":"StringFlav:probQQ1toQQ0join","link":"FlavourSelection.html#anchor5","text":"when two already produced quarks are to be combined to a diquark, e.g. in the junction framework, these numbers give the suppression of spin 1 diquark production relative to spin 0 one, apart from the factor of 3 enhancement of spin 1 from counting the number of states. The four components give the suppression when the heaviest quark is u/d , s , c or b , respectively. These parameters are seldom used and currently not constrained by any data, so very much a guesswork. Character-string input of this vector should be as a comma-separated list, without any blanks."},{"name":"HardQCD:qq2qq","link":"QCDProcesses.html#anchor12","text":"Scatterings q q' &rarr; q q' , q qbar' &rarr; q qbar' , qbar qbar' &rarr; qbar qbar' , where q' and q may agree, but the outgoing flavours equals the incoming ones Code 114."},{"name":"double Particle::eCalc()","link":"ParticleProperties.html#anchor40","text":"energy calculated from the mass and three-momentum; should agree with e() up to roundoff. For spacelike partons a positive-energy  solution is picked. This need not be the correct one, so it is recommended not to use the method in such cases."},{"name":"HadronScatter:scatterProb","link":"HadronScattering.html#anchor23","text":"Probability for a pair of hadrons to scatter. All hadrons scatter with probability j max(0, 1 - dR^2 / rMax^2). Angular distribution is picked flat in cos(theta). As option 0, above, but only pi-pi , pi-K and pi-p scatterings are considered. Only pi-pi , pi-K and pi-p scatterings are considered, with probability given by (1 - exp(-j sigEl)) max(0, 1 - dR^2 / rMax^2). The elastic cross sections and angular distributions are taken from the partial-wave distributions."},{"name":"ExtraDimensionsLED:qqbar2Gg","link":"ExtraDimensionalProcesses.html#anchor45","text":"Scatterings q qbar &rarr; G g. Code 5023."},{"name":"JetMatching:jetAllow","link":"JetMatching.html#anchor16","text":"Controls which particles are clustered by the jet algorithm. This option explicitly disallows top quarks, leptons and photons. All other particle types are passed to the jet algorithm. No extra particles are disallowed."},{"name":"HadronLevel:mStringMin","link":"Fragmentation.html#anchor38","text":"Decides whether a partonic system should be considered as a normal string or a ministring, the latter only producing one or two primary hadrons. The system mass should be above mStringMin plus the sum of quark/diquark constituent masses for a normal string description, else the ministring scenario is used."},{"name":"void Settings::addWord(string key,  string default)","link":"SettingsScheme.html#anchor28","text":""},{"name":"Diffraction:MBRsigma0","link":"Diffraction.html#anchor7","text":"the Pomeron-proton coupling, and the total Pomeron-proton cross section."},{"name":"Info Pythia::info","link":"ProgramFlow.html#anchor38","text":"further information on the event-generation process, see here for further details."},{"name":"void Particle::setEvtPtr(Event* evtPtr)","link":"ParticleProperties.html#anchor121","text":"sets the pointer to the Event object the particle belongs to. This method is automatically called when a particle is appended to an event record. Also calls setPDEPtr below."},{"name":"StringZ:aExtraDiquark","link":"Fragmentation.html#anchor4","text":"allows a larger a for diquarks, with total a = aLund + aExtraDiquark."},{"name":"HiggsBSM:ffbar2A3","link":"HiggsProcesses.html#anchor45","text":"Scattering f fbar &rarr; A^0(H_3^0) , where f sums over available flavours except top. Code 1041."},{"name":"Main:numberOfSelectedEvents","link":"MainProgramSettings.html#anchor22","text":"The number of events to be selected during generation. Any number smaller than one means that the setting will be ignored."},{"name":"SUSY:gg2gluinogluino","link":"SUSYProcesses.html#anchor7","text":"Pair production of gluinos by gluon-gluon initial states."},{"name":"SigmaProcess:factorFixScale","link":"CouplingsAndScales.html#anchor16","text":"A fix Q^2 value used as factorization scale for 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes in some of the options above."},{"name":"StringFlav:nQuark","link":"FlavourSelection.html#anchor43","text":"Selects the newly produced quark flavours that may be included in hadrons. The default corresponds to only include u/d/s quarks."},{"name":"double Info::eB()","link":"EventInformation.html#anchor7","text":"the energies of the two beam particles."},{"name":"Event::Event(int capacity = 100)","link":"EventRecord.html#anchor16","text":"creates an empty event record, but with a reserved size capacity for the Particle vector."},{"name":"double CoupSM::vf2(int idAbs)","link":"StandardModelParameters.html#anchor36","text":""},{"name":"Bottomonium:qqbar2bbbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor69","text":"Colour-octet production of 3PJ bottomonium states via q qbar &rarr; bbbar[3S1(8)] g. Code 516."},{"name":"friend double dot3(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor35","text":"the three-product."},{"name":"bool ParticleData::init(istreamAMPERSAND is","link":"ParticleDataScheme.html#anchor6","text":"copy particle data from a stream (rather than from a file)."},{"name":"bool ParticleData::readFF(string inFile,  bool reset = true)","link":"ParticleDataScheme.html#anchor11","text":""},{"name":"SigmaProcess:renormMultFac","link":"CouplingsAndScales.html#anchor9","text":"The Q^2 renormalization scale for 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes is multiplied by this factor relative to the scale described above (except for the options with a fix scale). Should be use sparingly for 2 &rarr; 1 processes."},{"name":"Beams:eA","link":"BeamParameters.html#anchor5","text":"The energy of the first incoming particle, moving in the +z direction, to be set if Beams:frameType = 2. If the particle energy is smaller than its mass it is assumed to be at rest."},{"name":"ParticleDecays:tauMax","link":"ParticleDecays.html#anchor4","text":"The above tauMax , expressed in mm/c. In order for this and the subsequent tests to work, a tau is selected and stored for each particle, whether in the end it decays or not. (If each test would use a different temporary tau it would lead to inconsistencies.)"},{"name":"Beams:eB","link":"BeamParameters.html#anchor6","text":"The energy of the second incoming particle, moving in the -z direction, to be set if Beams:frameType = 2. If the particle energy is smaller than its mass it is assumed to be at rest."},{"name":"ColourReconnection:kI","link":"ColourReconnection.html#anchor21","text":"kI is the main free parameter in the reconnection probability for SK I. This probability is given by kI times the space-time overlap volume, up to saturation effects."},{"name":"POWHEG:veto","link":"POWHEGMerging.html#anchor2","text":"Master switch to perform vetoing or not. No vetoing is performed (the user hooks is not loaded). Showers are started at the kinematical limit. Emissions are vetoed if pTemt > pThard. See also POWHEG:vetoCount below."},{"name":"virtual bool UserHooks::canVetoPartonLevel()","link":"UserHooks.html#anchor10","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoPartonLevel(...) will be called immediately after the parton level has been generated and stored in the event event record. Thus showers, multiparton interactions and beam remnants have been set up, but hadronization and decays have not yet been performed. This is already a fairly complete event, possibly with quite a complex parton-level history. Therefore it is usually only meaningful to study the hardest interaction, e.g. using subEvent(...) introduced above, or fairly generic properties, such as the parton-level jet structure."},{"name":"void ParticleData::initPtr(Info* infoPtr,  Settings* settingsPtrIn, Rndm* rndmPtrIn, CoupSM* coupSMPtrIn)","link":"ParticleDataScheme.html#anchor3","text":"initialize pointers to a few other classes. Internal."},{"name":"EventAMPERSAND Event::operator+=(const EventAMPERSAND addEvent)","link":"EventRecord.html#anchor18","text":"appends an event to an existing one. For the appended particles mother, daughter and colour tags are shifted to make a consistent record. The zeroth particle of the appended event is not copied, but the zeroth particle of the combined event is updated to the full energy-momentum content."},{"name":"void Event::bst(const Vec4AMPERSAND vec)","link":"EventRecord.html#anchor35","text":"boost all particles in the event by this three-vector. Optionally you may provide the gamma value as a fourth argument, which may help avoid roundoff errors for big boosts. You may alternatively supply a Vec4 four-vector, in which case the boost vector becomes beta = p/E."},{"name":"bool AlpgenPar::parse(const string paramStr)","link":"AlpgenEventInterface.html#anchor10","text":"This method parses an ALPGEN parameter file. The parameter file is passed as a single string, mainly intended to be read out from the PYTHIA Info object using the header information methods."},{"name":"HiggsSM:qqbar2Hg(l:t)","link":"HiggsProcesses.html#anchor21","text":"Scattering q qbar &rarr; H^0 g via an s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from g g &rarr; H^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 916."},{"name":"SigmaTotal:sigmaAXB","link":"TotalCrossSections.html#anchor9","text":"Central Diffractive cross section A + B &rarr; A + X + B in mb."},{"name":"WeakDoubleBoson:ffbar2ZW","link":"ElectroweakProcesses.html#anchor20","text":"Scattering f fbar' &rarr; Z^0 W^+-. Note that here the gamma^* contribution is not (currently) included. Code 232."},{"name":"MultipartonInteractions:nSample","link":"MultipartonInteractions.html#anchor24","text":"The allowed pT range is split (unevenly) into 100 bins, and in each of these the interaction cross section is evaluated in nSample random phase space points. The full integral is used at initialization, and the differential one during the run as a 'Sudakov form factor' for the choice of the hardest interaction. A larger number implies increased accuracy of the calculations."},{"name":"double Sphericity::sphericity()","link":"EventAnalysis.html#anchor3","text":"gives the sphericity (or equivalent if r is not 2),"},{"name":"ExcitedFermion:qqbar2muStarmuStar","link":"CompositenessProcesses.html#anchor23","text":"Scatterings q qbar &rarr; mu^*+- mu^*-+. Code 4053."},{"name":"FourthBottom:ffbar2bPrimebPrimebar(s:gmZ)","link":"FourthGenerationProcesses.html#anchor5","text":"Scatterings f fbar &rarr; b' b'bar by s -channel exchange of a gamma^*/Z^0 boson. Code 804."},{"name":"Merging:allowColourShuffling","link":"CKKWLMerging.html#anchor49","text":"If on, this will allow the algorithm to swap one colour index in the state, when trying to find all possible clusterings, if no clustering has been found, but more clusterings had been requested. In this way, some incomplete histories can be avoided. Generally, we advise the non-expert user to not touch this switch, because a slight change in the colour structure can change the radiation pattern. To however study the sensitivity of the predictions on these effects, allowing for colour reshuffling can be useful."},{"name":"PDF:PomGluonB","link":"PDFSelection.html#anchor11","text":"the parameter b in the ansatz xg(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"PDF:PomGluonA","link":"PDFSelection.html#anchor10","text":"the parameter a in the ansatz xg(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"Merging:nonJoinedNorm","link":"CKKWLMerging.html#anchor41","text":"Normalisation factor with which to multiply splitting probability for splittings without joined evolution equation."},{"name":"void Vec4::flip4()","link":"FourVectors.html#anchor62","text":"flip the sign of all four-vector components."},{"name":"double Vec4::eT()","link":"FourVectors.html#anchor23","text":""},{"name":"PhaseSpace:pTHatMinSecond","link":"PhaseSpaceCuts.html#anchor17","text":"The minimum invariant pT for a second interaction, if separate."},{"name":"BeamRemnants:primordialKT","link":"BeamRemnants.html#anchor1","text":"Allow or not selection of primordial kT according to the parameter values below."},{"name":"Beams:setProductionScalesFromLHEF","link":"BeamParameters.html#anchor19","text":"If enabled, production scales for all particles in an input Les Houches event will be set by using auxiliary information provided in the input event. Depending on which LHEF version is used, different information will be read. For LHEF 1.0, scale information can be transferred by including a line starting with the hashtag (#) character at the end of the event. The hashtag should be followed by the sequential scale values of the particles with status 1. For LHEF 3.0, the standardised <scales> tag is used instead. In this case, please ensure that production scale of the final state particle with position i in the input event will be transferred as the value of a scales tag attribute which contains i at the end of the attribute name, separated from the rest of the name by an underscore (_). An example <scales> tag would be <scales muf='100' pt_start_3='100' pt_start_4='50'> </scales>. This could be used to set the production scales of particles three and four to 100 GeV and 50 GeV, respectively, provided that these particles have status 1."},{"name":"LeftRightSymmmetry:coupHtaumu","link":"LeftRightSymmetryProcesses.html#anchor23","text":"Yukawa coupling for H^-- &rarr; tau- mu-."},{"name":"bool Settings::writeFile(ostreamAMPERSAND os = cout,  bool writeAll = false)","link":"SettingsScheme.html#anchor8","text":"write current settings to a file or to an ostream. file or stream on which settings are written. normally only settings that have been changed are written, but if true then all settings are output. Note: the method returns false if it fails."},{"name":"double m2(const ParticleAMPERSAND pp1, const ParticleAMPERSAND pp2)","link":"ParticleProperties.html#anchor62","text":"the (squared) invariant mass of two particles."},{"name":"HardQCD:3parton","link":"QCDProcesses.html#anchor22","text":"Common switch for the group of all hard QCD processes with three partons in the final state, as listed separately in the following."},{"name":"HiddenValley:qqbar2TvTvbar","link":"HiddenValleyProcesses.html#anchor19","text":"Pair production q qbar &rarr; Tv Tvbar via intermediate gluon. Code 4916."},{"name":"ExtraDimensionsUnpart:spinU","link":"ExtraDimensionalProcesses.html#anchor80","text":"Unparticle spin."},{"name":"void SlowJet::list(bool listAll = false)","link":"EventAnalysis.html#anchor62","text":"provides a listing of the above information. lists both jets and clusters if true , else only jets."},{"name":"bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vectorAMPERSANDlt;intAMPERSANDgt; handledParticles)","link":"ProgramFlow.html#anchor14","text":"offers the possibility to link to an external program that can do some of the particle decays, instead of using the internal decay machinery. With particles we here mean the normal hadrons and leptons, not top quarks, electroweak bosons or new particles in BSM scenarios. The rules for constructing your own class from the DecayHandler base class are described here. Note that you can only provide one external object, but this object in its turn could very well hand on different particles to separate decay libraries. pointer to a DecayHandler -derived object. This object must be instantiated by you in your program. vector with the PDG identity codes of the particles that should be handled by the external decay package. You should only give the particle (positive) codes; the respective antiparticle is always included as well. Note: The method currently always returns true."},{"name":"virtual bool UserHooks::canEnhanceEmission()","link":"UserHooks.html#anchor42","text":"In the base class this method returns false. If you redefine it to return true then the method enhanceFactor(...) will be used to rescale an initial-state splitting probability. Both enhanceFactor(...) and vetoProbability(...) will have to be derived to allow for a branching enhancement."},{"name":"int CoupSM::V2CKMpick(int id)","link":"StandardModelParameters.html#anchor45","text":"picks a random CKM partner quark or lepton (with the same sign as id ) according to the respective squared elements, again excluding the top quark and fourth generation from the list of possibilities. Unambiguous choice for the lepton-neutrino sector."},{"name":"void ParticleData::mMin(int id, double mMin)","link":"ParticleDataScheme.html#anchor43","text":""},{"name":"HiggsBSM:qqbar2H2g(l:t)","link":"HiggsProcesses.html#anchor74","text":"Scattering q qbar &rarr; H^0 g via an s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from g g &rarr; H^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1036."},{"name":"void Settings::resetPVec(string key)","link":"SettingsScheme.html#anchor75","text":""},{"name":"ParticleDecays:limitRadius","link":"ParticleDecays.html#anchor5","text":"When on, only particles with a decay within a radius r < rMax are decayed. There is assumed to be no magnetic field or other detector effects."},{"name":"Pythia::setMergingPtr( Merging* myMerging)","link":"MatchingAndMerging.html#anchor1","text":""},{"name":"ResonanceWidths:minThreshold","link":"ResonanceDecays.html#anchor2","text":"Used uniquely for meMode = 103 to set the minimal value assumed for the threshold factor, sqrt( (1 - m_1^2/m_2 - m_2^2/m^2)^2 - 4 m_1^2 m_2^2/m^4) for two-body decays and sqrt(1 - Sum_i m_i / m) for multibody ones. Thus the inverse of this number sets an upper limit for how much the partial width of a channel can increase from the on-shell value to the value for asymptotically large resonance masses. Is mainly intended as a safety measure, to avoid unintentionally large rescalings."},{"name":"int Info::id1()","link":"EventInformation.html#anchor30","text":""},{"name":"string Hist::getTitle()","link":"Histograms.html#anchor17","text":"return the title of the histogram."},{"name":"HiggsSM:ffbar2H","link":"HiggsProcesses.html#anchor7","text":"Scattering f fbar &rarr; H^0 , where f sums over available flavours except top. Related to the mass-dependent Higgs point coupling to fermions, so at hadron colliders the bottom contribution will dominate. Code 901."},{"name":"JetMatching:doVeto","link":"JetMatching.html#anchor25","text":"If turned off, then no jet matching veto will be applied internally in Pythia. Instead, it is assumed that the (expert) user enforces all necessary vetoes externally by some other means. Do not change the default value unless you are an expert in MLM jet matching and want to use your own code to perform the necessary vetoes."},{"name":"PhaseSpace:mHatMaxSecond","link":"PhaseSpaceCuts.html#anchor16","text":"The maximum invariant mass for a second interaction, if separate. A value below mHatMin means there is no upper limit."},{"name":"void DecayChannel::setHasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor181","text":""},{"name":"ExtraDimensionsUnpart:lambda","link":"ExtraDimensionalProcesses.html#anchor83","text":"Unparticle coupling to the SM fields."},{"name":"void Particle::daughters(int daughter1, int daughter2)","link":"ParticleProperties.html#anchor27","text":"sets both daughters in one go."},{"name":"PhaseSpace:minWidthBreitWigners","link":"PhaseSpaceCuts.html#anchor7","text":"The minimum width a resonance must have for the mass to be dynamically selected according to a Breit-Wigner shape, within the limits set below. Only applies when useBreitWigners is on; else the nominal mass value is always used."},{"name":"Merging:doKTMerging","link":"CKKWLMerging.html#anchor1","text":"If the additional jets in the LHE files have been regulated by a kT cut, the user can supply the merging scale definition by setting this flag to on. kT here and below means cutting on Durham kT for e+e- collisions, and cutting on longitudinally invariant kT for hadronic  collisions. Please note that this particular merging scale definition will check kT between all pairs of u,d,c,s,b,g partons."},{"name":"int Particle::daughter2()","link":"ParticleProperties.html#anchor6","text":"the indices in the event record where the first and last daughters are stored, if any. There are five allowed combinations of daughter1 and daughter2 : daughter1 = daughter2 = 0 : there are no daughters (so far); daughter1 = daughter2 > 0 : the particle has a 'carbon copy' as its sole daughter, but with changed momentum as a 'recoil' effect, e.g. in a shower; daughter1 > 0, daughter2 = 0 : each of the incoming beams has only (at most) one daughter, namely the initiator parton of the hardest interaction; further, in a 2 &rarr; 1 hard interaction, like q qbar &rarr; Z^0 , or in a clustering of two nearby partons, the initial partons only have this one daughter; daughter1 < daughter2 , both > 0: the particle has a range of decay products from daughter1 to daughter2 ; daughter2 < daughter1 , both > 0: the particle has two separately stored decay products (e.g. in backwards evolution of initial-state showers). Note 1: in backwards evolution of initial-state showers, the daughters may well appear below the mother in the event record. Note 2: the mother-daughter relation normally is reciprocal, but not always. An example is hadron beams (indices 1 and 2), where each beam remnant and the initiator of each multiparton interaction has the respective beam as mother, but the beam itself only has the initiator of the hardest interaction as daughter. Note 3: the daughterList() method below returns a vector of all the daughters, providing a uniform representation for all five cases. With this method, also all the daughters of the beams are caught, with the initiators of the basic process given first,  while the rest are in no guaranteed order (since they are found by a scanning of the event record for particles with the beam as mother, with no further information)."},{"name":"ParticleDecays:mixB","link":"ParticleDecays.html#anchor10","text":"Allow or not B^0 - B^0bar and B_s^0 - B_s^0bar mixing."},{"name":"double CoupSM::GF()","link":"StandardModelParameters.html#anchor28","text":"the Fermi constant of weak decays, in GeV ^-2."},{"name":"StringFlav:mesonUDL1S0J1","link":"FlavourSelection.html#anchor14","text":"the relative pseudovector production ratio (L=1,S=0,J=1) /pseudoscalar for light ( u , d ) mesons."},{"name":"Beams:strictLHEFscale","link":"BeamParameters.html#anchor18","text":"Always use the SCALUP value read from LHEF as production scale for particles, also including particles coming from resonance decays. By default, the production scale of resonance decay products (W-, Z-, H-bosons, top quarks) will be set to M/2 , where M is the mass of the resonance."},{"name":"long Info::nAccepted(int i = 0)","link":"EventInformation.html#anchor102","text":"the total number of tried phase-space points, selected hard processes and finally accepted events, summed over all allowed processes ( i = 0 ) or for the given process. The first number is only intended for a study of the phase-space selection efficiency. The last two numbers usually only disagree if the user introduces some veto during the event-generation process; then the former is the number of acceptable events found by PYTHIA and the latter the number that also were approved by the user. If you set a second hard process there may also be a mismatch."},{"name":"virtual double MergingHooks::dampenIfFailCuts(const EventAMPERSAND  event)","link":"CKKWLMerging.html#anchor25","text":"This routine will be supplied internally with the lowest multiplicity  reclustered state as an input Event. From this input event, the user can then check if matrix element cuts are fulfilled. The return value will be internally multiplied to the CKKW-L weight of the current event. Thus, if the user wishes  to suppress contributions not passing particular cuts, a number smaller than  unity can be returned."},{"name":"Rndm::Rndm()","link":"RandomNumbers.html#anchor1","text":"construct a random number generator, but does not initialize it."},{"name":"Merging:muFacInME","link":"NLOMerging.html#anchor4","text":"The fixed factorisation scale used in the matrix element calculation. This information is needed if factorisation scale variations in NLO merged results are attempted. Depending on the matrix element generator, it might not be possible to infer the factorisation scale from Les Houches event input, and thus, setting an explicit value is required. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the SCALUP variable of the current LH event will be used instead."},{"name":"virtual ~MyMergingHooks()","link":"MatchingAndMerging.html#anchor8","text":"A destructor for your MergingHooks class. If not defined, the base class's empty destructor will be used."},{"name":"int ParticleDataEntry::colType(int id = 1)","link":"ParticleDataScheme.html#anchor109","text":"set or get the particle colour type, 0 for singlet, 1 for triplet, -1 for antitriplet, 2 for octet. Only the sign of id is needed to distinguish particle/antiparticle."},{"name":"virtual bool DecayHandler::decay(vectorAMPERSANDlt;intAMPERSANDgt;AMPERSANDamp; idProd,  vectorAMPERSANDlt;doubleAMPERSANDgt;AMPERSANDamp; mProd, vectorAMPERSANDlt;Vec4AMPERSANDgt;AMPERSANDamp; pProd, int iDec,  const EventAMPERSANDamp; event)","link":"ExternalDecays.html#anchor1","text":"where is a list of particle PDG identity codes, is a list of their respective masses (in GeV), and is a list of their respective four-momenta."},{"name":"bool Pythia::readFile(string fileName,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor9","text":""},{"name":"ExcitedFermion:qqbar2tauStartauStar","link":"CompositenessProcesses.html#anchor25","text":"Scatterings q qbar &rarr; tau^*+- tau^*-+. Code 4055."},{"name":"double Info::mHat()","link":"EventInformation.html#anchor51","text":""},{"name":"Bottomonium:qqbar2bbbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor57","text":"Colour-octet production of 3S1 bottomonium states via q qbar &rarr; bbbar[1S0(8)] g. Code 507."},{"name":"double CellJet::m(int i)","link":"EventAnalysis.html#anchor39","text":"gives the invariant mass of the i 'th jet, defined by the pMassive above,"},{"name":"void ParticleDataEntry::setSpinType(int spinType)","link":"ParticleDataScheme.html#anchor103","text":""},{"name":"Jet Matching","link":"JetMatching.html","text":"Jet Matching This manual page describes the parton-jet matching interfaces for PYTHIA8. In this approach, usually referred to as MLM matching Man02, Man07 , the final jets after parton-shower evolution and jet clustering are matched to the original partons. The event is accepted if a reasonable match is found, and rejected if not. The rejection step in an approximate way introduces a Sudakov form factor on to the hard processes. Notably the parton shower should not generate an emission that would doublecount hard activity already included in the matrix-element description. Within this general ansatz, different technical solutions can be adopted. We provide two alternatives, one based on the algorithm used in ALPGEN Man03 , and another on the one used in Madgraph Alw11 , both reimplemented from scratch here. The main points of these two algorithms are outlined further down on this page. We also allow for two alternative sources of external events, one in the ALPGEN native format and one in the Madgraph LHEF-based one. All four combinations of input format and matching style are implemented. In the following it is therefore important to keep the two aspects apart, whenever the ALPGEN and Madgraph labels are used. Currently all the files of interest are located in the include/Pythia8Plugins/ subdirectory: JetMatching.h contains the machinery for the parton-jet matching, in the two JetMatchingAlpgen and JetMatchingMadgraph classes. GeneratorInput.h contains three classes for the reading of ALPGEN event and parameter files, and one for the reading of Madgraph parameters. CombineMatchingInput.h contains three classes that combine the reading of events with the matching of them. main32.cc, main32.cmnd : a sample main program and card file showing the usage of the previous files/classes. Event input source External sources of partons are used in the parton-jet matching process. The source of the partons has been separated from the implementation of the matching algorithm. By default, PYTHIA8 contains a machinery to process Les Houches Event Files (LHEFs) as described on the Les Houches Accord and Beam Parameters pages. Madgraph5 adheres to this format, but also contains some further non-standardized information that can be used. The parsing of the native ALPGEN file format is described on the Alpgen Event Interface page. Commonly, the source of external partons also contains information about how a particular type of matching algorithm should be employed. This information is handled by the AlpgenPar class for ALPGEN files, and MadgraphPar for LHEFs. The user can choose to set default matching parameters using the Alpgen:setMLM flag for ALPGEN files. For LHEFs, instead, the setting of default parameters is controlled with the JetMatching:setMad flag: Jet Matching parameters A class JetMatching , derived from UserHooks , is used to define the basic structure of a parton-jet matching algorithm. Two versions are implemented here, based on the FORTRAN code provided by the ALPGEN and Madgraph packages, respectively: JetMatchingAlpgen and JetMatchingMadgraph. The matching parameters are defined with the JetMatching:* keyword. Scheme and Usage Jet algorithm The choice of jet algorithm and associated parameters can be adjusted with the settings below. The PYTHIA8 internal CellJet and SlowJet routines are used for jet finding.  See the Event Analysis page for more details. Merging parameters The following options are the three main parameters for the merging procedure. Although here they are in principle free parameters, they should be heavily influenced by the hard process generation cuts. These values can be set automatically based on the information in the ALPGEN file or LHEF. Exclusive mode The following settings determine whether clustered jets which do not match an original hard parton are allowed. They are typically permitted in the highest jet multiplicity sample, where the parton shower may produce extra hard jets, without risk of double counting. Any extra jet produced by the shower must be softer than any matched light jet, or else the event is vetoed. Jet matching The following parameters control the criteria for matching a clustered jet to a hard parton. Alpgen-specific parameters Madgraph-specific parameters A preliminary implementation of the FxFx prescription for combining multiple NLO calculations Fre12 is available. We would like to stress that this implementation is still undergoing validation. FxFx merging with aMC\@NLO shares most parameters with the leading-order (MadGraph-style) MLM prescriptions and can be activated by using the three additional settings below. Alpgen-style parton-jet matching and merging This section describes the Alpgen-style MLM merging algorithm for PYTHIA8. The most common reference to the algorithm is Man02. In many respects, however, the implementation provided in the ALPGEN package should be considered the official description of the MLM merging procedure. Although designed primarily to work with events generated with ALPGEN, it can in principle also be used with events from a different source. This should not be done without thought, however, and it is up to the user to understand the details of the algorithm and the implications of using a different hard process generator. First, either the CellJet or SlowJet jet algorithm is chosen. Both of these algorithms have an R and an etaMax parameter. In addition, CellJet has an eTmin and SlowJet has a pTmin parameter. These are the primary three parameters of the merging procedure, and in practice are set dependent on the cuts applied to the matrix element (ME) generation. We stress that the merging procedure is not tied to the geometry of a specific physical detector, but only to the match between the original partons and the resulting jets, using standard jet algorithms in the phase space region where partons have been generated. ME samples with different jet multiplicities are run through the event generator, and the generation interrupted after parton showers have been applied, but before resonance decays and beam remnants have been processed. Note in particular that top quarks will not yet be decayed, which may lead to slight differences with the PYTHIA 6 interface included with the ALPGEN package. In what follows, the hardness measure of jets/partons is taken to be eT when CellJet is used and pT when SlowJet is used. The hard system (ignoring all MPI systems) is then analysed: The particles in the original matrix element process are sorted into    light partons, heavy partons and other particles. For backwards    compatibility, a light parton is defined as the set (d, u, s, c,    b, g) with zero mass. A heavy parton is defined as the set (c, b, t) with non-zero mass. All particles not originating from the heavy partons or other    particles are passed to the jet algorithm and clustered. Clustered jets are matched to the light partons in the original ME    process. There are two different methods which can be used: Method 1: The following is done for each parton, in order      of decreasing hardness. The delta R between the parton      and all jets is calculated and the smallest value taken. If      this is less than the jet R parameter, possibly      multiplied by a constant, the jet and parton are considered to      match, and the jet is removed from further consideration.      Note that for CellJet the delta R measure      is in (eta, phi) , while for SlowJet , it is      in (y, phi). Method 2: This method is only possible when using the SlowJet algorithm. Before the clustering is performed,      extremely soft 'ghost' particles are added to the event at the (y, phi) coordinates of the original matrix element      partons. If such a particle is clustered into a jet, the parton      and jet are considered to match. The idea of 'ghost' particles      was originally introduced by FastJet as a way to measure jet      areas Cac06 and should not affect clustering with an      infrared-safe jet algorithm. If there is a light ME parton remaining which has not been matched    to a jet, then the event is vetoed. If all ME partons have been    matched to a jet, but there are still some extra jets remaining,    then two options are possible: Exclusive mode: the event is vetoed. This is typically used when      there are ME samples with higher jet multiplicities, which would      fill in the extra jets. Inclusive mode: the event is retained if the extra jets are softer      than the softest matched jet. This is typically used when      there is no ME sample with higher jet multiplicity, so the parton      shower should be allowed to give extra jets. All particles originating from the heavy partons are passed to the    jet algorithm and clustered. The clustered jets are again matched to the original partons, but    there is no requirement for a match to be present; all matched jets    are immediately discarded. The matching procedure is much the same    as for light partons, but with two differences when delta R matching is used. First, a different R parameter than that    used by the jet algorithm may optionally be given. Second, all jets    that are within the given radius of the parton are matched, not    just the one with the smallest delta R measure. If there    are still extra jets remaining then in exclusive mode the event is    immediately vetoed, while in inclusive mode the event is retained if    the extra jets are softer than the softest light matched jet. Some different options are provided, specified further above in the parameters section. These are set so that, by default, the algorithm closely follows the official MLM interface provided in the ALPGEN package. All vetoing of events is done through the usual User Hooks machinery, and is therefore already taken into account in the cross section. In the output from Pythia::stat() , the difference between the 'Selected' and 'Accepted' columns gives the number of events that have not survived the vetoing procedure. It is still the responsibility of the user to add together the results from runs with different jet multiplicities. In the simplest case, when ALPGEN input is used and the hard process parameters are used to guide the merging procedure, it is enough to set the JetMatching:nJetMax parameter. Madgraph-style parton-jet Merging and Matching This section describes the Madgraph-style parton-jet matching algorithm for PYTHIA8. First, the k T jet algorithm is applied using the PYTHIA8 SlowJet implementation. The useStandardR = false is used, ie. the (delta R)^2 separation is defined as 2 (cosh(delta y) - cos(delta phi)) rather than the more common (delta y)^2 + delta phi)^2. The R , etaMax , and a pTmin parameters are specified. By default, R = 1 and pTmin = qCut. It is not recommended to change these. These should match the algorithm parameters used in the Madgraph Matrix Element (ME) generation. ME samples with different jet multiplicities are run through the event generator, and the generation is interrupted after parton showers have been applied, but before resonance decays and beam remnants have been processed. In what follows, the hardness measure of jets/partons is taken to be k T relative to qCut. The hard system (ignoring all MPI systems) is analyzed: The hard partons in the original matrix element process, provided by    the LHEF, are sorted into light partons, heavy partons and other    particles. A heavy parton is defined by the JetMatching:nQmatch or by the maxjetflavor value in the LHEF. nQmatch refers to the absolute value of    the quark PDG identity code. All partons arising from the parton shower are sorted based on their    motherhood. A showered parton arising from a heavy parton or 'other'    parton classified in the previous step is not passed to the jet    algorithm. All other partons are clustered into light jets. It is checked whether there are 'too few' or 'too many' light jets.    If the number of light jets is less than the number of light partons    defined by nQmatch , the event is vetoed. If the number is    larger, the event is vetoed only in exclusive mode (defined below). In exclusive mode, the number of jets matches the number of light    partons. In inclusive mode, the jets are re-clustered until the number    of jets equals the number of light partons. Next, each light hard    parton is clustered, one at a time, with the jets until a match is found.    A match is defined as a squared cluster scale that equals: |clFact| * qCut for inclusive mode, |clFact| * max(qCut,min(p T (parton))) for exclusive mode, clFact &ge; 0, or |clFact| * min(k T (parton)) for exclusive       mode, clFact < 0. If no match is found, the event is vetoed. When a parton    matches a jet, the jet is removed from the collection, and    the process continues. The process terminates when all partons    are matched to a jet, or a parton is unmatched. All particles originating from the heavy partons are not used. In exclusive mode, it is expected that ME samples with higher parton multiplicity are available to fill the phase space above qCut. The inclusive mode is when there are no such samples, and the parton shower is used to fill the phase space. Some different options are provided, specified further above. These are set so that, by default, the algorithm closely follows the FORTRAN interface ME2Pythia provided in the Madgraph package. All vetoing of events is done through the usual User Hooks machinery, and is therefore already taken into account in the cross section. In the output from Pythia::stat() , the difference between the 'Selected' and 'Accepted' columns gives the number of events that have not survived the vetoing procedure. It is still the responsibility of the user to add together the results from runs with different jet multiplicities. In the simplest case, when the hard process parameters are used to guide the merging procedure, events will be matched in the exclusive mode. Madgraph-style jet matching with no internal vetoes (assuming an external veto implementation) This section describes the facilities that allow expert users to use their own veto code to perform a Madgraph-style jet matching. This can e.g. be useful to assess jet matching uncertainties without having to process the same input events multiple times. As a first step, any vetoes in the Pythia Jet Matching need to be disabled by using JetMatching:doVeto = off. In this mode, Pythia only stores all the information that is necessary to check (and apply) the shower-kT or kT-MLM vetoes externally by hand. This information can be accessed by calling the functions We do not currently supply example code for this very advanced functionality. Interested expert users should feel free to contact the Pythia authors for further explanations. A note on combining UserHooks As have been noted above, the matching is implemented using classes derived from the UserHooks class, thereby gaining access to the event generation process at the relevant locations. For native ALPGEN files, which do not adhere to the Les Houches standards, it is also necessary to intervene with a UserHooks -derived AlpgenHooks to handle the extraction and setting of relevant extra information. One must then combine multiple UserHooks classes, such that the functionality of both is present. A prerequisite is that the different UserHooks classes should be declared with virtual inheritance, e.g. class JetMatching : virtual public UserHooks Without this option, when combining two UserHooks -derived classes, two copies of the base UserHooks class would be created, leading to ambiguities. The two first classes in CombineMatchingInput.h combine ALPGEN input with the two different matching schemes, e.g. for the first class JetMatchingAlpgenInputAlpgen : public AlpgenHooks,  public JetMatchingAlpgen { public:  // Constructor and destructor.  JetMatchingAlpgenInputAlpgen(Pythia& pythia) : AlpgenHooks(pythia),    JetMatchingAlpgen() { }  ~JetMatchingAlpgenInputAlpgen() {}  // Initialisation.  virtual bool initAfterBeams() {    if (!AlpgenHooks::initAfterBeams()) return false;    if (!JetMatchingAlpgen::initAfterBeams()) return false;    return true;  }  // Process level vetos.  virtual bool canVetoProcessLevel() {    return JetMatchingAlpgen::canVetoProcessLevel();  }  .... }; This class inherits from both AlpgenHooks and JetMatchingAlpgen. Any functions which are present in both classes should be overridden with a function that calls the different parent methods in the desired order. In the above example, the only shared methods are the constructor and initAfterBeams()."},{"name":"SpaceShower:alphaSuseCMW","link":"SpacelikeShowers.html#anchor8","text":"Do not apply the CMW rescaling. Apply the CMW rescaling, increasing Lambda_QCD for spacelike showers by a factor roughly 1.6."},{"name":"HiggsBSM:ffbar2A3W","link":"HiggsProcesses.html#anchor49","text":"Scattering f fbar &rarr; A^0(A_3^0) W^+- via s -channel W^+- exchange. Code 1045."},{"name":"void Pythia::stat()","link":"ProgramFlow.html#anchor30","text":"list statistics on the event generation, specifically total and partial cross sections and the number of different errors. For more details see here and for available options here."},{"name":"ExtraDimensionsG*:GWW","link":"ExtraDimensionalProcesses.html#anchor18","text":"Coupling between graviton and W boson."},{"name":"HiggsBSM:ffbar2A3Z","link":"HiggsProcesses.html#anchor48","text":"Scattering f fbar &rarr; A^0(A_3^0) Z^0 via s -channel Z^0 exchange. Code 1044."},{"name":"double Particle::xProd()","link":"ParticleProperties.html#anchor17","text":""},{"name":"HiddenValley:aLund","link":"HiddenValleyProcesses.html#anchor41","text":"The a parameter of the Lund symmetric fragmentation function. See the normal fragmentation function description for the shape of this function."},{"name":"HardQCD:qqbar2ccbar","link":"QCDProcesses.html#anchor17","text":"Scatterings q qbar &rarr; c cbar. Code 122."},{"name":"Next:numberCount","link":"MainProgramSettings.html#anchor9","text":"Print a line telling how many events have been generated so far, once every numberCount events. If set zero then no lines are ever printed."},{"name":"double ParticleData::mWidth(int id)","link":"ParticleDataScheme.html#anchor42","text":"the width Gamma of the Breit-Wigner distribution (in GeV)."},{"name":"StringFlav:probStoUD","link":"FlavourSelection.html#anchor1","text":"the suppression of s quark production relative to ordinary u or d one."},{"name":"double LHAup::pz(int i)","link":"LesHouchesAccord.html#anchor47","text":""},{"name":"TimeShower:weakShower","link":"TimelikeShowers.html#anchor28","text":"Allow a weak shower, yes or no."},{"name":"double Info::sHat()","link":"EventInformation.html#anchor52","text":"the invariant mass and its square for the hard process."},{"name":"double Info::zNowISR()","link":"EventInformation.html#anchor111","text":"set/get value of z in latest ISR branching."},{"name":"ContactInteractions:QCffbar2eebar","link":"CompositenessProcesses.html#anchor34","text":"Scatterings f fbar &rarr; e- e+ including contact interactions. Code 4203."},{"name":"Charmonium:qg2ccbar(3S1)[3S1(8)]q","link":"OniaProcesses.html#anchor16","text":"Colour-octet production of 3S1 charmonium states via q g &rarr; ccbar[3S1(8)] q. Code 403."},{"name":"bool Settings::flagDefault(string key)","link":"SettingsScheme.html#anchor41","text":""},{"name":"double ParticleDataEntry::resWidth(int idSgn,  double mHat, int idInFlav = 0, bool openOnly = false,  bool setBR = false)","link":"ParticleDataScheme.html#anchor162","text":"calculate the total with for a resonance of a given current mass, optionally including coupling to incoming flavour state (consider the gamma*/Z^0 combination), optionally excluding decay channels that have been closed by the user, and optionally storing the results in the normal decay table. For the first argument only the sign is relevant."},{"name":"UncertaintyBands:doVariations","link":"Variations.html#anchor1","text":"Master switch to perform variations."},{"name":"double Info::uHat()","link":"EventInformation.html#anchor54","text":"the remaining two Mandelstam variables; only defined for 2 &rarr; 2 processes."},{"name":"double Info::thetaScatLepB()","link":"EventInformation.html#anchor71","text":"Scattering angles of the leptons wrt. the beam direction."},{"name":"void ParticleData::initWidths(  vectorAMPERSANDlt;ResonanceWidths*AMPERSANDgt; resonancePtrs)","link":"ParticleDataScheme.html#anchor8","text":"initialize Breit-Wigner shape parameters for all particles, and the detailed handling of resonances, i.e. particles with perturbatively calculable partial widths, which can be used to obtain a mass-dependent Breit-Wigner and a dynamic choice of decay channels. Called from Pythia::init()."},{"name":"bool Pythia::readFile(istreamAMPERSAND inStream = cin,  bool warn = true, int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor10","text":""},{"name":"virtual void BeamShape::init( SettingsAMPERSAND settings,  Rndm* rndmPtrIn)","link":"BeamShape.html#anchor3","text":"the base-class method simply reads in the relevant values stored in the Settings data base, and saves a pointer to the random-number generator. You are free to write your own derived initialization routine, or use the existing one. In the latter case you can then give your own modified interpretation to the beam spread parameters defined there. The two flags Beams:allowMomentumSpread and Beams:allowVertexSpread should not be tampered with, however. These are checked elsewhere to determine whether the beam shape should be set or not, whereas the other momentum-spread and vertex-spread parameters are local to this class."},{"name":"bool Settings::init(string  startFile = AMPERSANDquot;../share/Pythia8/xmldoc/Index.xmlAMPERSANDquot;,  bool append = false)","link":"SettingsScheme.html#anchor3","text":"read in the settings database. read in the settings from all the files listed in this file, and assumed to be located in the same subdirectory. By default nothing is done if the method has already been called once. If true the further settings read in are added to the current database. Note: The method returns false if it fails."},{"name":"double Hist::getBinContent(int iBin)","link":"Histograms.html#anchor18","text":"return the value in bin iBin , ranging from 1 through numberOfBins , with 0 for underflow and numberOfBins + 1 for overflow."},{"name":"bool Particle::isDiquark()","link":"ParticleProperties.html#anchor86","text":"true for a diquark or an antidiquark."},{"name":"void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter))","link":"ParticleProperties.html#anchor114","text":"add a positive offset to the mother and daughter indices, i.e. if mother1 is above minMother then addMother is added to it, same with mother2 , if daughter1 is above minDaughter then addDaughter is added to it, same with daughter2."},{"name":"SigmaProcess:tauMassiveME","link":"SemiInternalProcesses.html#anchor4","text":"Let the tau lepton be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"void Settings::listChanged()","link":"SettingsScheme.html#anchor11","text":""},{"name":"Automated Variations of Shower Parameters","link":"Variations.html","text":"Automated Variations of Shower Parameters for Uncertainty Bands While a number of different central 'tunes' of the Pythia parameters are provided, it is often desired  to study how event properties change when some of the parameters (such as those describing the parton showers) are varied.  Pythia8 now has the ability to provide a series of weights to reflect the change in probability for a particular final state to occur when a subset of parton-shower parameters are varied.  Details on the implementation and interpretation of these weights can be found in Mre16. Currently, the list of available automated variations (see full list below ) includes: The renormalization scale for QCD emissions in FSR; The renormalization scale for QCD emissions in ISR; The inclusion of non-singular terms in QCD emissions in FSR; The inclusion of non-singular terms in QCD emissions in ISR. Similar variations would be possible for QED emissions, but these have not yet been implemented. Since the computation of the uncertainty variations takes additional CPU time (albeit much less than would be required for independent runs with the equivalent variations), the automated uncertainty variations are switched off by default. The main intended purpose of these variations is to estimate perturbative uncertainties associated with the parton showers. Due to the pole at LambdaQCD, however, branchings near the perturbative cutoff can nominally result in very large reweighting factors, which is unwanted for typical applications. We therefore enable to limit the absolute (plus/minus) magnitude by which alphaS is allowed to vary by Likewise, non-singular-term variations are mainly intended to capture uncertainties related to missing higher-order tree-level matrix elements and are hence normally uninteresting for very soft branchings. The following parameter allows to switch off the variations of non-singular terms below a fixed perturbative threshold: By default, the automated shower uncertainty variations are enabled for the showers off the hardest interaction (and associated resonance decays), but not for the showers off MPI systems which would be more properly labeled as underlying-event uncertainties. If desired, the variations can be applied also to showers off MPI systems via the following switch: UserHooks Warning: the calculation of uncertainty variations will only be consistent in the absence of any external modifications to the shower branching probabilities via the UserHooks framework. It is therefore strongly advised to avoid combining the automated uncertainty calculations with any such UserHooks modifications. Merging Warning: in multi-jet merging approaches, trial showers are used to generate missing Sudakov factor corrections to the hard matrix elements. Currently that framework is not consistently combined with the variations introduced here, so the two should not be used simultaneously. This restriction will be lifted in a future release. Specifying the Variations When UncertaintyBands:doVariations is switched on, the user can define an arbitrary number of (combinations of) uncertainty variations to perform. Each variation is defined by a string with the following generic format: Label keyword1=value keyword2=value ... where the user has complete freedom to specify the label, and each keyword must be selected from the list of currently recognised keywords below. Instead of an equal sign it is also possible to leave a blank between a keyword and its value. To exemplify, an uncertainty variation corresponding to simultaneously increasing both the ISR and FSR renormalisation scales by a factor of two would be defined as follows myVariation1 fsr:muRfac=2.0 isr:muRfac=2.0 Staying within the context of this example, the user might also want to check what a variation of the two scales independently of each other would produce. This can be achieved within the same run by adding two further variations, as follows: myVariation2 fsr:muRfac=2.0    myVariation3 isr:muRfac=2.0 Different histograms can then be filled with each set of weights as desired (see accessing the uncertainty weights below). Variations by smaller or larger factors can obviously also be added in the same way, again within one and the same run. Once a list of variations defined as above has been decided on, the whole list should be passed to Pythia in the form of a single 'vector of strings' , defined as follows: For completeness, we note that a command-file specification equivalent to the above default variations could look as follows: UncertaintyBands:List = {      alphaShi fsr:muRfac=0.5 isr:muRfac=0.5,      alphaSlo fsr:muRfac=2.0 isr:muRfac=2.0,      hardHi fsr:cNS=2.0 isr:cNS=2.0,      hardLo fsr:cNS=-2.0 isr:cNS=-2.0    } Note that each of the individual uncertainty-variation definitions (the elements of the vector) are separated by commas and that keywords separated only by spaces are interpreted as belonging to a single combined variation. Note also that the beginning and end of the vector is marked by curly braces. Accessing the Uncertainty Weights During the event generation, uncertainty weights will be calculated for each variation defined above, via the method described in Mre16. The resulting alternative weights for the event are accessible through the Pythia::info.weight(int iWeight=0) method. The baseline weight for each event (normally unity for an ordinary unweighted event sample) is not modified and corresponds to iWeight = 0. The uncertainty-variation weights are thus enumerated starting from iWeight = 1 for the first variation up to N for the last variation, in the order they were specified in UncertaintyBands:List. The total number of variations that have been defined, N , can be queried using Pythia::info.nWeights(). NLO Compensation Term for Renormalisation-Scale Variations Additionally, there is a run-time parameter: List of Recognised Keywords for Uncertainty Variations The following keywords adjust the renormalisation scales and non-singular terms for all FSR and ISR branchings, respectively: fsr:muRfac : multiplicative factor applied to the renormalization scale for FSR branchings. isr:muRfac : multiplicative factor applied to the renormalization scale for ISR branchings. fsr:cNS : additive non-singular ('finite') term in the FSR splitting functions. isr:cNS : additive non-singular ('finite') term in the ISR splitting functions. Note that the muRfac parameters are applied linearly to the renormalisation scale, hence &mu; 2 &rarr; ( muRfac ) 2 *&mu; 2. Optionally, a further level of detail can be accessed by specifying variations for specific types of branchings, with the global keywords above corresponding to setting the same value for all branchings. Using the fsr:muRfac parameter for illustration, the individual branching types that can be specified are: fsr:G2GG:muRfac : variation for g&rarr;gg branchings. fsr:Q2QG:muRfac : variation for q&rarr;qg branchings. fsr:G2QQ:muRfac : variation for g&rarr;qqbar branchings. fsr:X2XG:muRfac : variation for gluon bremsstrahlung off other types of particles (such as coloured new-physics particles). For the distinction between Q2QG and X2XG , the following switch can be used to control whether b and t quarks are considered to be Q or X particles (e.g. providing a simple way to control top-quark or bottom-quark radiation independently of the rest of the shower uncertainties):"},{"name":"Beams:frameType","link":"BeamParameters.html#anchor3","text":"Choice of frame for the two colliding particles. For options 1 - 3 the beam identities are specified above, while they are obtained by the Les Houches information for options 4 and 5. the beams are colliding in their CM frame, and therefore only the CM energy needs to be provided, see Beams:eCM below. the beams are back-to-back, but with different energies, see Beams:eA and Beams:eB below. This option could also be used for fixed-target configurations. the beams are not back-to-back, and therefore the three-momentum of each incoming particle needs to be specified, see Beams:pxA through Beams:pzB below. the beam and event information is stored in a Les Houches Event File , see Beams:LHEF below. the beam and event information is obtained by a pointer to an LHAup class instance."},{"name":"bool Particle::isVisible()","link":"ParticleProperties.html#anchor82","text":"particles with strong or electric charge, or composed of ones having it, which thereby should be considered visible in a normal detector."},{"name":"StandardModel:alphaEM0","link":"StandardModelParameters.html#anchor2","text":"The alpha_em value at vanishing momentum transfer (and also below m_e )."},{"name":"ExtraDimensionsTEV:ffbar2numunumubar","link":"ExtraDimensionalProcesses.html#anchor36","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; numu numubar , Code 5074."},{"name":"SpaceShower:MEcorrections","link":"SpacelikeShowers.html#anchor27","text":"Use of matrix element corrections; on/off = true/false."},{"name":"WeakShower:singleEmission","link":"WeakShowers.html#anchor2","text":"This parameter allows to stop the weak shower after a single emission. If on, only a single weak emission is allowed. If off, an unlimited number of weak emissions possible."},{"name":"HiggsBSM:qqbar2H2bbbar","link":"HiggsProcesses.html#anchor71","text":"Scattering q qbar &rarr; H^0 b bbar via an s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1033."},{"name":"HiggsBSM:ffbar2H2W","link":"HiggsProcesses.html#anchor39","text":"Scattering f fbar &rarr; H^0(H_2^0) W^+- via s -channel W^+- exchange. Code 1025."},{"name":"SpaceShower:pTdampMatch","link":"SpacelikeShowers.html#anchor4","text":"These options only take effect when a process is allowed to radiate up to the kinematical limit by the above pTmaxMatch choice, and no matrix-element corrections are available. Then, in many processes, the fall-off in pT will be too slow by one factor of pT^2. That is, while showers have an approximate dpT^2/pT^2 shape, often it should become more like dpT^2/pT^4 at pT values above the scale of the hard process. Whether this actually is the case depends on the particular process studied, e.g. if t -channel gluon exchange is likely to dominate. If so, the options below could provide a reasonable high- pT behaviour without requiring higher-order calculations. emissions go up to the kinematical limit, with no special dampening. emissions go up to the kinematical limit, but dampened by a factor k^2 Q^2_fac/(pT^2 + k^2 Q^2_fac) , where Q_fac is the factorization scale and k is a multiplicative fudge factor stored in pTdampFudge below. emissions go up to the kinematical limit, but dampened by a factor k^2 Q^2_ren/(pT^2 + k^2 Q^2_ren) , where Q_ren is the renormalization scale and k is a multiplicative fudge factor stored in pTdampFudge below. as option 1, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include t tbar and squark gluino production. as option 2, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include t tbar and squark gluino production. Note: These options only apply to the hard interaction. Specifically, a 'second hard' interaction would not be affected. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of the process itself."},{"name":"HiggsBSM:ffbar2H2Z","link":"HiggsProcesses.html#anchor38","text":"Scattering f fbar &rarr; H^0(H_2^0) Z^0 via s -channel Z^0 exchange. Code 1024."},{"name":"Beams:readLHEFheaders","link":"BeamParameters.html#anchor16","text":"Read in LHEF header blocks and store them in the Info class. See also LHAupLHEF for more information."},{"name":"virtual bool LHAup::setEvent(int idProcess = 0)","link":"LesHouchesAccord.html#anchor30","text":"this pure virtual method has to be implemented in the derived class, to set relevant information when called. For strategy options +-1 and +-2 the input idProcess value specifies which process that should be generated, while idProcess is irrelevant for strategies +-3 and +-4. The method should return false if it fails to set the info, i.e. normally that the supply of events in a file is exhausted. If so, no event is generated, and Pythia::next() returns false. You can then interrogate Info::atEndOfFile() to confirm that indeed the failure is caused in this method, and decide to break out of the event generation loop."},{"name":"ColourReconnection:range","link":"ColourReconnection.html#anchor5","text":"The range parameter defined above. The higher this number is the more reconnections can occur. For values above unity the reconnection rate tends to saturate, since then most systems are already connected with each other. This is why 10 is set as an effective upper limit, beyond which it is not meaningful to let the parameter go."},{"name":"double Info::pzA()","link":"EventInformation.html#anchor4","text":""},{"name":"bool Info::tooLowPTmin()","link":"EventInformation.html#anchor12","text":"normally false, but true if the proposed pTmin scale was too low in timelike or spacelike showers, or in multiparton interactions. In the former case the pTmin is raised to some minimal value, in the latter the initialization fails (it is impossible to obtain a minijet cross section bigger than the nondiffractive one by reducing pTmin )."},{"name":"double Info::eMPI(int i)","link":"EventInformation.html#anchor94","text":"The enhancement or depletion of the rate of the i 'th subprocess. Is primarily of interest for the MultipartonInteractions:bProfile = 4 option, where the size of the proton depends on the x values of the colliding partons. Note that eMPI(0) = enhanceMPI()."},{"name":"SigmaElastic:setOwn","link":"TotalCrossSections.html#anchor18","text":"Allow a user to set parameters for the normalization and shape of the elastic cross section the by hand; yes/no = true/false."},{"name":"ColourReconnection:allowDoubleJunRem","link":"ColourReconnection.html#anchor12","text":"This parameter tells whether or not to allow a directly connected junction-antijunction pair to split into two strings. The lambda measure of the junction system is compared to that of the two possible string configurations. If the chosen configuration is the junction system, a q-qbar system is inserted between the junctions by removing some energy/momentum from the other legs."},{"name":"ExtraDimensionsG*:gg2G*g","link":"ExtraDimensionalProcesses.html#anchor4","text":"Scatterings g g &rarr; G^* g. Code 5003."},{"name":"void Event::scale( double scaleIn)","link":"EventRecord.html#anchor8","text":""},{"name":"TimeShower:limitPTmaxGlobal","link":"TimelikeShowers.html#anchor25","text":"If on, limit the maximal pT produced in branchings in the global recoil scheme exactly as in the default (local) scheme. This means that the mass of the splitting dipole will set an upper bound for the pT of an emission. To be more explicit, this disallows emissions with pT larger than min{&mu; start 2 , m D 2 /4} , with m D 2 = (&radic; &nbsp;(p r +p s ) 2 &nbsp; -m 0,s ) 2 - m 0,r 2 , where the shower starting scale is &mu; start (i.e. SCALUP when reading LHE files, and Info.QFac() otherwise), r the radiating parton, and s the recoiling particle that would have been used in the local recoil scheme. This option is only used if wimpy showers are enabled."},{"name":"Diffraction:MBRdyminCD","link":"Diffraction.html#anchor14","text":"the minimum width of the rapidity gap used in the calculation of cross sections, i.e. the parameter dy_S , which suppresses the cross section at low dy (non-diffractive region)."},{"name":"Particle Data","link":"ParticleData.html","text":"Particle Data The structure and operation of the particle data table is described here. That page also describes how default data properties can be changed. The current page provides the actual default values. Main settings Apart from the data itself, the particle data table only contains a few aspects that are available to change: Since running masses are only calculated for the six quark flavours, e.g. to obtain couplings to the Higgs boson(s), there is not an entry in the normal tables for each particles, but only the six MSbar mass values below, used as starting point for the running. In addition you can pick an alpha_s(M_Z) , which is converted into a first-order five-flavour Lambda that is used to determine the rate of the running. (Without any match to four flavours below m_b ; if desired, this can be fixed by slightly shifted default mass values, since the routines never should be called below the m_b scale anyway.) Comments on the data Much of the current data has been updated based on the 2012 Review of Particle Physics Ber12 , while some is still based on the 2006 RPP Yao06. All known particle masses, widths and lifetimes have been set accordingly, while most not-yet-measured particles are kept at their values from PYTHIA 6. Decay channels and their branching ratios remain a major worry: many particles do not have one single solidly measured branching ratio, and many further do not have known branching ratios that add up to (the neighbourhood of) unity. Uncertainties are especially big for the scalar, pseudovector and tensor L = 1 multiplets available in PYTHIA. We note that some distributions become better described when these multiplets are included in the generation, while others become worse. It is tempting to associate this lackluster performance with the primitive knowledge. Not even the multiplets themselves are particularly well known. It used to be that the a_0(980) and f_0(980) were considered to be members of the scalar multiplet. Nowadays they are commonly assumed to be either four-quark states or of some other exotic character. This means that the PYTHIA 8 PDG particle codes have been changed for these particles, relative to what was used in PYTHIA 6 based on previous PDG editions. Specifically their numbers are now in the 9000000 series, and they have been replaced in the scalar multiplet by a_0(1450) and f_0(1370). For charm and bottom mesons the jungle of partial measurements makes it very difficult to construct fully consistent sets of decay channels. This part of the program has not yet been brought up to date to the 2006 RPP. Instead the LHCb decay tables (for EvtGen, but without using the EvtGen matrix-element machinery) and the DELPHI tune for PYTHIA 6 is being used. (This also includes a few non-c/b hadrons that only occur in the c/b decay tables.) This has the advantage that many tests have been made for consistency, but the disadvantage that it is not always in agreement with the latest measurements of some specific decay channels. The decays based on the LHCb tables (with some modifications) are 411, 421, 431, 441, 445, 511, 521, 531, 541, 3124, 4122, 4124, 5122, 10441, 10443, 13122, 14122, 20443, 23122, 30313, 30323, 30443, 33122, 100113, 100213, 100441, 100443, 100553, 9000111, 9000211. Correspondingly the decays based on the DELPHI tables are 415, 425, 435, 515, 525, 535, 4132, 4232, 4332, 5132, 5232 and 5332. The data itself Here comes the default particle data used in the program. Do not touch. The meaning of the various properties and the format used are explained here and the meMode codes here."},{"name":"double Vec4::eta()","link":"FourVectors.html#anchor31","text":"true rapidity y and pseudorapidity eta."},{"name":"StringPT:expMPI","link":"Fragmentation.html#anchor33","text":"Exponent to the number of MPIs. The width/temparture will get the prefactor N(MPI)^expMPI."},{"name":"double Thrust::tMajor()","link":"EventAnalysis.html#anchor12","text":""},{"name":"void LHAup::setInfoHeader(string AMPERSANDkey, string AMPERSANDval)","link":"LesHouchesAccord.html#anchor12","text":"set the header key to have value val. This is a wrapper function to the Info::setHeader function that should be used in any classes derived from LHAup."},{"name":"virtual bool UserHooks::canEnhanceTrial()","link":"UserHooks.html#anchor46","text":"In the base class this method returns false. If you redefine it to return true then the method enhanceFactor(...) (see above) will be used to rescale an initial-state trial splitting probability."},{"name":"MergingHooks::MergingHooks()","link":"CKKWLMerging.html#anchor15","text":""},{"name":"void ParticleDataEntry::setDoExternalDecays(bool  doExternalDecays)","link":"ParticleDataScheme.html#anchor126","text":""},{"name":"Diffraction:mMinPert","link":"Diffraction.html#anchor18","text":"The abovementioned threshold mass m_min for phasing in a perturbative treatment. If you put this parameter to be bigger than the CM energy then there will be no perturbative description at all, but only the older low- pt description."},{"name":"Beams:sigmaPzA","link":"BeamParameters.html#anchor23","text":"The width of a Gaussian distribution of the p_z spread of the first incoming particle."},{"name":"Beams:sigmaPzB","link":"BeamParameters.html#anchor27","text":"The width of a Gaussian distribution of the p_z spread of the second incoming particle."},{"name":"LeftRightSymmmetry:coupHtaue","link":"LeftRightSymmetryProcesses.html#anchor22","text":"Yukawa coupling for H^-- &rarr; tau- e-."},{"name":"double LHAup::m(int i)","link":"LesHouchesAccord.html#anchor49","text":""},{"name":"bool Settings::writeFile(string toFile,  bool writeAll = false)","link":"SettingsScheme.html#anchor7","text":""},{"name":"Bottomonium:gg2bbbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor58","text":"Colour-octet production of 3S1 bottomonium states via g g &rarr; bbbar[3PJ(8)] g. Code 508."},{"name":"Diffraction:bSelHard","link":"Diffraction.html#anchor36","text":"Selection of impact parameter b and the related enhancement factor for the Pomeron-proton subsystem when the MPI check is carried out. This affects the underlying-event activity in hard diffractive events. Use the same b as already assigned for the proton-proton collision. This implicitly assumes that a Pomeron is as big as a proton and centered in the same place. Since small b values already have been suppressed, few events should have high enhancement factors. Use the square root of the b as already assigned for the proton-proton collision, thereby making the enhancement factor fluctuate less between events. If the Pomeron is very tiny then what matters is where it strikes the other proton, not the details of its shape. Thus the variation with b is of one proton, not two, and so the square root of the normal variation, loosely speaking. Tecnhically this is difficult to implement, but the current simple recipe provides the main effect of reducing the variation, bringing all b values closer to the average. Pick a completely new b. This allows a broad spread from central to peripheral values, and thereby also a more varying MPI activity inside the diffractive system than the other two options. This offers an extreme picture, even if not the most likely one."},{"name":"double LHAup::scalePDF()","link":"LesHouchesAccord.html#anchor64","text":""},{"name":"JetMatching:qCut","link":"JetMatching.html#anchor22","text":"k T scale for merging shower products into jets."},{"name":"SLHA:allowUserOverride","link":"SUSYLesHouchesAccord.html#anchor5","text":"Flag to set whether the user is allowed to modify the parameters read from an SLHA spectrum. Is normally kept off to preserve the internal self-consistency of SLHA spectra. If this flag is switched on , the mass values read from the SLHA block MASS are allowed to be modified by the user, using PYTHIA's standard readString and related methods."},{"name":"void Settings::parm(string key, double now,  bool force = false)","link":"SettingsScheme.html#anchor59","text":""},{"name":"int ClusterJet::nError()","link":"EventAnalysis.html#anchor27","text":"tells the number of times analyze(...) failed to analyze events, i.e. returned false."},{"name":"double Particle::pNeg()","link":"ParticleProperties.html#anchor53","text":"E +- p_z."},{"name":"bool Info::isHardDiffractiveA()","link":"EventInformation.html#anchor20","text":""},{"name":"Merging:usePythiaQFacHard","link":"CKKWLMerging.html#anchor51","text":"If on, this will allow the algorithm to use a dynamical factorisation scale to evaluate parton distributions associated with the hadronic cross section of the core hard process in dijet and prompt photon events. In the calculation of PDF ratios as part of the CKKW-L weight of an event, parton distributions that should be evaluated at the scale of the core 2 - >2 process will be evaluated using the dynamical factorisation scale Pythia would attribute to this process. This means that the hard process factorisation scale is set to the smaller of the squared transverse masses of the two outgoing particles."},{"name":"Diffraction:PomFlux","link":"Diffraction.html#anchor1","text":"Parametrization of the Pomeron flux f_Pom/p( x_Pom, t). Schuler and Sj&ouml;strand Sch94 : based on a critical Pomeron, giving a mass spectrum roughly like dm^2/m^2 ; a mass-dependent exponential t slope that reduces the rate of low-mass states; partly compensated by a very-low-mass (resonance region) enhancement. Is currently the only one that contains a separate t spectrum for double diffraction (along with MBR) and separate parameters for pion beams. Bruni and Ingelman Bru93 : also a critical Pomeron giving close to dm^2/m^2 ,  with a t distribution the sum of two exponentials. The original model only covers single diffraction, but is here expanded by analogy to double and central diffraction. a conventional Pomeron description, in the RapGap manual Jun95 attributed to Berger et al. and Streng Ber87a , but there (and here) with values updated to a supercritical Pomeron with epsilon > 0 (see below), which gives a stronger peaking towards low-mass diffractive states, and with a mass-dependent (the alpha' below) exponential t slope. The original model only covers single diffraction, but is here expanded by analogy to double and central diffraction. a conventional Pomeron description, attributed to Donnachie and Landshoff Don84 , again with supercritical Pomeron, with the same two parameters as option 3 above, but this time with a power-law t distribution. The original model only covers single diffraction, but is here expanded by analogy to double and central diffraction. the MBR (Minimum Bias Rockefeller) simulation of (anti)proton-proton interactions Cie12. The event generation follows a renormalized-Regge-theory model, successfully tested using CDF data. The simulation includes single and double diffraction, as well as the central diffractive (double-Pomeron exchange) process (106). Only p p , pbar p and p pbar beam combinations are allowed for this option. Several parameters of this model are listed below. The H1 Fit A parametrisation of the Pomeron flux H1P06,H1P06a. The flux factors are motivated by Regge theory, assuming a Regge trajectory as in options 3 and 4. The flux has been normalised to 1 at x_Pomeron = 0.003 and slope parameter and Pomeron intercept has been fitted to H1 data. The H1 Fit B parametrisation of the Pomeron flux H1P06,H1P06a."},{"name":"double SigmaProcess::tChanFracPow2()","link":"SemiInternalProcesses.html#anchor28","text":"in the above kind of 2 &rarr; 3 phase-space selection, the sampling of pT^2 is done with one part flat, one part weighted like 1 / (pT^2 + m_R^2) and one part  like 1 / (pT^2 + m_R^2)^2. The above values provide the relative amount put in the latter two channels, respectively, with the first obtaining the rest. Thus the sum of tChanFracPow1() and tChanFracPow2() must be below unity. The final results should be independent of these numbers, but the Monte Carlo efficiency may be quite low for a bad choice. Here m_R is the mass of the exchanged resonance specified by idTchan1() or idTchan2(). Note that the order of the final-state listing is important in the above q qbar' &rarr; H^0 q qbar' example, i.e. the H^0 must be returned by id3Mass() , since it is actually the pT^2 of the latter two that are selected independently, with the first pT then fixed by transverse-momentum conservation."},{"name":"double ParticleDataEntry::m0()","link":"ParticleDataScheme.html#anchor111","text":"the nominal mass m_0 (in GeV)."},{"name":"StringPT:closePacking","link":"Fragmentation.html#anchor32","text":"If switched on then the two following parameters modify either StringPT:sigma or StringPT:temperature , respectively. Normally only one of the options below would be used, but technically both are allowed and then combine multiplicatively."},{"name":"PDF:GammaHardSet","link":"PDFSelection.html#anchor18","text":"Parton densities to be used by the beams of the hard process. For photons the other options are the ones provided by LHAPDF5. If this option is set to void then the same PDF set as PDF:GammaSet is used."},{"name":"CKKW-L Merging","link":"CKKWLMerging.html","text":"CKKW-L Merging CKKW-L merging Lon01 allows for a consistent combination of tree-level matrix elements containing multiple well-separated partons with each other and with parton showers. The result is a calculation that contains a mix of processes with different number of well-separated jets with fixed-order accuracy, improved by all-order resummation. The algorithm implemented  in PYTHIA is described in Lon11. To perform matrix element merging,  the user has to supply LHE files Alw07 for the hard process and the corresponding process with up to N additional jets. This mix of processes is then internally disentangled to ensure that the inclusive fixed-order inputs can be converted to exclusive cross sections that no longer overlap. Please note that subtleties (and setting scheme) for the EW-improved way of disentangling processes presented in Chr15a is discussed in the section Electroweak Merging below. The usage of the merging procedure is illustrated in a few example main  programs ( main81.cc , main82.cc , main83.cc , main84.cc and main85.cc , together with the input files main81.cmnd , main82.cmnd , main84.cmnd and main85.cmnd ). These examples should of course only serve as  an illustration, and as such will not make use of the merging in all  possible ways. For full generality, the example programs link to LHAPDF,  FastJet and HepMC. Of course the user is welcome to  remove these dependencies. To remove the FastJet dependence, the functions calculating example observables have to be deleted. Removing the LHAPDF  dependence requires changing the cmnd input files to choose an inbuilt PDF,  as outlined in the PDF documentation.  The HepMC dependence can be removed by erasing the code allowing for HepMC output. Please note that a detailed tutorial on merging in Pythia is available from http://home.thep.lu.se/Pythia/pythia8/mergingworksheet8160.pdf. Three very short LHE files ( w+_production_lhc_0.lhe , w+_production_lhc_1.lhe , w+_production_lhc_2.lhe ) are included in the distribution. These files are not intended for physics  studies, but only serve as input for the example main programs. For  realistic studies, the user has to supply LHE files. In the generation of LHE files, the value of the factorisation scale used in  the PDFs is not important, since the cross section will be multiplied by ratios  of PDFs to adjust to the PYTHIA starting scales. The same is true for the  renormalisation scale (and starting value &alpha; s (M Z ) )  used to evaluate &alpha; s. Coupling and scale choices by the user will be transferred to the merging routines. Multi-jet events can suffer from infrared divergences in the calculation. Sensible matrix element generator (MEG) outputs should not contain phase space points in which the calculation is ill-defined, meaning infrared regions need to be removed by cuts. This is most conveniently done by disallowing the MEG to produce partons below a minimal parton-parton separation in a certain jet algorithm. Using dedicated cuts to regularise MEG output is of course possible as well. Any regularisation criterion defines the matrix element region: The parts of phase space in which the fixed order calculation is considered valid and preferable to the parton shower. Matrix element merging is combining MEG events in the matrix element region with parton shower events in regions outside the regularisation cut (often called parton shower region). Because the regularisation cut defines a boundary between the matrix element and parton shower regions, i.e. the regions to be merged into one inclusive sample, it is usually called merging scale. Since many different cut choices may regularise the MEG calculation, many different merging scale definitions are possible. A few standard choices are listed below, as well as documentation on how to use a user-defined cut criterion. In combining matrix element and parton shower regions, the CKKW-L prescription tries to minimise the dependence on the merging scale. This can only be achieved if the combination of MEG events and parton shower populates the whole phase space. Additional cuts on the partons in the LHEF generation should hence be avoided as much as possible, meaning that the merging scale cut should always pose a more stringent cut than all other cuts on the partons. Of course, if the hard process itself is divergent, cuts need to be made. However, this should be chosen in such a way as to not exclude regions that will be available to the matrix elements with additional jets. An example is QCD di-jet production with additional jets: Say the 2 &rarr; 2 process is regularised with a pTmin cut of pTminCut = 100 GeV, and the 2 - >3 sample is regularised with a kTmin -cut of kTminCut = 50 GeV. This would mean that when reclustering the  emission in the 2 &rarr; 3 sample, we could end up with a pT value pTminNow of the 2 &rarr; 2 configuration with pTminCut > pTminNow , which is excluded in the 2 &rarr; 2 sample. Thus, the 2 &rarr; 3 sample will include a Sudakov factor  not included in the 2 &rarr; 2 sample, resulting in merging scale  dependencies. Such dependencies can be avoided if the additional cuts on the hard process are minimal. Of course, additional cuts on electroweak particles are allowed. These  should be the same for all samples with 0 <= n <= N additional partons. If it is not possible to generate LHE files with minimal cuts, the user can choose to use the MergingHooks structures in order to decide how much influence to attribute to parton shower histories in which the reclustered lowest multiplicity process does not pass the matrix element cuts. This is  described below. When generating LHE files, we advise against putting unstable  particles (e.g. massive gauge bosons) in the final state. Rather, specify a  resonance by its decay products, e.g. if Les Houches events for the pp &rarr; Z + jets &rarr; e+e- + jets process are desired, generate the matrix element events with the Z decay included. From a physical  point of view, on-shell final massive gauge bosons should not be considered  part of a hard process, since only the boson decay products will be detectable.  Furthermore, non-narrow-width approximation contributions are not present if  the ME generator only produces on-shell bosons. Interference effects between  different production channels for the decay products would also be neglected.  These points seem an unnecessary restriction on the accuracy of the ME  calculation.  In addition, there is a technical reason for this strategy. Since  some matrix element generators choose to put additional information on  intermediate bosons into Les Houches events, depending on if they pass a certain criterion (e.g. being close to the mass shell), without exact knowledge of this  criterion, the only feasible way of bookkeeping the hard process is by  identifying outgoing decay products. Despite these considerations, (massive) gauge bosons in the final state are allowed in the hard process definition. This is useful particularly for Higgs physics, when different decays of the Higgs boson need to be simulated after the LHEF generation. For all merging purposes, processes with different charge of outgoing leptons are considered different processes. That means e.g. that e+&nu; e + jets and e-&nu;&#772; e + jets are considered independent processes. If the user wishes to generate distributions including effects of more than one  process, merged samples for all independent processes should be generated  separately and added afterwards. Alternatively, to combine simple processes, combined LHE files can be used in conjunction with flexible containers (see below). When the matrix element merging is used to produce HepMC Dob01 files to be analysed  with RIVET Buc10 , special care  needs to taken in how the cross section is read by RIVET (see below). To specify the merging conditions, additionally information on the merging scale value and the functional definition of the merging scale is needed. A few  standard definitions of merging scales are available. We hope this makes the user interface less cumbersome. Different choices intrinsic to the CKKW-L merging procedure might be relevant for the user as well. The base class MergingHooks gives the user the opportunity to define the functional form of the merging scale.  In the following, the usage of the merging machinery to consistently include LHE files with additional jets into PYTHIA  will be discussed. Merging scale definitions The quickest way to include processes with additional jets is to produce LHE files with one of the standard ways to define the merging scale. Three standard ways to define a merging scale (minimal kT , minimal evolution pT and by three cuts) are implemented. All of these prescriptions are equivalent - different definitions have only been introduced for the convenience of users, who might be limited by which cuts can be used in the generation of LHE files. Below, we describe how to switch on and use these different merging scale definitions. Merging with merging scale defined in kT: Currently, the name longitudinally invariant kT is used for a few jet recombination algorithms with slightly different jet measures. A specific form can be chosen by setting the switch If e.g. W + jets merging should be performed, set this to pp>e+ve ( without white spaces or  quotation marks ). This string may contain resonances in the MG/ME notation, e.g. for merging pp&rarr;Z W + &rarr;q q&#772; e+&nu; e + jets , the string pp>(z>jj)(w+>e+ve) would be applicable. A lot more flexible hard process definitions are possible. To not dwell too much on these details here, we will come back to the process string at the end of this section. Merging with merging scale defined in Pythia evolution pT : If the LHE file has been regularised by cutting on the minimal Pythia evolution pT in the state, this can also be used as a merging scale right away. For this, change the switch Merging with merging scale defined by a combination of cuts: It is possible to regularise QCD divergences in a LHE file by applying cuts to the kinematical pT of jets ( pT i ), combined with a cut on &Delta;R ij between jets and a cut on invariant mass Q ij of jet pairs. The combination of these standard cuts can also serve as a merging scale. For this, use this setting The values of the cuts will then be read from With knowledge of these values, and Merging:doCutBasedMerging , Pythia will use these cuts as a separation between matrix element phase space and parton shower region. If e.g. the Les Houches Events have been generated with the cuts &Delta;R ij = 0.1 , pT i = 20 GeV and Q ij = 40 GeV , set Merging:QijMS=40. , Merging:pTjMS=20. , Merging:dRijMS=0.1 to perform a cut-based merging. Of course you will also need to set Merging:Process and the maximal number of additional matrix element jets Merging:nJetMax. Les Houches events outside the matrix element region Before continuing, we would like to point out that in general, the user should make sure that the events in the Les Houches file are actually calculated using the regularisation cut definition and value(s) supplied to Pythia as merging scale definition and value(s). However, if LH files with a large number of events and loose merging scale cuts are available, it might be useful to choose a higher merging scale value, e.g. for merging scale variations as part of uncertainty assessments. If CKKW-L merging is enabled, Pythia will by default check if events read from Les Houches file are in the matrix element region as defined by the merging scale definition and merging scale value. Events outside the matrix element region will be discarded. This will lead to warnings of the form ' Les Houches Event fails merging scale cut. Cut by rejecting event '. These warnings should, in this case, rather be regarded as information. To change the default behaviour, use the flag Defining the hard process To perform CKKW-L matrix element merging, the user has to decide on a hard process, and communicate this choice to Pythia. This is done by setting the input Merging:Process. Note that the EW-improved 'merging of mergings' strategy presented in Chr15a requires a very loose process definition that is discussed in the section Electroweak Merging below. For single processes in the Standard Model or the MSSM, MG4/ME notation is applicable. However, for some purposes, using a single simple process string is not satisfactory. Mixed W + and W - events in a single LHE file is a common example. For this case, it would of course be perfectly allowed to perform twice, once for W + production and once for W - production, and then add the results. Nevertheless, it seems reasonable to alleviate difficulties by allowing for less restrictive hard process definitions. Two generalisations of the process tag are available: Containers and user-defined particle tags. The syntax of these settings is described below. In case you want multiple processes in a LHE file to be treated on equal footing (e.g. W + + jets and W - + jets ), you should use flexible containers do specify the hard process. So far, we allow the use of the containers LEPTONS , NEUTRINOS , BQUARKS. If you use these containers, the hard process definition is relatively flexible, meaning that Pythia will attempt a merging of QCD jets for each event in the LHE file, and assume that all particles matching one of the containers are products of the hard process. This is best explained by examples. If you want to have both pp &rarr; e+ &nu; e + jets and pp &rarr; e- &nu;&#772; e + jets events in a single file, you can set Merging:Process=pp>LEPTONS,NEUTRINOS as hard process (note that for readability, you are allowed to use commata to separate container names). Combining e.g. the processes pp &rarr; e+ &nu; e and pp &rarr; &mu;+ &nu; &mu; is possible with the hard process definition pp>LEPTONS,NEUTRINOS. For maximal flexibility, the definition of the hard process by these containers does not mean that each Les Houches event needs to contain particles to match each container. It is enough if one container is matched. This means that with the string pp>LEPTONS,NEUTRINOS , you can immediately process pp &rarr; e+ e- events mixed with pp &rarr; e+ &nu; e events, since particles matching at least one container can be found in both cases. Another example for the usage of containers is mixing pp &rarr; e+ &nu; e and pp &rarr; tt&#772; &rarr; e+ &nu; e e- &nu;&#772; e bb&#772;. This can be accommodated by the hard process string Merging:Process=pp>LEPTONS,NEUTRINOS,BQUARKS. There is however a conceptual limitation to containers: The hard process definition is necessary to ensure that when constructing lower multiplicity states (that will be used to calculate the correct merging weight), the structure of the hard process will be preserved. If e.g. we want the hard process to be pp &rarr; Z &rarr; bb&#772; , we should ensure that the lowest multiplicity state contains a colour-singlet bb&#772;-pair. When reconstructing intermediate lower multiplicity states from multi-jet matrix elements, we should thus always be able to find at least one bb&#772;-pair. By mixing different processes in a LHE file, this requirement might already be violated at the level of Les Houches events. Flexible containers cannot give strong conditions which flavours should be preserved in the construction of the hard process. In order to avoid non-sensible results, it is hence assumed that all particles matching any of the containers will be part of the lowest multiplicity process. This implies that if you decide to use the BQUARKS container, all b-quarks in the LHE file will be interpreted as hard process particles, and never as additional radiation. Another way to specify the hard process particles is to explicitly define the particle names and identifiers. This is necessary if the matrix element merging in Pythia does not contain the particles of interest. To make sure that the hard process is still treated correctly, it is possible to define particles in the process string. If you e.g. want the hard process to contain a particle 'zeta~' with PDG identifier '12345', produced in proton collisions, you have to include a user-defined particle tag by setting the process string to pp>{zeta~,12345}. The  user-defined particle is enclosed in curly brackets, with syntax {particle_name,particle_identifier} , where 'particle_name' and 'particle_identifier' are the particle name and particle identifier used for this particle in the input LHE file. User-defined particles are only allowed in the final state. You are free to fix user-defined particles with more common ones, as long as user-defined particles are put before more common particles in the process string. This means that if you e.g. wanted the hard process to contain a graviton in association with a positron and an electron-neutrino, you have to define the hard process as pp>{G,39}e+ve. Below you can find a list of particles predefined in the merging. If you wish to include a hard process with different final state particles, you may use the 'curly bracket notation' outlined above. The set of incoming particles us limited to: e- (electron), e+ (positron), mu- (muon), mu+ (antimuon), p (proton, container to hold all initial state coloured particles), p~ (identical to p container). The following intermediate particles are allowed: a (photon), z (Z boson), w- (W - boson), w+ (W + boson), h (scalar Higgs boson), W (container to hold both W - and W + boson), t (top quark), t~ (anti-top), dl , dl~ , ul , ul~ , sl , sl~ , cl , cl~ , b1 , b1~ , t1 , t1~ , dr , dr~ , ur , ur~ , sr , sr~ , cr , cr~ , b2 , b2~ , t2 , t2~ (all MSSM squarks). We have pre-defined the outgoing particles: e+ , e- , ve~ , ve , mu+ , mu- , vm~ , vm , ta+ , ta- , vt~ , vt (all SM leptons and neutrinos), j~ (container to hold all final state coloured particles), j (container to hold all final state coloured particles), NEUTRINOS (container to hold all final state neutrinos and anti-neutrinos), LEPTONS (container to hold all final state leptons and anti-leptons), BQUARKS (container to hold final state b-quarks), d~ , d , u~ , u , s~ , s , c~ , c , b~ , b , t~ , t (all SM quarks), a , z , w- , w+ (all SM electro-weak bosons), h (scalar Higgs boson), W (container to hold both W - and W + boson), n1 (MSSM neutralino), dl~ , dl , ul~ , ul , sl~ , sl , cl~ , cl , b1~ , b1 , t1~ , t1 , dr~ , dr , ur~ , ur , sr~ , sr , cr~ , cr , b2~ , b2 , t2~ , t2 (all MSSM squarks). Other outgoing particles are possible if you use the 'curly bracket notation' described earlier. Histogramming the events After the event has been processed, histograms for observables of interest need to be filled. In order to achieve good statistical accuracy for all jet multiplicities and all subprocesses contributing to one jet multiplicity, generally a fixed number of unit-weighted events is read from each Les Houches Event file. To then arrive at the correct prediction, for each of these events, histogram bins should be filled with the corresponding cross section, or weighted with unit weight and normalised at the end to the generated cross section for each jet multiplicity separately. Still another, even more important, event weight that has to applied on an  event-by-event basis is the CKKW-L-weight. This corrective weight is the main  outcome of the merging procedure and includes the correct no-emission  probabilities, PDF weights and coupling (&alpha; s or &alpha; em ) factors. This means that the merging implementation will generate weighted events. The CKKW-L-weight can be accessed by the following function: double Info::mergingWeight() &nbsp; Returns the CKKW-L weight for the current event. Note that to avoid confusion, this function does not include the the weight of a phase space point (given by Info::weight() ). This weight will differ from unity when reading in weighted Les Houches events. In this case, the full weight with which to fill histogram bins is Info::mergingWeight() * Info::weight(). Finally, to arrive at a correct relative normalisation of the contributions from different number of additional jets in the matrix element, each histogram should be rescaled with the accepted cross section given by Info::sigmaGen(). The accepted cross section includes the  effect of vetoes generating Sudakov form factors for the matrix elements, and  is in general only known after the run. This final step can of course be skipped if the accepted cross section had been estimated before the histogramming run, and  histogram bins had instead been filled with the weight Info::mergingWeight() * &sigma; est (number of additional jets in current ME sample). This is the way HepMC events should be weighted to produce correct relative weights of events (see below, and particularly examine the example programs main84.cc and main85.cc ). Examples how to use these options are given in main81.cc ( kT merging), main84.cc (automatic MG/ME merging for RIVET usage), and main85.cc (HepMC output for RIVET usage). Merging with user-defined merging scale function For all other merging scale definitions, the procedure is slightly more  complicated, since the user has to write a small piece of code defining the  merging scale. To allow for a user defined procedure, set the input Then, set the Merging:nJetMax , Merging:TMS and Merging:Process input as before. Since during execution, PYTHIA needs to evaluate the merging scale with the  definition of the user, the user interface is designed in a way similar to the UserHooks strategy. The class controlling the merging scale  definition is called MergingHooks. Initialisation To initialise the merging with user-defined merging scale, we should construct a class derived from MergingHooks , with a constructor and destructor For the class to be called during execution, a pointer to an object of the class should be handed in with the Pythia::setMergingHooksPtr( MergingHooks*) method.  An examples of this procedure are given in main82.cc. Defining a merging scale Then, in the spirit of the UserHooks class, the user needs to  supply the process to be merged by defining a methods to evaluate the merging scale variable. The base class MergingHooks contains many functions giving  information on the hard process, to make the definition of the merging scale as easy as possible: Filling output histograms for the event then proceeds along the lines described above in 'Histogramming the events'. The full procedure is outlined in main82.cc. Special care needs to be  taken when the output is stored in the form of HepMC files for RIVET usage. Defining a cut on lowest jet multiplicity events It can sometimes happen that when generating LHE files, a fairly restrictive cut has been used when generating the lowest multiplicity matrix element  configurations. Then, it can happen that states that are (in the generation of a parton shower history) constructed by reclustering from higher multiplicity  configurations, do not pass this matrix element cut. Consider as an example  pure QCD dijet merging, when up to one additional jet should be merged.  Three-jet matrix element configurations for which the reclustered two-jet state does not pass the cuts applied to the two-jet matrix element would never have  been produced by showering the two-jet matrix element. This means that the three-jet matrix element includes regions of phase space that would never have  been populated by the parton shower. Thus, since the matrix element phase space is larger than the shower phase space, merging scale dependencies are expected.  A priori, this is not troublesome, since the aim of matrix element merging is  to include regions of phase space outside the range of the parton shower approximation into the shower. An example is the inclusion of configurations  with only unordered histories. Clearly, if the parton shower phase space is very constrained by applying  stringent cuts to the two-jet matrix element, merging scale dependencies can  become sizable, as was e.g. seen in Lon11 when forcing shower emissions to be ordered both in the evolution variable and in rapidity. To  influence the effect of large phase space differences for shower emissions and matrix element configurations due to LHEF generation cuts, the user has to  write a small piece of code overwriting method Note that this method gives the user access to the lowest multiplicity state,  which ( e.g. in the case of incomplete histories) does not have to be a 2 &rarr; 2 configuration. Also, changing the weight of the current event by  hand is of course a major intervention in the algorithm, and should be  considered very carefully. Generally, if this facility would have to be used extensively, it is certainly preferable to be less restrictive when applying  additional, non-merging-scale-related cuts to the matrix element. An example how to force a cut on lowest multiplicity reclustered states for pure QCD matrix element configurations is given by main83.cc (to be used with e.g. main82.cmnd ). Influencing the construction of all possible histories Even more powerful - and dangerous - is influencing the construction of histories directly. This should only be attempted by expert users. If you believe manipulations completely unavoidable, we advise you to take great care when redefining the following functions. Clearly, these methods are highly intrusive. It could e.g. happen that no history is allowed, which would make merging impossible. One example where this method could be useful is if cuts on the core 2 &rarr; 2 processes have to be checked, and the method MergingHooks::dampenIfFailCuts(const Event& event) is not sufficiently effective. Defining the hard process matrix element The MergingHooks class also allows the expert user to define the matrix element of the hard process, by defining the method The inclusion of the hard process matrix element into the choice of histories becomes relevant when the hard process matrix element has very strong phase space dependencies. QCD dijet cross sections for example strongly depend on the transverse momentum of the jets. So far, the authors have not encountered any changes upon inclusion of the full hard process matrix element, even for the QCD dijet case. Matrix element merging and HepMC output for RIVET Examples how to produce matrix element merged events to be analysed with RIVET are given by main84.cc and main85.cc. The main issue is that the output of separate RIVET runs can not in general be combined. To perform a matrix element merging, we however need to runs over  different LHE files. The solution to this problem (so far) is to only perform  one RIVET run for all matrix elements, i.e. print the events for all ME parton  multiplicities, with the correct weights, to a single HepMC file. Since the correct weight includes the cross section of the different samples after Sudakov vetoes --- which is not a priori known --- the cross sections have to be  estimated in a test run, before the actual production run is performed. Finally, the cross section of the last event in the HepMC file has to be taken as the  full merged cross section sigma_merge = Sum_{i=0}^N Sum_{j=0}*^{nEvents} sigma_est(i)*wckkwl(j). This procedure is outlined in main84.cc.  Input LHE files with only very inclusive cuts pose further difficulties. For such files (which were already addressed under the heading Les Houches events outside the matrix element region ), the cross section after the merging scale cut is not known before the cut is performed. Using Pythia's UserHooks facilities, it is possible to produce a valid estimate of the cross section after cuts. This however entails a careful cut definition by the user, which might become cumbersome for some in-built merging scale definitions. A reasonable alternative is using the switch This switch also relies on knowledge on how many partons a LHE file should contain. This is important for real-emission kinematics in the case of NLO merging. The number of (additional) partons in a LHE file can be set with The usage of these switches to obtain the necessary cross section estimate is illustrated in main85.cc. The example main85.cc program is intended as a 'front-end' for CKKW-L merging in Pythia8, so we will discuss the program briefly. main85.cc should be used together with an input file (like main85.cmnd ). The executable should be invoked with three arguments: the input file, the 'name' of the input LHE files, and the name of the output HepMC event file. To use the LHE files that are shipped with the Pythia distribution, a valid usage would be ./main85.exe ./main85.cmnd ./w_production ./myhepmc.hepmc If you want to use other input LHE files, note that main85.cc assumes the naming convention name_tree_#nAdditionalJets.lhe. All settings can be included though the input file, so that main85.cc does not have to be changed explicitly. main85.cc first switches off showers, multiparton interactions and hadronisation, and estimates the cross sections (after enforcing the merging scale cut) of samples for different numbers of additional jets. Then, showers, MPI and hadronisation are switched on again, and the CKKW-L merging procedure is performed. Events will be read in a decreasing sequence of jet multiplicities, which also means that e.g. events with two additional partons in the LHE file will be printed to the HepMC file before events with one additional parton. Electroweak Merging Merging strategies like CKKW-L usually assume that the description of a (relatively simple) underlying process should be improved by combining with states that contain additional well-separated partons - with 'additional' measured with respect to the underlying process. As discussed in Chr15a , this philosophy is not always sensible, and may lead to an unconvincing physics model. The bias can be greatly reduced by considering that in perturbation theory, corrections to seemingly very different underlying processes mix, so that there is no justification to classify some states as corrections to only one underlying process. Interactions that only contain vertices of only one theory (e.g. QCD) will mix with processes that contain only vertices of another interactions (e.g. QED). Underlying processes with very different coupling structures should thus be considered. This is the main aim of the electroweak merging scheme. The process p p &rarr; W jet jet provides a good example, since it can be interpreted either as double-real-QCD-emission correction to p p &rarr; W or as real-electroweak-emission correction to p p &rarr; jet jet. The distinction is artificial, but the all-order resummation is very different in either case, leading to distinctly different predictions. Thus, a minimally biased method for assigning an underlying process has to be found. The method of Chr15a chooses the underlying process probabilistically for each phase space point based on a product of splitting kernels and full hard process matrix elements, and includes the correct all-order factors after this choice. In our previous example ( p p &rarr; W jet jet ), this would mean that the hard scattering could be p p &rarr; W or p p &rarr; jet jet (or, depending on phase space considerations, also p p &rarr; W jet ). The availability of electro-weak showers in Pythia 8 is crucial for a consistent scheme that removes of double-counting, since double-counting is (in part) removed by applying no-emission probabilities. In order to e.g. ensure that a state in the p p &rarr; jet jet does not, via W-boson emission, evolve into a state overlapping with p p &rarr; W + two QCD emissions, the former has to be reweighted with an all-order no-electroweak-emission probability. As always, a small merging scale dependence is facilitated by accounting for for dynamical PDF evaluation and running couplings. An electroweak merging thus includes a reweighting with &alpha; em ratios that are automatically included in the 'merging weight'. As another consequence of probabilistically assigning the underlying process is the 'merging of mergings': Since purely partonic final states can evolve into jets + electroweak bosons states, it is necessary to treat bosons and partons on equal footing, meaning that well-separated boson states should be corrected with fixed-order inputs, while soft/collinear bosons should be associated with parton showering. Shortly, bosons and partons are treated identically. For our previous example, this means that the 'correct' set of fixed-order corrections that include up to three final state particles is p p &rarr; n Ws + m jets , where any combination of n and m subject to n + m <= 3 has to be included ( p p &rarr; W , p p &rarr; W jet , p p &rarr; W jet jet , p p &rarr; W W , p p &rarr; W W W , p p &rarr; W W jet , p p &rarr; jet jet , p p &rarr; jet jet jet ) For practical purposes, it is sometimes permitted to not combine a complete set of processes. Only the single W-state has been explicitly validated and in addition the weak PS does not include all possible splittings for multiple W emissions, therefore caution has to be taken if using this for multiple W states. The 'merging of mergings' has important consequences for the (interested) user. Below, we give instructions on the usage of the electroweak merging. Fixed-order inputs for electroweak merging The electroweak merging leads to the idea of a 'merging of mergings'. This has to be enforced also at the fixed-order sample generation stage, with two main requirements. A fully consistent treatment requires the generation of samples containing all states with a number of emissions that is less than or equal to the 'maximal possible number of emissions of any type' that should be corrected, cf. the W jet jet example above.  In practise, it is often permitted to disregard some (set of) samples since their impact on an analysis is negligible. If e.g. an analyis always requires missing transverse momentum and a single lepton, and we assume perfect lepton acceptances, then it would be permitted to disregard the multi-W samples in the example. If the collision energy is in addition low (~up to fews of TeVs), then the probability for a pure QCD state to emit W-bosons is often low enough so that the pure jet samples can be neglected. However, you should think very carefully before settling on any shortcuts. Any particle that could count as an emission has to be included in the calculation of the particle separations that define the merging scale. If e.g. W-bosons are considered emissions, then any state with W-bosons that are collinear with another emission should be removed from the fixed-order sample. Such configurations will instead be produced through parton showering. This requirement means that you might have to define your own cut including this condition in your favourite fixed-order matrix element generator. At the risk of losses in efficiency, you can also use samples with very loose cuts and have Pythia enforce the merging scale cut when reading your input events. The latter is only possible if you use the merging scale definition Merging:doPTLundMerging = on. Enabling the electroweak merging The electroweak merging is currently only tested for processes containing W-bosons and jets. For a consistent merging, it is necessary to enable W-boson emissions by using TimeShower:weakShower    = on , TimeShower:weakShowerMode  = 1 , SpaceShower:weakShower    = on , SpaceShower:weakShowerMode = 1 , and WeakShower:externalSetup  = on. To enable the electroweak merging, use the following switch. As explained above, the electroweak (EW) merging treats all shower-producible particles equally. This also means that the merging scale definition must include a separation of W-bosons and partons to define if a state is in the (well-separated) fixed-order region or if it is in the (soft/collinear) parton shower region. Such a cut can be implemented inside the (external) matrix element generator. On the other hand, Pythia 8 allows the usage of samples with very loose cuts and can enforce the correct merging scale cut by rejecting input events that do not pass the cut. This is also possible for the EW merging, albeit only for the merging scale definition that is enabled by using Merging:doPTLundMerging = on. We recommend using this strategy for users that do not wish to implement the cut directly into the ME generation, and who are prepared to accept a loss of efficiency because of Pythia's a-posteriori rejection. Defining the 'inclusive' merging process Since the concept of a single 'hard process' is not suitable for the EW merging, the process should be defined in a rather loose manner. This loose definition is still done by setting the input Merging:Process.  Processes for EW merging should use the containers Jinc , Winc , Ainc and Zinc , which tell the code which particles could be possible 'additional' emissions. No other particle defnitions are allowed, and none of the settings discussed in the 'Defining the hard process' section are relevant here.  Examples of allowed process definitions are Merging:Process = pp > Jinc,Winc meaning that W-bosons and partons are treated on equal footing (i.e. this is the setting applicable to the example used earlier). The merging will then include pure QCD multijet events, W+jets events, multi-W+jets events and pure multi-W events; Merging:Process = pp > Jinc,Zinc meaning that Z-bosons and partons are treated on equal footing; Merging:Process = pp > Jinc,Winc,Zinc meaning that W-bosons, Z-bosons and partons are treated on equal footing. Setting the number of additional particles Since the EW merging probabilistically decides on the 'underlying process', it is a priori not possible to set the maximal number of additional emissions on top of this underlying process. A p p &rarr; W jet jet state would e.g. contain two additional emissions if interpreted as correction to p p &rarr; W , and only one additional emission if interpreted as correction to p p &rarr; jet jet. Pythia 8 consequently decides dynamically how to set the additional number of emissions. The maximal number of emissions, set by using the Merging:nJetMax setting, still has to be defined to allow a sensible treatment of the 'highest-multiplicity' states. We thus redefine the meaning of Merging:nJetMax to 'maximal possible number of emissions of any type'. As an example, Merging:nJetMax = 3 if you want to perform a 'merging of mergins' containing states with up to three partons, or up to two partons and one W-boson, or up to one parton and two W-bosons, or up to three W-bosons. Further variables For more advanced manipulations of the merging machinery, all parameter  changes that were investigated in Lon11 are supplied. Please  check Lon11 for a detailed discussion of the switches. These switches allow enthusiastic users to perform a systematic assessment of the merging prescription. Apart from this, we advise the non-expert user to keep the default values."},{"name":"Vec4AMPERSAND Vec4::operator=(double value)","link":"FourVectors.html#anchor4","text":"gives a  four-vector with all components set to value."},{"name":"HiddenValley:FSR","link":"HiddenValleyProcesses.html#anchor33","text":"switch on final-state shower of gv or gammav in a HV production process."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; ParticleData::getReadHistory(int subrun)","link":"ParticleDataScheme.html#anchor20","text":"Method to retrieve the history of readString commands that have been processed by the ParticleData instance, for a specific subrun (see the section on Main-Program Settings ). For subrun = -1 , returns the readString history common to all subruns. For subrun >= 0 , returns the history of readString commands for that specific subrun (omitting the common part)."},{"name":"bool ParticleDataEntry::isQuark()","link":"ParticleDataScheme.html#anchor141","text":"true for a quark or an antiquark."},{"name":"Diffraction:coreRadius","link":"Diffraction.html#anchor29","text":"When assuming a double Gaussian matter profile, bProfile = 2 , the inner core is assumed to have a radius that is a factor coreRadius smaller than the rest."},{"name":"void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr)","link":"UserHooks.html#anchor3","text":"this (non-virtual) method is automatically called during the initialization stage to set several useful pointers, and to set up the workEvent below. The corresponding objects can later be used to extract some useful information. Info : general event and run information, including some loop counters. Settings : the settings used to determine the character of the run. ParticleData : the particle data used in the event record (including workEvent below). Rndm : the random number generator, that you could also use in your code. BeamParticle : the beamAPtr and beamBPtr beam particles contain info on partons extracted from the two incoming beams, on the PDFs used, and more. In cases when diffraction is simulated, also special Pomeron beams beamPomAPtr and beamPomBPtr are introduced, for the Pomerons residing inside the respective proton. CoupSM : Standard Model couplings. PartonSystems : the list of partons that belong to each individual subcollision system. SigmaTotal : total/elastic/diffractive cross section parametrizations."},{"name":"HadronScatter:neighbourFar","link":"HadronScattering.html#anchor12","text":"If scattering of hadrons within the same string is allowed this  parameter gives the neighbour starting from which the maximum  probability maxProbSS is applied."},{"name":"Init:showChangedParticleData","link":"MainProgramSettings.html#anchor5","text":"Print a list of particle and decay data for those particles that were changed (one way or another)."},{"name":"TimeShower:pTdampMatch","link":"TimelikeShowers.html#anchor4","text":"These options only take effect when a process is allowed to radiate up to the kinematical limit by the above pTmaxMatch choice, and no matrix-element corrections are available. Then, in many processes, the fall-off in pT will be too slow by one factor of pT^2. That is, while showers have an approximate dpT^2/pT^2 shape, often it should become more like dpT^2/pT^4 at pT values above the scale of the hard process. This argument is more obvious and relevant for ISR, where emissions could go the the kinematical limit, whereas they are constrained by the respective dipole mass for FSR. Nevertheless this matching option is offered for FSR to have a (semi-)symmetric description. Note that a dampening factor is applied to all dipoles in the final state of the hard process, which is somewhat different from the ISR implementation. emissions go up to the kinematical limit, with no special dampening. emissions go up to the kinematical limit, but dampened by a factor k^2 Q^2_fac/(pT^2 + k^2 Q^2_fac) , where Q_fac is the factorization scale and k is a multiplicative fudge factor stored in pTdampFudge below. emissions go up to the kinematical limit, but dampened by a factor k^2 Q^2_ren/(pT^2 + k^2 Q^2_ren) , where Q_ren is the renormalization scale and k is a multiplicative fudge factor stored in pTdampFudge below. as option 1, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include t tbar and squark gluino production. as option 2, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include t tbar and squark gluino production. Note: These options only apply to the hard interaction. Specifically, a 'second hard' interaction would not be affected. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of the process itself."},{"name":"double Vec4::pAbs2()","link":"FourVectors.html#anchor22","text":"the (squared) absolute momentum."},{"name":"SUSY:idB","link":"SUSYProcesses.html#anchor3","text":"As for SUSY:idA , but requires an additional particle with PDG code SUSY:idB to be present in the 2 &rarr; 2 process. Thus, using SUSY:idA and SUSY:idB a specific subprocess can be selected. Again only the absolute sign is used, i.e. the summation over particle and antiparticle is retained. Also the order of SUSY:idA and SUSY:idB is irrelevant; since both possible orderings are checked for a match with the two outgoing particles. (Although not recommended, should SUSY:idA be zero and SUSY:idB nonzero a match is searched for just like in the normal case with SUSY:idA nonzero and SUSY:idB zero.)"},{"name":"ParticleData:maxEnhanceBW","link":"ParticleData.html#anchor2","text":"The modifications in options 2 and 4 above enhance the large-mass tail of the Breit-Wigner distributions (the mass spectrum develops a dm/m divergence). However, we expect form factors to dampen this tail at masses some distance above the nominal one, so cut off the rise by requiring the actual Breit-Wigner weight not to be more than a factor maxEnhanceBW above the one obtained with options 1 or 3, respectively. This also opens up for a simpler technical handling of mass selection in options 2 and 4, by using standard hit-and-miss Monte Carlo."},{"name":"StringFlav:mesonCvector","link":"FlavourSelection.html#anchor8","text":"the relative production ratio vector/pseudoscalar for charm mesons."},{"name":"POWHEG:pTdef","link":"POWHEGMerging.html#anchor7","text":"Use of pT definitions. The POWHEG ISR pT definition for both ISR and FSR. The POWHEG ISR pT and FSR d_ij definitions. The PYTHIA definitions."},{"name":"LHAupAlpgen::LHAupAlpgen(const char *baseFNin,  Info *infoPtrIn = NULL)","link":"AlpgenEventInterface.html#anchor6","text":"The constructor for the class takes the base filename for the ALPGEN format files (without file extensions) and optionally a pointer to a PYTHIA Info class, used for warning/error message printing and for storing the ALPGEN parameter file. The event and parameter files are opened immediately, with the AlpgenPar class, described below, used to parse the parameter file."},{"name":"ColourReconnection:lowerLambdaOnly","link":"ColourReconnection.html#anchor19","text":"Only allow overlaps that lowers the total string length."},{"name":"friend Hist operator*(double f, const HistAMPERSANDamp; h1)","link":"Histograms.html#anchor37","text":""},{"name":"virtual bool UserHooks::canVetoStep()","link":"UserHooks.html#anchor17","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoStep(...) will interrupt the downward ISR and FSR evolution the first numberVetoStep() times."},{"name":"friend Hist operator-(const HistAMPERSANDamp; h1, const Hist h2)","link":"Histograms.html#anchor36","text":"subtract a histogram from a constant, a constant from a histogram, or two histograms from each other, bin by bin."},{"name":"PromptPhoton:qqbar2ggamma","link":"ElectroweakProcesses.html#anchor3","text":"Scattering q qbar &rarr; g gamma. Code 202."},{"name":"HiddenValley:qqbar2SvSvbar","link":"HiddenValleyProcesses.html#anchor16","text":"Pair production q qbar &rarr; Sv Svbar via intermediate gluon. Code 4913."},{"name":"double Particle::m2()","link":"ParticleProperties.html#anchor37","text":"squared mass, which can be negative for spacelike partons."},{"name":"double Rndm::xexp()","link":"RandomNumbers.html#anchor7","text":"generate random numbers according to x exp(-x)."},{"name":"Beams:maxDevB","link":"BeamParameters.html#anchor28","text":"The triply Gaussian distribution (p_x, p_y, p_z) is restricted to a maximal total deviation from the nominal values (p_x0, p_y0, p_z0) , for the second incoming particle, like (p_x - p_x0)^2/sigma_px^2 + (p_y - p_y0)^2/sigma_py^2 + (p_z - p_z0)^2/sigma_pz^2 < maxDev^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick (p_x, p_y, p_z) .)"},{"name":"Beams:maxDevA","link":"BeamParameters.html#anchor24","text":"The triply Gaussian distribution (p_x, p_y, p_z) is restricted to a maximal total deviation from the nominal values (p_x0, p_y0, p_z0) for the first incoming particle, like (p_x - p_x0)^2/sigma_px^2 + (p_y - p_y0)^2/sigma_py^2 + (p_z - p_z0)^2/sigma_pz^2 < maxDev^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick (p_x, p_y, p_z) .)"},{"name":"HadronLevel:all","link":"MasterSwitches.html#anchor11","text":"If off then stop the generation after the hard process and parton-level activity has been generated, but before the hadron-level steps."},{"name":"bool LHAup::setNewEventLHEF(ifstreamAMPERSAND is)","link":"LesHouchesAccord.html#anchor76","text":"read in event information from the specified stream into a staging area where it can be reused by setOldEventLHEF."},{"name":"long Info::nSelected(int i = 0)","link":"EventInformation.html#anchor101","text":""},{"name":"SigmaProcess:bMassiveME","link":"SemiInternalProcesses.html#anchor2","text":"Let the b quark be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"double Info::mB()","link":"EventInformation.html#anchor9","text":"the masses of the two beam particles."},{"name":"int ParticleDataEntry::baryonNumberType(int id)","link":"ParticleDataScheme.html#anchor150","text":"is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a minus sign for antiparticles, and else zero. Only the sign of the input argument is relevant."},{"name":"virtual int TimeShower::showerQED( int iBeg, int iEnd,  EventAMPERSAND event, double pTmax)","link":"ImplementNewShowers.html#anchor8","text":"This is a further simplified version of the shower method above. Currently it only handles the emission of photons in the decay of a hadron into a pair of leptons, either a charged lepton-antilepton or a lepton-neutrino pair. It is properly matched to the matrix element in the decay via a virtual photon or W^+- , respectively. It is called as part of such decays if ParticleDecays:allowPhotonRadiation = on , which is not the default value."},{"name":"Beam Parameters","link":"BeamParameters.html","text":"Beam Parameters The settings on this page relate to the beam identities and energies, to a beam momentum spread and to a beam interaction spot. As always, momenta and energies are to be given in units of GeV, and of space and time in mm. Incoming beams The identities and energies of the two incoming beam particles should be specified using the settings in this section. Note that, if nothing is done, you will default to LHC at 14 TeV. Currently the beam particles must be either a hadron pair, a lepton pair, a photon pair, a lepton and a hadron or a photon and a hadron. In the first category p p and pbar p combinations dominate, but it is also possible to combine with pi^+ , pi^- and pi^0. In the second e^+ e^- and mu^+ mu^- would be the most useful combinations, but also others should work if combined with an appropriate hard process. Beam momentum spread This framework currently is intended for a modest beam spread, such as experienced at hadron colliders. Thus it can be safely assumed that the physics does not change over the CM energy range probed, so that the parameters of the physics initialization at the nominal energy can be used as is. Currently it can not be used for the more extensive energy spread expected at linear e^+ e^- colliders. Also, any attempt to combine it with external Les Houches input of parton-level events is at own risk. On this page you can set the momentum spread according to a simple Gaussian distribution. If you instead want a more sophisticated parametrization, you can write and link your own BeamShape class. Beam interaction vertex On this page you can set the spread of the interaction vertex according to a simple Gaussian distribution. If you instead want a more sophisticated parametrization, you can write and link your own BeamShape class. The distributions above are all centered at the origin. It is also possible to shift the above distributions to be centered around another nominal position. You must have Beams:allowVertexSpread = on to use this possibility."},{"name":"virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent)","link":"UserHooks.html#anchor34","text":"when called this method should provide the factor by which you want to see the phase space sampling of the current event modified. Events are assigned a weight being the inverse of this, such that the integrated cross section of a process is unchanged. Note that the selection is only modifiable for normal hard processes. It does not affect the selection in further multiparton interactions, nor in elastic/diffractive/minimum-bias events. : what makes this routine somewhat tricky to write is that the hard-process event has not yet been constructed, so one is restricted to use the information available in the phase-space and cross-section objects currently being accessed. Which of their  methods are applicable depends on the process, in particular the number of final-state particles. The biasSelectionBy code in UserHooks.cc contains explicit instructions about which methods provide meaningful information, and so offers a convenient starting point. : this flag is true when the method is called from within the event-generation machinery and false when it is called at the initialization stage of the run, when the cross section is explored to find a maximum for later Monte Carlo usage. Cross-section modifications should be independent of this flag, for consistency, but if biasSelectionBy(...) is used to collect statistics on the original kinematics distributions before cuts, then it is important to be able to exclude the initialization stage from comparisons."},{"name":"ExcitedFermion:qqbar2muStarmu","link":"CompositenessProcesses.html#anchor17","text":"Scatterings q qbar &rarr; mu^*+- mu^-+. Code 4033."},{"name":"SoftQCD:all","link":"QCDProcesses.html#anchor1","text":"Common switch for the group of all soft QCD processes, as listed separately in the following."},{"name":"Bottomonium:O(3S1)[1S0(8)]","link":"OniaProcesses.html#anchor49","text":"The colour-octet long-distance matrix elements <O[1S0(8)]> for the 3S1 bottomonium states."},{"name":"Charmonium:all","link":"OniaProcesses.html#anchor7","text":"Common switch for the group of charmonium production, e.g. J/psi and chi_c."},{"name":"SoftQCD:centralDiffractive","link":"QCDProcesses.html#anchor6","text":"Central diffractive scattering A B &rarr; A X B (a.k.a. double-Pomeron exchange, DPE). See pages on Total Cross Sections and on Diffraction for details. In particular note the SigmaTotal:zeroAXB flag, which is on in most tunes, meaning no central diffraction, and that therefore would need to be reset to off after the selection of a tune (even the default one) to get central diffraction. Code 106."},{"name":"double ParticleData::m0Min(int id)","link":"ParticleDataScheme.html#anchor47","text":"similar to mMin() above, except that for particles with no width the m0(id) value is returned."},{"name":"ExtraDimensionsUnpart:CutOffMode","link":"ExtraDimensionalProcesses.html#anchor85","text":"Options for when the hard scale of the process (e.g. sHat ) approaches or exceed the scale of validity of the low energy effective theory ( Lambda_U ). This mode only concerns the unparticle emission processes. Do nothing, i.e. all values of sHat contribute. Truncate contributing sHat region ( Ask09 )."},{"name":"int TimeShower::system()","link":"ImplementNewShowers.html#anchor17","text":"This method is not virtual. If a branching is constructed by the previous routine this tiny method should be able to return the number of the selected subsystem iSysSel where it occurred, so that the spacelike shower can be told which system to update, if necessary. Therefore iSysSel must be set in branch (or already in pTnext )."},{"name":"SigmaDiffractive:mResMax","link":"TotalCrossSections.html#anchor12","text":"The contribution of low-mass resonances is dampened at around the scale mHadron + mResMax (the sum is Mres in eq. (22) of Sch94 ). To make sense, we should have mResMax > mMin."},{"name":"SigmaTotal:sigmaXB","link":"TotalCrossSections.html#anchor6","text":"Single Diffractive cross section A + B &rarr; X + B in mb."},{"name":"int Info::nISR()","link":"EventInformation.html#anchor76","text":""},{"name":"void ParticleData::list(bool changedOnly = false,  bool changedRes = true)","link":"ParticleDataScheme.html#anchor16","text":"methods intended to present a listing of particle data in a readable format. The first two are special cases of the third. The first lists all particle data, the second only data for those particles that were changed after the original creation of the particle data table. Resonances are a special case since they can get their data changed by being linked to an object that does the calculation of branching ratios. By default the second method does not count such resonances as changed, whereas the third does and thus lists all resonances."},{"name":"Merging:unorderedScalePrescrip","link":"CKKWLMerging.html#anchor45","text":"When the parton shower history of the matrix element contains a sequence of splittings which are not ordered in evolution pT (called an unordered history), this sequence is interpreted as a combined emission. Then, a decision on which starting scale for trial emissions off reconstructed states in this sequence of unordered splittings has to be made. Two options are available: Use larger of the two reconstructed (unordered) scales as  starting scale. Use smaller of the two reconstructed (unordered) scales as  starting scale."},{"name":"bool ParticleData::hasChanged(int id)","link":"ParticleDataScheme.html#anchor62","text":"keep track of whether the data for a particle has been changed in any respect between initialization and the current status. Is used e.g. by the listChanged method to determine which particles to list."},{"name":"void Settings::forceMVec(string key,  vectorAMPERSANDlt;intAMPERSANDgt; now)","link":"SettingsScheme.html#anchor67","text":""},{"name":"HiggsH2:coup2W","link":"HiggsProcesses.html#anchor91","text":"The H^0(H_2^0) coupling to W^+-."},{"name":"HiggsH2:coup2Z","link":"HiggsProcesses.html#anchor90","text":"The H^0(H_2^0) coupling to Z^0."},{"name":"SigmaTotal:sigmaEl","link":"TotalCrossSections.html#anchor5","text":"Elastic cross section in mb."},{"name":"Print:quiet","link":"MasterSwitches.html#anchor16","text":"Can be set on to avoid the printing during program execution, to the largest extent possible. This flag acts by setting the relevant values for Init:showProcesses , Init:showMultipartonInteractions , Init:showChangedSettings , Init:showAllSettings , Init:showChangedParticleData , Init:showChangedResonanceData , Init:showAllParticleData , Init:showOneParticleData , Next:numberCount , Next:numberShowLHA , Next:numberShowInfo , Next:numberShowProcess , and Next:numberShowEvent. The change is to off or 0 for Print:quiet = off , and restores to the respective default value for = on. Those changes take effect immediately, so individual settings can be changed afterwards."},{"name":"HadronScatter:maxProbSS","link":"HadronScattering.html#anchor14","text":"The maximum probability P max SS for the  scattering of two hadrons within the same string. (Relative to that for  different strings, i.e. for the total probability the baseline maxProbDS factor also enters.)"},{"name":"ExtraDimensionsLED:n","link":"ExtraDimensionalProcesses.html#anchor60","text":"Number of extra dimensions."},{"name":"HiggsH2:coup2d","link":"HiggsProcesses.html#anchor87","text":"The H^0(H_2^0) coupling to down-type quarks."},{"name":"ExtraDimensionsLED:c","link":"ExtraDimensionalProcesses.html#anchor67","text":"Coupling related to scalar graviton emission."},{"name":"MultipartonInteractions:bSelScale","link":"MultipartonInteractions.html#anchor17","text":"The selection of impact parameter is related to the scale of the hard process: the harder this scale is, the more central the collision. In practice this centrality saturates quickly, however, and beyond a scale of roughly 20 GeV very little changes. (The relevant quantity is that the QCD jet cross section above the scale should be a tiny fraction of the total cross section.) In 2 &rarr; 1 and 2 &rarr; 2 processes traditional scale choices work fine, but ambiguities arise for higher multiplicities, in particular when the scale is used for matching between the multiparton matrix elements and parton showers. Then the event scale may be chosen as that of a very low- pT parton, i.e. suggesting a peripheral collision, while the much harder other partons instead would favour a central collision. Therefore the default here is to override whatever scale value have been read in from an LHEF, say. Notice that the scale used here is decoupled from the maximum scale for MPIs ( MultipartonInteractions:pTmaxMatch ). Use the mass for a 2 &rarr; 1 process. For 2 &rarr; n, n > 1 processes order the particles in falling mmT = m + mT and then let the scale be (mmT_1 + mmT_2)/2 + mmT_3/3 + mmT_4/4 + ... + mmT_n/n. This is constructed always to be above m1 , and to assign decreasing importance to softer particles that are less likely to be associated with the hard process. Use the scale parameter of the event. use the same scale as chosen by the rules for MultipartonInteractions:pTmaxMatch."},{"name":"ExtraDimensionsLED:g","link":"ExtraDimensionalProcesses.html#anchor66","text":"Coupling related to scalar graviton emission."},{"name":"SUSY:idA","link":"SUSYProcesses.html#anchor2","text":"Option to limit the sum over possible outgoing states in SUSY 2 &rarr; 2 processes to ones including a specific particle identity code. The default corresponds to summing over all possible indices. A non-zero value of SUSY:idA selects only processes that contain the state corresponding to that particular particle identity code in the fundamental 2 &rarr; 2 scattering process (summed over particle/antiparticle). It is the user's responsibility to ensure that (a subset of) the processes to be simulated actually include this particle at the 2 &rarr; 2 level; thus, asking for the lightest neutralino (code 1000021) to be present in a squark-squark production process will give no match."},{"name":"HiggsH2:coup2l","link":"HiggsProcesses.html#anchor89","text":"The H^0(H_2^0) coupling to (charged) leptons."},{"name":"void ParticleDataEntry::setName(string name)","link":"ParticleDataScheme.html#anchor99","text":""},{"name":"bool ParticleDataEntry::isBaryon()","link":"ParticleDataScheme.html#anchor147","text":"true for a baryon or antibaryon."},{"name":"HiggsH2:coup2u","link":"HiggsProcesses.html#anchor88","text":"The H^0(H_2^0) coupling to up-type quarks."},{"name":"virtual bool UserHooks::doReconnectResonanceSystems(  int oldSizeEvent, EventAMPERSAND event)","link":"UserHooks.html#anchor41","text":"can optionally be called, as described above, to reconnect colours in the event. The method should normally return true, but false if the colour-reconnected event is unphysical and to be rejected. (If this is likely to happen, having a safety copy to restore to is a good idea, so that false can be avoided to the largest extent possible.) the size of the event record before resonance decay products and their associated final-state showers have been added to the event. Can thus be used to easily separate the resonance-decay partons from those in the rest of the event. the event record contains a list of all particles generated so far. You are allowed to freely modify this record, but with freedom comes responsibility. Firstly, it is only meaningful to modify the colour indices of final-state (at the time) partons; all other event properties had better be left undisturbed. Secondly, it is up to you to ensure that the new colour topology is meaningful, e.g. that no gluon has obtained the same colour as anticolour index and thereby forms a singlet on its own."},{"name":"double Vec4::pNeg()","link":"FourVectors.html#anchor29","text":"the combinations E+-p_z."},{"name":"ExcitedFermion:qqbar2eStareStar","link":"CompositenessProcesses.html#anchor21","text":"Scatterings q qbar &rarr; e^*+- e^*-+. Code 4051."},{"name":"ExtraDimensionsLED:t","link":"ExtraDimensionalProcesses.html#anchor65","text":"Form factor parameter."},{"name":"Particle::Particle(const ParticleAMPERSAND pt)","link":"ParticleProperties.html#anchor119","text":"constructs an particle that is a copy of the input one."},{"name":"void Event::init(string headerIn = AMPERSANDquot;AMPERSANDquot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100)","link":"EventRecord.html#anchor19","text":"initializes colour, the pointer to the particle database, and the header specification used for the event listing. We remind that a Pythia object contains two event records process and event. Thus one may e.g. call either pythia.process.list() or pythia.event.list(). To distinguish those two rapidly at visual inspection, the 'Pythia Event Listing' header is printed out differently, in one case adding '(hard process)' and in the other '(complete event)'. When += is used to append an event, the modified event is printed with '(combination of several events)' as a reminder."},{"name":"TimeShower:dampenBeamRecoil","link":"TimelikeShowers.html#anchor18","text":"When beam recoil is allowed there is still some ambiguity how far into the beam end of the dipole that emission should be allowed. It is dampened in the beam region, but probably not enough. When on an additional suppression factor 4 pT2_hard / (4 pT2_hard + m2) is multiplied on to the emission probability. Here pT_hard is the transverse momentum of the radiating parton and m the off-shell mass it acquires by the branching, m2 = pT2/(z(1-z)). Note that m2 = 4 pT2_hard is the kinematical limit for a scattering at 90 degrees without beam recoil."},{"name":"bool Settings::flag(string key)","link":"SettingsScheme.html#anchor33","text":""},{"name":"void Settings::resetMode(string key)","link":"SettingsScheme.html#anchor70","text":""},{"name":"int Info::LHEFversion()","link":"EventInformation.html#anchor114","text":""},{"name":"Top:gg2ttbar","link":"TopProcesses.html#anchor2","text":"Scatterings g g &rarr; t tbar. Code 601."},{"name":"Diffraction:doHard","link":"Diffraction.html#anchor32","text":"Allows for the possibility to include hard diffraction tests in a run."},{"name":"int LHAup::strategy()","link":"LesHouchesAccord.html#anchor21","text":"for the strategy choice."},{"name":"Bottomonium:qg2bbbar(3DJ)[3PJ(8)]q","link":"OniaProcesses.html#anchor75","text":"Colour-octet production of 3DJ bottomonium states via q g &rarr; bbbar[3PJ(8)] q. Code 519."},{"name":"HiggsBSM:allH+-","link":"HiggsProcesses.html#anchor54","text":"Common switch for the group of H^+- production processes."},{"name":"void Pythia::initPtrs()","link":"ProgramFlow.html#anchor5","text":""},{"name":"StandardModel:Vtb","link":"StandardModelParameters.html#anchor15","text":"The V_tb CKM matrix element."},{"name":"virtual bool UserHooks::canVetoPartonLevelEarly()","link":"UserHooks.html#anchor12","text":"is very similar to canVetoPartonLevel() above, except that the chance to veto appears somewhat earlier in the generation chain, after showers and multiparton interactions, but before the beam remnants and resonance decays have been added. It is therefore somewhat more convenient for many matrix element strategies, where the primordial kT added along with the beam remnants should not be included."},{"name":"ParticleDecays:xBdMix","link":"ParticleDecays.html#anchor11","text":"The mixing parameter x_d = Delta(m_B^0)/Gamma_B^0 in the B^0 - B^0bar system. (Default from RPP2006.)"},{"name":"StandardModel:Vtd","link":"StandardModelParameters.html#anchor13","text":"The V_td CKM matrix element."},{"name":"virtual bool UserHooks::doVetoMPIStep(int nMPI,  const EventAMPERSAND event)","link":"UserHooks.html#anchor22","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of Pythia::next(). is the number of MPI subprocesses has occurred so far. the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', e.g. leftovers from the ISR and FSR evolution of previously generated systems. The most recently added one has not had time to radiate, of course."},{"name":"StandardModel:Vts","link":"StandardModelParameters.html#anchor14","text":"The V_ts CKM matrix element."},{"name":"Diffraction:mWidthPert","link":"Diffraction.html#anchor19","text":"The abovementioned threshold width m_width."},{"name":"MultipartonInteractions:deltaYRescatter","link":"MultipartonInteractions.html#anchor22","text":"used for some of the MultipartonInteractions:rescatterMode options above, as the width of the rapidity transition region, where the probability rises from zero to unity that a scattered parton is considered as a potential rescatterer."},{"name":"Particle Decays","link":"ParticleDecays.html","text":"Particle Decays The ParticleDecays class performs the sequential decays of all unstable hadrons produced in the string fragmentation stage, i.e. up to and including b hadrons and their decay products, such as the tau lepton. It is not to be used for the decay of more massive resonances , such as top, Z^0 or SUSY, where decays must be performed already at the ProcessLevel of the event generation. The decay description essentially copies the one present in PYTHIA since many years, but with some improvements, e.g. in the decay tables and the number of decay models available. Recently a more sophisticated handling of tau decays has also been introduced. Some issues may need further polishing. Variables determining whether a particle decays Before a particle is actually decayed, a number of checks are made. (i) Decay modes must have been defined for the particle kind; tested by the canDecay() method of Event (and ParticleData ). (ii) The main switch for allowing this particle kind to decay must be on; tested by the mayDecay() method of Event (and ParticleData ). By default this is defined as true for all particles with tau0 below 1000 mm, and false for ones above, see the Particle Data Scheme. This means that mu^+- , pi^+- , K^+- , K^0_L and n/nbar always remain stable unless decays are explicity switched on, e.g. 211:mayDecay  = true. (iii) Particles may be requested to have a nominal proper lifetime tau0 below a threshold. (iv) Particles may be requested to have an actual proper lifetime tau below a threshold. (v) Particles may be requested to decay within a given distance of the origin. (vi) Particles may be requested to decay within a given cylindrical volume around the origin. Mixing Tau decays Decays of tau leptons can be performed using helicity information from the tau production process and with the hadronic current of the tau decay modelled using form factors fit to data. The tau decay framework is largely based on the corresponding Herwig++ implementation Gre07 , with some input from Tauola Jad90. A short summary can be found in Ilt12 , while the complete writeup is in Ilt14. The decays of tau leptons are categorized as correlated , where a tau pair is produced from a single process, or uncorrelated , where only one tau is produced. Currently internally supported tau production mechanisms include correlated decays from gamma , Z^0 , Z'^0 , gamma^*/Z^0/Z'^0 , and Higgs bosons (CP-even, odd, or mixed) and uncorrelated decays from W^+- , W'^+- , B/D hadrons, and charged Higgs bosons. For all mechanisms except B/D hadrons, both the full process, e.g. q qbar &rarr; Z^0 &rarr; tau^+ tau^- , as well as just the decay of the boson with a given initial polarization, e.g. Z^0 &rarr; tau^+ tau^- , can be handled. The axial and vector couplings of the Z'^0 and W'^0 are set from the relevant parameters in New Gauge Boson Processes. Note that the CP of the various Higgs bosons can be set with the options HiggsX:parity , HiggsX:etaParity , and HiggsX:phiParity as described in Higgs Processes where X is either H1 , H2 , or A3. The tau polarization and tau decay correlation mechanism can be determined either using internal matrix elements or external SPINUP information provided in the event, e.g. via Les Houches Event Files (LHEF). For internal determination any tau pair or single tau from the processes of the previous list can be handeled. For external determination of a single uncorrelated tau , its polarization is set to its SPINUP information. When the SPINUP for the tau is not valid, e.g. when FSR is applied, the SPINUP for the first copy of that tau is used instead unless also invalid. For the external determination of a correlated tau pair the following options are available. A default behaviour is defined when the polarization and decay mechanism cannot be determined using either the internal or external methods. If the tau is known to be produced from a W^+- , gamma , or Z^0 , the tau or tau pair is assumed to be produced from an unpolarized boson of this type. If the mediator is unknown but there is a correlated tau pair, the pair is assumed to be produced from an unpolarized photon and a warning is issued. Finally, if the tau is uncorrelated, an unpolarized and uncorrelated decay is performed and a warning is issued. Both the internal and external determination have advantages and disadvantages. For example, if an LHEF Z^0 &rarr; tau^+ tau^- event is passed with SPINUP provided for both tau s but without SPINUP for the Z^0 then with TauDecays:externalTau set to 0 the decays of the tau s will be uncorrelated. Using 1 instead will result in correlations, assuming an unpolarized Z^0. If using internal determination, then the correlation and polarization will be fully calculated using the correct production mechanism for the Z^0. Consequently, a variety of options on how to determine polarization and correlation are available, with a sensible default in place which should catch most everything. QED radiation So far PYTHIA does not have any generic machinery for handling QED radiation in normal particle decays. In order to include this, a program like Photos Bar94, Dav10 could be used as an afterburner. In a few cases, however, the existing shower machinery can be used also here: for two-body decays to a lepton pair ( l^+ l^- or l^+- nu_l ). Such decays are mediated by gamma^*/Z^0/W^+- exchange, for which PYTHIA does have an existing machinery that can be applied, including first-order matrix-element corrections for the first (hardest) photon emission. Other variables When a decay mode is defined in terms of a partonic content, a random multiplicity (and a random flavour set) of hadrons is to be picked, especially for some charm and bottom decays. This is done according to a Poissonian distribution, for n_p normal particles and n_q quarks the average value is chosen as n_p/ 2 + n_q/4 + multIncrease * ln ( mDiff / multRefMass) with mDiff the difference between the decaying particle mass and the sum of the normal-particle masses and the constituent quark masses. For gluon systems multGoffset offers and optional additional term to the multiplicity. The lowest possible multiplicity is n_p + n_q/2 (but at least 2) and the highest possible 10. If the picked hadrons have a summed mass above that of the mother a new try is made, including a new multiplicity. These constraints imply that the actual average multiplicity does not quite agree with the formula above. Modes for Matrix Element Processing Some decays can be treated better than what pure phase space allows, by reweighting with appropriate matrix elements. In others a partonic content has to be converted to a set of hadrons. The presence of such corrections is signaled by a nonvanishing meMode() value for a decay mode in the particle data table. The list of allowed possibilities almost agrees with the PYTHIA 6 ones, but several obsolete choices have been removed, a few new introduced, and most have been moved for better consistency. Here is the list of currently allowed meMode() codes: 0 : pure phase space of produced particles ('default'); input of partons is allowed and then the partonic content is converted into the minimal number of hadrons (i.e. one per parton pair, but at least two particles in total) 1 : omega and phi &rarr; pi+ pi- pi0 2 : polarization in V &rarr; PS + PS ( V = vector, PS = pseudoscalar), when V is produced by PS &rarr; PS + V or PS &rarr; gamma + V 11 : Dalitz decay into one particle, in addition to the lepton pair (also allowed to specify a quark-antiquark pair that should collapse to a single hadron) 12 : Dalitz decay into two or more particles in addition to the lepton pair 13 : double Dalitz decay into two lepton pairs 21 : decay to phase space, but weight up neutrino_tau spectrum in tau decay 22 : weak decay; if there is a quark spectator system it collapses to one hadron; for leptonic/semileptonic decays the V-A matrix element is used, for hadronic decays simple phase space 23 : as 22, but require at least three particles in decay 31 : decays of type B &rarr; gamma X, very primitive simulation where X is given in terms of its flavour content, the X multiplicity is picked according to a geometrical distribution with average number 2, and the photon energy spectrum is weighted up relative to pure phase space 42 - 50 : turn partons into a random number of hadrons, picked according to a Poissonian with average value as described above, but at least code - 40 and at most 10, and then distribute then in pure phase space; make a new try with another multiplicity if the sum of daughter masses exceed the mother one 52 - 60 : as 42 - 50, with multiplicity between code - 50 and 10, but avoid already explicitly listed non-partonic channels 62 - 70 : as 42 - 50, but fixed multiplicity code - 60 72 - 80 : as 42 - 50, but fixed multiplicity code - 70, and avoid already explicitly listed non-partonic channels 91 : decay to q qbar or g g , which should shower and hadronize 92 : decay onium to g g g or g g gamma (with matrix element), which should shower and hadronize 100 - : reserved for the description of partial widths of resonances Three special decay product identity codes are defined. 81: remnant flavour. Used for weak decays of c and b hadrons, where the c or b quark decays and the other quarks are considered as a spectator remnant in this decay. In practice only used for baryons with multiple c and b quarks, which presumably would never be used, but have simple (copied) just-in-case decay tables. Assumed to be last decay product. 82: random flavour, picked by the standard fragmentation flavour machinery, used to start a sequence of hadrons, for matrix element codes in 41 - 80. Assumed to be first decay product, with -82 as second and last. Where multiplicity is free to be picked it is selected as for normal quarkonic systems. Currently unused. 83: as for 82, with matched pair 83, -83 of decay products. The difference is that here the pair is supposed to come from a closed gluon loop (e.g. eta_c &rarr; g g ) and so have a somewhat higher average multiplicity than the simple string assumed for 82, see the ParticleDecays:multGoffset parameter above."},{"name":"double Particle::px()","link":"ParticleProperties.html#anchor9","text":""},{"name":"bool Particle::canDecay()","link":"ParticleProperties.html#anchor79","text":"flag whether decay modes have been declared for a particle, so that it could be decayed, should that be requested."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Info::codesHard()","link":"EventInformation.html#anchor98","text":"returns a vector with all the process codes set up for the current run, i.e. the valid nonzero arguments for the five methods below."},{"name":"bool ParticleData::readString(string line,  bool warn = true)","link":"ParticleDataScheme.html#anchor13","text":"read in a string and interpret is as a new or changed particle data. The possibilities are extensively described above. It is normally used indirectly, via Pythia::readString(...) and Pythia::readFile(...). the string to be interpreted as an instruction. write a warning message or not whenever the instruction does not make sense, e.g. if the particle does not exist in the database. Note: the method returns false if it fails to make sense out of the input string."},{"name":"StringZ:aExtraSQuark","link":"Fragmentation.html#anchor3","text":"allows a larger a for s quarks, with total a = aLund + aExtraSQuark."},{"name":"HardQCD:qq2qqgDiff","link":"QCDProcesses.html#anchor26","text":"Scatterings q q' &rarr; q q' g , q qbar' &rarr; q qbar' g , and qbar qbar' &rarr; qbar qbar' g. Code 134."},{"name":"string ParticleDataEntry::name(int id = 1)","link":"ParticleDataScheme.html#anchor102","text":"set or get the particle or antiparticle name. Only the sign of id is needed to distinguish particle/antiparticle."},{"name":"LeftRightSymmmetry:lgm2HRtau","link":"LeftRightSymmetryProcesses.html#anchor13","text":"Scatterings l_i gamma &rarr; H_R^-- tau^+. Code 3144."},{"name":"SUSY:qq2antisquark","link":"SUSYProcesses.html#anchor23","text":"Resonant squark production via R-parity violating UDD couplings. The couplings must be input using the SLHA2 structure."},{"name":"double ParticleDataEntry::mMax()","link":"ParticleDataScheme.html#anchor117","text":"the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there."},{"name":"void ParticleDataEntry::setMMin(double mMin)","link":"ParticleDataScheme.html#anchor114","text":""},{"name":"ParticleDecays:colRearrange","link":"ParticleDecays.html#anchor24","text":"When a decay is given as a list of four partons to be turned into hadrons (primarily for modes 41 - 80)  it is assumed that they are listed in pairs, as a first and a second colour singlet, which could give rise to separate sets of hadrons. Here colRearrange is the probability that this original assignment is not respected, and default corresponds to no memory of this original colour topology."},{"name":"Program Flow","link":"ProgramFlow.html","text":"Program Flow Recall that, to first order, the event generation process can be subdivided into three stages: Initializaion. The event loop. Finishing. This is reflected in how the top-level Pythia class should be used in the user-supplied main program, further outlined in the following. Since the nature of the run is defined at the initialization stage, this is where most of the PYTHIA user code has to be written. So as not to confuse the reader unduly, the description of initialization options has been subdivided into what would normally be used and what is intended for more special applications. At the bottom of this webpage is a complete survey of all public Pythia methods and data members, in a more formal style than the task-oriented descriptions found in the preceding sections. This offers complementary information. Initialization - normal usage Already at the top of the main program file, you need to include the proper header file #include 'Pythia8/Pythia.h' To simplify typing, it also makes sense to declare using namespace Pythia8; The first step is to create a generator object, e.g. with Pythia pythia; It is this object that we will use from now on. Normally a run will only contain one Pythia object. (But you can use several Pythia objects, which then will be independent of each other.) By default all output from Pythia will be on the cout stream, but a few methods do allow output to alternative streams or files. You next want to set up the character of the run. The pages under the 'Setup Run Tasks' heading in the index describe all the options available (with some very few exceptions, found on the other pages). The default values and your modifications are stored in two databases, one for generic settings and one for particle data. Both of these are initialized with their default values by the Pythia constructor. The default values can then be changed, primarily by one of the two ways below, or by a combination of them. a) You can use the pythia.readString(string); method repeatedly to do a change of a property at a time. The information in the string is case-insensitive, but upper- and lowercase can be combined for clarity. The rules are that (i) if the first nonblank character of the string is a letter it is assumed to contain a setting, and is sent on to pythia.settings.readString(string) ; (ii) if instead the string begins with a digit it is assumed to contain particle data updates, and so sent on to pythia.particleData.readString(string) ; (iii) if none of the above, the string is assumed to be a comment, i.e. nothing will be done. In the former two cases, a warning is issued whenever a string cannot be recognized (maybe because of a spelling mistake). Some examples would be pythia.readString('TimeShower:pTmin = 1.0');    pythia.readString('111:mayDecay = false'); The readString(string) method is intended primarily for a few changes. It can also be useful if you want to construct a parser for input files that contain commands both to PYTHIA and to other libraries. b) You can read in a file containing a list of those variables you want to see changed, with a pythia.readFile(fileName); Each line in this file with be processes by the readString(string) method introduced above. You can thus freely mix comment lines and lines handed on to Settings or to ParticleData. This approach is better suited for more extensive changes than a direct usage of readString(string) , and can also avoid having to recompile and relink your main program between runs. It is also possible to read input from an istream , by default cin , rather than from a file. This may be convenient if information is generated on-the-fly, within the same run. Changes are made sequentially in the order the commands are encountered during execution, meaning that if a parameter is changed several times it is the last one that counts. The two special Tune:ee and Tune:pp modes are expanded to change several settings in one go, but these obey the same ordering rules. Next comes the initialization stage, where all remaining details of the generation are to be specified. There is one standard method to use for this pythia.init(); with no arguments will read all relevant information from the Settings and ParticleData databases. Specifically the setup of incoming beams and energies is governed by the the beam parameters from the Beams group of variables. If you don't change any of those you will default to proton-proton collisions at 14 TeV, i.e. the nominal LHC values. If you want to have a list of the generator and particle data used, either only what has been changed or everything, you can use pythia.settings.listChanged();    pythia.settings.listAll();    pythia.particleData.listChanged();    pythia.particleData.listAll(); The event loop Inside the event generation loop you generate the next event using the next() method, pythia.next(); This method takes no arguments; everything has already been specified. It does return a bool value, however, false when the generation failed. This can be a 'programmed death' when the supply of input parton-level configurations on file is exhausted. It can alternatively signal a failure of Pythia to generate an event, or unphysical features in the event record at the end of the generation step. It makes sense to allow a few false values before a run is aborted, so long as the related faulty events are skipped. The generated event is now stored in the event object, of type Event , which is a public member of pythia. You therefore have access to all the tools described on the pages under the 'Study Output' header in the index. For instance, an event can be listed with pythia.event.list() , the identity of the i 'th particle is given by pythia.event[i].id() , and so on. The hard process - roughly the information normally stored in the Les Houches Accord event record - is available as a second object, process , also of type Event. A third useful public object is info , which offers a set of one-of-a kind pieces of information about the most recent event. Finishing At the end of the generation process, you can call pythia.stat(); to get some run statistics, on cross sections and the number of errors and warnings encountered. Advanced usage, mainly for initialization A) Necessary data are automatically loaded when you use the default PYTHIA installation directory structure and run the main programs in the examples subdirectory. However, in the general case, you must provide the path of the xmldoc directory, where default settings and particle data are found. This can be done in several ways. You can set the environment variable PYTHIA8DATA to contain the location of the xmldoc directory. In the csh and tcsh shells this could e.g. be setenv PYTHIA8DATA /home/myname/pythia82xx/share/Pythia8/xmldoc while in other shells it could be export PYTHIA8DATA=/home/myname/pythia82xx/share/Pythia8/xmldoc where xx is the subversion number. Recall that environment variables set locally are only defined in the current instance of the shell. The above lines should go into your .cshrc and .bashrc files, respectively, if you want a more permanent assignment. You can provide the path as argument to the Pythia constructor, e.g. Pythia pythia('/home/myname/pythia82xx/share/Pythia8/xmldoc'); where again xx is the subversion number. When PYTHIA8DATA is set it takes precedence, else the path in the constructor is used, else one defaults to the ../share/Pythia8/xmldoc directory. You can provide references to existing Settings and ParticleData (useful if several identical copies of Pythia8 are constructed): Pythia(Settings& settingsIn, ParticleData& particleDataIn); You can take input from streams of Settings and ParticleData information (which requires the user to create the streams with the appropriate information): Pythia(istream& settingsStrings, istream& particleDataStrings); B) You can override the default behaviour of PYTHIA not only by the settings and particle data, but also by replacing some of the PYTHIA standard routines by ones of your own. Of course, this is only possible if your routines fit into the general PYTHIA framework. Therefore they must be coded according to the the rules relevant in each case, as a derived class of a PYTHIA base class, and a pointer to such an object must be handed in by one of the methods below. These calls must be made before the pythia.init() call. If you are not satisfied with the list of parton density functions that are implemented internally or available via the LHAPDF interface (see the PDF Selection page), you can supply your own by a call to the setPDFPtr(...) method pythia.setPDFptr( pdfAPtr, pdfBPtr); where pdfAPtr and pdfBPtr are pointers to two Pythia PDF objects. Note that pdfAPtr and pdfBPtr cannot point to the same object; even if the PDF set is the same, two copies are needed to keep track of two separate sets of x and density values. If you further wish to use separate PDF's for the hard process of an event than the ones being used for everything else, the extended form pythia.setPDFptr( pdfAPtr, pdfBPtr, pdfHardAPtr, pdfHardBPtr); allows you to specify those separately, and then the first two sets would only be used for the showers and for multiparton interactions. If you want to link to an external generator that feeds in events in the LHA format, you can call the setLHAupPtr(...) method pythia.setLHAupPtr( lhaUpPtr); where the lhaUpPtr derives from the LHAup base class. If you want to perform some particle decays with an external generator, you can call the setDecayPtr(...) method pythia.setDecayPtr( decayHandlePtr, particles); where the decayHandlePtr derives from the DecayHandler base class and particles is a vector of particle codes to be handled. If you want to use an external random number generator, you can call the setRndmEnginePtr(...) method pythia.setRndmEnginePtr( rndmEnginePtr); where rndmEnginePtr derives from the RndmEngine base class. The Pythia default random number generator is perfectly good, so this is only intended for consistency in bigger frameworks. If you want to interrupt the evolution at various stages, to interrogate the event and possibly veto it, or you want to reweight the cross section, you can use pythia.setUserHooksPtr( userHooksPtr); where userHooksPtr derives from the UserHooks base class. If you want to use your own merging scale definition for matrix element + parton shower merging, you can call pythia.setMergingHooksPtr( mergingHooksPtr); where mergingHooksPtr derives from the MergingHooks base class. If you want to use your own parametrization of beam momentum spread and interaction vertex, rather than the provided simple Gaussian parametrization (off by default), you can call pythia.setBeamShapePtr( beamShapePtr); where beamShapePtr derives from the BeamShape base class. If you want to implement a cross section of your own, you can use pythia.setSigmaPtr( sigmaPtr ); or, optionally, pythia.setSigmaPtr( sigmaPtr, phaseSpacePtr ); where sigmaPtr is of type SigmaProcess* and phaseSpacePtr is of type PhaseSpace*. When only the cross-section expression is provided, the built-in phase-space selection machinery will be used. Then sigmaPtr must be an instance of a class derived from one of the Sigma1Process , Sigma2Process and Sigma3Process classes for 1-, 2- and 3- particle production, in their turn derived from SigmaProcess. When you supply your own phase-space generator there is no fundamental limit on the complexity of the process. This call can be used repeatedly to hand in several different processes, mixing ones with and ones without their own phase-space generators. If your cross section contains the production of a new resonance with known analytical expression for all the relevant partial widths, you can make this resonance available to the program with pythia.setResonancePtr( resonancePtr); where resonancePtr of type ResonanceWidths* is an instance of a class derived from the ResonanceWidths base class. In addition you need to add the particle to the normal particle and decay database. This procedure can be used repeatedly to hand in several different resonances. If you are a real expert and want to replace the PYTHIA initial- and final-state showers , you can use pythia.setShowerPtr( timesDecPtr, timesPtr, spacePtr); where timesDecPtr and timesPtr derive from the TimeShower base class, and spacePtr from SpaceShower. C) Some comments on collecting several tasks in the same run. PYTHIA has not been written for threadsafe execution on multicore processors. If you want to use all cores, the most efficient way presumably is to start correspondingly many jobs, with different random number seeds, and add the statistics at the end. However, note that several instances  can be set up in the same main program, since instances are completely independent of each other, so each instance could be run inside a separate thread. In some cases it is convenient to use more than one Pythia object. The key example would be the simultaneous generation of signal and pileup events, see main19.cc. The two objects are then set up and initialized separately, and generate events completely independently of each other. It is only afterwards that the event records are combined into one single super-event per beam crossing. When time is not an issue, it may be that you want to perform several separate subruns sequentially inside a run, e.g. to combine results for several kinematical regions or to compare results for some different tunes of the underlying event. One way to go is to create (and destroy) one pythia object for each subrun, in which case they are completely separate. You can also use the same pythia object, only doing a new init() call for each subrun. In that case, the settings and particle databases remain as they were in the previous subrun, only affected by the specific changes you introduced in the meantime. You can put those changes in the main program, with pythia.readString(string) , using your own logic to decide which ones to execute in which subrun. A corresponding possibility exists with pythia.readFile(fileName, subrun) (or an istream instead of a fileName ), which as second argument can take a non-negative subrun number. Then only those sections of the file before any Main:subrun = ... line or with matching subrun number will be read. That is, the file could have a structure like ( lines always read, i.e. 'default values' always (re)set )    Main:subrun = 1    ( lines only read with readFile(fileName, 1) )    Main:subrun = 2    ( lines only read with readFile(fileName, 2) ) Both of these possibilities are illustrated in main08.cc. When working with Les Houches Event Files, it may well be that your intended input event sample is spread over several files, that you all want to turn into complete events in one and the same run. There is no problem with looping over several subruns, where each new subrun is initialized with a new file, with name set in Beams:LHEF. However, in that case you will do a complete re-initialization each time around. If you want to avoid this, note that the flag Beams:newLHEFsameInit = true can be set for the second and subsequent subruns. Then the new file will be simulated with the same initialization data as already set in a previous pythia.init() call. The burden rests on you to ensure that this is indeed correct, e.g. that the two event samples have not been generated for different beam energies. Also note that cross sections for processes will be based on the information in the first-read file, when the full initialization is performed. The Pythia Class Here follows the complete survey of all public Pythia methods and data members. Constructors and destructor Set up run Initialize At the initialization stage all the information provided above is processed, and the stage is set up for the subsequent generation of events. Currently only one init method is available for this stage. Generate events The next() method is the main one to generate events. In this section we also put a few other specialized methods that may be useful in some circumstances. Finalize There is no required finalization step; you can stop generating events when and how you want. It is still recommended that you make it a routine to call the following method at the end. A second method provides a deprecated alternative. Interrogate settings Normally settings are used in the setup and initialization stages to determine the character of a run, e.g. read from a file with the above-described Pythia::readFile(...) method. There is no strict need for a user to interact with the Settings database in any other way. However, as an option, some settings variables have been left free for the user to set in such a file, and then use in the main program to directly affect the performance of that program, see here. A typical example would be the number of events to generate. For such applications the following shortcuts to some Settings methods may be convenient. Get a PDF set Pythia contains an number of parton density sets internally, plus an interface to LHAPDF. With the method below, this machinery is also made available for external usage. Data members The Pythia class contains a few public data members, several of which play a central role. We list them here, with links to the places where they are further described."},{"name":"ParticleAMPERSAND Event::at(int i)","link":"EventRecord.html#anchor4","text":""},{"name":"SpaceShower:pTminChgL","link":"SpacelikeShowers.html#anchor18","text":"Parton shower cut-off mass for pure QED branchings. Assumed smaller than (or equal to) pTminChgQ."},{"name":"bool Particle::isNeutral()","link":"ParticleProperties.html#anchor69","text":"charge different from or equal to 0."},{"name":"virtual bool UserHooks::canVetoMPIStep()","link":"UserHooks.html#anchor20","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoMPIStep(...) will interrupt the downward MPI evolution the first numberVetoMPIStep() times."},{"name":"HadronScatter:Rmax","link":"HadronScattering.html#anchor6","text":""},{"name":"void Event::scaleSecond( double scaleSecondIn)","link":"EventRecord.html#anchor10","text":""},{"name":"SigmaProcess:cMassiveME","link":"SemiInternalProcesses.html#anchor1","text":"Let the c quark be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"double ParticleDataEntry::resWidthStore(int idSgn,  double mHat, int idInFlav = 0)","link":"ParticleDataScheme.html#anchor164","text":"special case of resWidth , where only open channels are included, and results are stored in the normal decay table."},{"name":"HiggsBSM:gg2A3g(l:t)","link":"HiggsProcesses.html#anchor78","text":"Scattering g g &rarr; A^0 g via loop contributions primarily from top. Code 1054."},{"name":"bool Settings::initPtr(Info* infoPtrIn)","link":"SettingsScheme.html#anchor2","text":"initialize pointer to error-message database. Internal."},{"name":"bool ParticleData::isParticle(int id)","link":"ParticleDataScheme.html#anchor25","text":"query whether the particle data table contains the particle of the identity code."},{"name":"double Info::s()","link":"EventInformation.html#anchor11","text":"the CM energy and its square for the two beams."},{"name":"SigmaElastic:lambda","link":"TotalCrossSections.html#anchor21","text":"the main parameter of the electric form factor G(t) = lambda^2 / (lambda + |t|)^2 , in units of GeV^2."},{"name":"Rndm::Rndm(int seed)","link":"RandomNumbers.html#anchor2","text":"construct a random number generator, and initialize it for the given seed number."},{"name":"WeakBosonAndParton:ffbar2Wgm","link":"ElectroweakProcesses.html#anchor29","text":"Scattering f fbar &rarr; W^+- gamma. Code 253."},{"name":"int MergingHooks::nMaxJets()","link":"CKKWLMerging.html#anchor18","text":"Return the maximum number of additional jets to be merged."},{"name":"double Particle::mMin()","link":"ParticleProperties.html#anchor73","text":""},{"name":"string ParticleData::name(int id)","link":"ParticleDataScheme.html#anchor31","text":"particle and antiparticle names are stored separately, the sign of id determines which of the two is returned, with void used to indicate the absence of an antiparticle."},{"name":"Top:all","link":"TopProcesses.html#anchor1","text":"Common switch for the group of top production."},{"name":"bool Pythia::readFile(istreamAMPERSAND inStream = cin,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor11","text":"reads in a whole file, where each line is interpreted as an instruction to modify the value of a setting or particle data , cf. the above readString method. All four forms of the readFile command share code for actually reading a file. the file from which instructions are read. an istream from which instructions are read. write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. In the command forms where warn is omitted it is true. allows you have several optional sets of commands within the same file. Only those sections of the file before any Main:subrun = ... line or following such a line with matching subrun number will be read. The subrun number should not be negative; negative codes like SUBRUNDEFAULT corresponds to no specific subrun. Note: the method returns false if it fails to make sense out of any one line."},{"name":"SUSY:idVecB","link":"SUSYProcesses.html#anchor5","text":"As for SUSY:idB , but as a vector of PDG codes. As above, to activate this, SUSY:idB must be equal to zero; if not then the match to SUSY:idB takes precedence. For the matching, either of SUSY:idA and SUSY:idVecA may be combined with either of SUSY:idB and SUSY:idVecB. As above one of the two outgoing SUSY particles must match one of the particles in SUSY:id(Vec)A and the other one of the particles in SUSY:id(Vec)B when both are nonzero. Character-string input of this vector  should be as a comma-separated list, without any blanks."},{"name":"HiggsBSM:gg2H1","link":"HiggsProcesses.html#anchor26","text":"Scattering g g &rarr; h^0(H_1^0) via loop contributions primarily from top. Code 1002."},{"name":"HiggsBSM:gg2H2","link":"HiggsProcesses.html#anchor36","text":"Scattering g g &rarr; H^0(H_2^0) via loop contributions primarily from top. Code 1022."},{"name":"bool ParticleData::isVisible(int id)","link":"ParticleDataScheme.html#anchor58","text":"a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector."},{"name":"PDF:lepton","link":"PDFSelection.html#anchor19","text":"Use parton densities for lepton beams or not. If off the colliding leptons carry the full beam energy, if on part of the energy is radiated away by initial-state photons. In the latter case the initial-state showers will generate the angles and energies of the set of photons that go with the collision. In addition one collinear photon per beam carries any leftover amount of energy not described by shower emissions. If the initial-state showers are switched off these collinear photons will carry the full radiated energy."},{"name":"virtual map AMPERSANDlt;string,doubleAMPERSANDgt; SpaceShower::getStateVariables(  const EventAMPERSAND event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor43","text":"This function should return a map of variables related to the splitting that produced the particles event[iRad] , event[iRec] and event[iEmt]. Four entries are compulsory, - the key t gives the evolution variable associated with the splitting, - the key tRS gives the evolution variable at which the shower should be restarted after a branching, - the key scaleAS gives the argument of &alpha; s used for the branching, and - the key scalePDF gives the argument of PDF factors used for the branching. All other entries are optional and may be auxiliary variables related to the splitting (e.g. an energy sharing variable, an azimuthal angle, kinematical invariants etc.). The identifier name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"POWHEG:vetoCount","link":"POWHEGMerging.html#anchor3","text":"After this many accepted emissions in a row, no more emissions are checked. Value 0 means that no emissions are checked. Using a very large value (e.g. 100000) will mean that all emissions are checked."},{"name":"bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0)","link":"ProgramFlow.html#anchor12","text":"offers the possibility to link in external PDF sets for usage inside the program. The rules for constructing your own class from the PDF base class are described here. pointers to two PDF -derived objects, one for each of the incoming beams. The two objects have to be instantiated by you in your program. Even if the two beam particles are the same (protons, say) two separate instances are required, since current information is cached in the objects. If both arguments are zero then any previous linkage to external PDF's is disconnected, see further Note 2 below. pointers to two further PDF -derived objects, one for each of the incoming beams. Normally only the first two arguments above would be used, and then the same PDF sets would be invoked everywhere. If you provide these two further pointers then two different sets of PDF's are used. This second set is then exclusively for the generation of the hard process from the process matrix elements library. The first set above is for everything else, notably parton showers and multiparton interactions. pointers to two further PDF -derived objects, one for each of the incoming beams. These define the pomeron PDFs used in hard diffraction. pointers to two further PDF -derived objects, one for each of the incoming beams. These define the photon PDFs when photons are emitted from lepton beams. With resolved photon beams some additional methods are required for initial state radiation and multiparton interactions and to sample valence content. pointers to two further PDF -derived objects, one for each of the incoming beams. As above, but now these are used for hard-process generation only, the parton showers and multiparton interactions uses the pdfGamAPtr and pdfGamBPtr PDFs. Unlike above, no additional methods are needed for these. pointers to two further PDF -derived objects, one for each of the incoming beams. Additional PDF pointers when the beam particle has also unresolved PDFs in addition to usual resolved one. Currently used only when mixing direct and resolved photon-initiated processes. pointers to two further PDF -derived objects, one for each of the incoming beams. Additional PDF pointers when having resolved and unresolved photons coming from lepton beams. Currently used only when mixing direct and resolved photon-initiated processes in lepton-lepton or lepton-hadron collisions. Note 1: The method returns false if the input is obviously incorrect, e.g. if two (nonzero) pointers agree. Note 2: If you want to combine several subruns you can call setPDFPtr with new arguments before each Pythia::init() call. To revert from external PDF's to the normal internal PDF selection you must call setPDFPtr(0, 0) before Pythia::init()."},{"name":"void Vec4::rescale3(double f)","link":"FourVectors.html#anchor59","text":"multiply the three-vector components by f , but keep the fourth component unchanged."},{"name":"ExtraDimensionsTEV:nMax","link":"ExtraDimensionalProcesses.html#anchor40","text":"The number of included KK excitations."},{"name":"bool ParticleDataEntry::useBreitWigner()","link":"ParticleDataScheme.html#anchor138","text":"tells whether a particle will have a Breit-Wigner mass distribution or not. Is determined by an internal logic based on the particle width and on the value of the ParticleData:modeBreitWigner switch."},{"name":"StringPT:widthPreStrange","link":"Fragmentation.html#anchor27","text":"Prefactor multiplying the Gaussian width for strange quarks."},{"name":"MultipartonInteractions:allowRescatter","link":"MultipartonInteractions.html#anchor18","text":"Switch to allow rescattering of partons; on/off = true/false. Note: the rescattering framework has not yet been implemented for the MultipartonInteractions:bProfile = 4 option, and can therefore not be switched on in that case. Warning: use with caution since machinery is still not so well tested."},{"name":"Photon:Wmax","link":"Photoproduction.html#anchor6","text":"Upper limit for invariant mass of gamma-gamma ( gamma-hadron ) system in GeV. A value below Photon:Wmin means that the invariant mass of the original l+l- ( lepton-hadron ) system is used as an upper limit."},{"name":"Vec4 Thrust::eventAxis(int i)","link":"EventAnalysis.html#anchor15","text":"gives the matching normalized event-axis vectors, for i = 1, 2 or 3 corresponding to thrust, major or minor, as a Vec4 with vanishing time/energy component."},{"name":"Merging:unorderedPDFscalePrescrip","link":"CKKWLMerging.html#anchor47","text":"Prescription which scale to use to evaluate ratios of parton distributions for splittings in a sequence of splittings which are not ordered in evolution pT. Use the combined splitting scale as argument in PDF ratios, for both splittings. Use the true reconstructed scale as argument in PDF ratios, for each splitting separately."},{"name":"void Settings::wvec(string key, vectorAMPERSANDlt;stringAMPERSANDgt; now,  bool force = false)","link":"SettingsScheme.html#anchor64","text":"change the current value(s) of the respective setting to the provided new value(s). If lower or upper limits have been set and force=false , input values outside the allowed range are reinterpreted as being at the nearest limit. If force = true , upper and lower limits will be ignored, allowing to force values outside the allowed range (to be used with caution and at own responsibility!). Any key not found in the settings database will be ignored, unless force = true , in which case the missing key will be added to the database with the given value."},{"name":"int AlpgenPar::getParamAsInt(const string AMPERSANDamp;paramIn)","link":"AlpgenEventInterface.html#anchor13","text":"Return the parameter with key paramIn as a double or integer. The presence of a parameter should have already been checked using the haveParam() function above. If the parameter is not present, 0 is returned."},{"name":"HadronScatter:maxProbDS","link":"HadronScattering.html#anchor10","text":"The maximum probability P max DS for the  scattering of two hadrons that are not part of the same string."},{"name":"SUSY Processes","link":"SUSYProcesses.html","text":"SUSY Here is collected processes involving supersymmetric particle production, with the exception of the (extended) Higgs sector. Since the number of separate but closely related processes is so big, there will not be switches for each separate process but only for a reasonable set of subgroups. However, the general switches SUSY:idA and SUSY:idB ,valternatively vectors SUSY:idVecA and SUSY:idVecB , may be used in conjunction with any of these groups to provide some additional flexibility to concentrate on processes involving only specific (s)particle final states, see below. Most of the SUSY implementation in PYTHIA 8 has been written by N. Desai and is documented in Des11. Please give due credit to external contributions to PYTHIA 8, such as this one, by including the original work in your list of references when using this implementation. The cross section formulae are mostly taken from Boz07 and Fuk11. Since the implementation of SUSY processes was only recently completed Des11 , case-by-case validations against other codes are still recommended. A set of default validations have already been carried out by the authors, comparing to the PYTHIA 6 SUSY implementation and to the XSUSY code, using an sps1a spectrum. Explicit validations of the non-trivial SLHA2-specific extensions have generally not been carried out yet, with the exception of the R-parity violating single-sparticle production cross sections. Please report the results of any user validations you may carry out to the authors. Important Note on SLHA: In order to simulate SUSY processes it is required to read in the couplings and masses relevant for the scenario to be studied. This is done with the help of the SUSY Les Houches Accord (SLHA), including the SLHA2 extensions and generalizations. (Internally, the SLHA2 conventions are used. SLHA1 spectra are automatically translated into SLHA2 notation during initialization.) The reading of a relevant SLHA file must be set up, as described on the SLHA page. Attempting to generate SUSY processes without a properly initialized SLHA spectrum is strongly discouraged and may lead to unexpected results. Always check for warnings and errors reported by the SLHA reader during the initialization stage. SUSY Processes Note 1: Decays of SUSY particles are described separately below. Note 2: One special possibility is that the gluino or some squark(s) are sufficiently long-lived to hadronize. See the R-hadrons page for further details. Note 3: lepton- and photon-initial states are not yet available. Only quark/gluon-initiated 2 &rarr; 2 and 2 &rarr; 1 (RPV) processes have been implemented. Note 4: cross sections will be correctly folded with open branching fractions of cascade decays, but at present any difference between particle and antiparticle decay tables is not taken into account. This possibility will be included in a future update. Gluino Pair Production Associated Squark-Gluino Production Squark Pair Production Neutralino and Chargino Pair Production Associated Neutralino/Chargino + Squark/Gluino Production Slepton Production R-parity violating squark production Decays of SUSY Particles Based on the parameters read in from the SLHA, PYTHIA 8 will normally compute the decay modes of SUSY particles automatically, using the SusyResonanceDecays class(es). Essentially all tree-level 2-body decays in the MSSM have been implemented this way, excepting so far only those involving Higgs bosons (either in the in- or out-state) or gravitinos. Available channels so far include: ~q &rarr; q + ~chi ~q &rarr; ~q + W/Z ~q &rarr; q + q (RPV UDD) ~q &rarr; l + q (RPV LQD) ~g &rarr; ~q + q ~chi &rarr; ~chi + Z/W ~chi &rarr; ~q + q ~chi &rarr; ~l/~nu + l/nu ~chi0 &rarr; q + q + q (RPV UDD) ~l/~nu &rarr; l/nu + ~chi ~l/~nu &rarr; ~l/~nu + W/Z All channels are still undergoing validation, so this implementation should be considered preliminary. Still missing but to be included in a forthcoming update are: 3-body decays of charginos (via RPV), and 2-body decays of squarks and gauginos with Higgs as one of the decay products.  Some 3-body decays have been implemented with Matrix Element weighting. In particular, those for a neutralino to a lighter neutralino and a fermion pair can be enabled."},{"name":"PhotonParton:ggm2bbbar","link":"ElectroweakProcesses.html#anchor41","text":"Scattering g gamma &rarr; b bbar. Code 273 (283)."},{"name":"bool writeFileXML(ostreamAMPERSAND os = cout)","link":"SettingsScheme.html#anchor9","text":"write out the information stored in xmldoc to be used later to initialize Settings through an input stream."},{"name":"ParticleData Pythia::particleData","link":"ProgramFlow.html#anchor40","text":"the particle properties and decay tables database, see here for further details."},{"name":"void RotBstMatrix::bst(const Vec4AMPERSAND p1, const Vec4AMPERSAND p2)","link":"FourVectors.html#anchor81","text":"boost so that p_1 is transformed to p_2. It is assumed that the two vectors obey p_1^2 = p_2^2."},{"name":"void ParticleDataEntry::setM0(double m0)","link":"ParticleDataScheme.html#anchor110","text":""},{"name":"ExtraDimensionsUnpart:dU","link":"ExtraDimensionalProcesses.html#anchor81","text":"Scale dimension parameter."},{"name":"LeftRightSymmmetry:ff2HLff","link":"LeftRightSymmetryProcesses.html#anchor8","text":"Scatterings f_1 f_2 &rarr; H_L^-- f_3 f_4 via WW fusion. Code 3125."},{"name":"LesHouches:setLeptonMass","link":"LesHouchesAccord.html#anchor71","text":"setting of mass for final-state charged leptons. The reason here is that some matrix-element generators assume leptons to be massless, so as to simplify calculations. This is particularly common for the e and mu leptons, but sometimes also the tau lepton is afflicted. Incoming leptons are not affected by this procedure. all lepton masses are taken from the Les Houches input. if the input lepton mass deviates by more than 10% from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. This should catch weird masses, while allowing sensible variations. each lepton mass is reset according to the PYTHIA value. Warning: when the mass is changed, also energy and/or momentum need to be shifted. This cannot be done for the lepton in isolation, but should be made so as to preserve the energy and momentum of the event as a whole. An attempt is therefore made to find another final-state particle recoiler that can transfer the appropriate amount of energy and momentum. The recoiler may be unstable, and if so the transfer is inherited by its decay products. The choice is straightforward if only two final-state particles exist, or in a two-body decay of an intermediate resonance, else a matching (anti)neutrino or (anti)lepton is searched for. These rules catch most of the standard cases for lepton production, such as gamma^*/Z^0/W^+- , but not necessarily all. Should they all fail the potential final-state recoiler with largest relative invariant mass is picked. In either case, if the transfer fails because the intended recoiler has too little energy to give up, then instead the energy is recalculated for the new mass without any transfer. The energy violation is partly compensated by changed energies for the incoming partons to the hard collision if LesHouches:matchInOut = on , but not always perfectly. One possibility then is to change the tolerance to such errors."},{"name":"WeakBosonAndParton:fgm2Wf","link":"ElectroweakProcesses.html#anchor30","text":"Scattering f gamma &rarr; W^+- f. Code 254."},{"name":"void DecayChannel::currentBR(double currentBR)","link":"ParticleDataScheme.html#anchor186","text":""},{"name":"int SlowJet::sizeOrig()","link":"EventAnalysis.html#anchor44","text":"gives the original number of particles (and thus clusters) that the analysis starts with."},{"name":"PhaseSpace:mHatMinSecond","link":"PhaseSpaceCuts.html#anchor15","text":"The minimum invariant mass for a second interaction, if separate."},{"name":"BeamRemnants:maxValQuark","link":"BeamRemnants.html#anchor11","text":"The maximum valence quark kind allowed in acceptable incoming beams, for which multiparton interactions are simulated. Default is that hadrons may contain u , d and s quarks, but not c and b ones, since sensible kinematics has not really been worked out for the latter."},{"name":"double DecayChannel::currentBR()","link":"ParticleDataScheme.html#anchor187","text":"set or get the current branching ratio, taking into account on/off switches and dynamic width for resonances. For internal use."},{"name":"Random-Number Seed","link":"RandomNumberSeed.html","text":"Random-Number Seed The seed of the random number generator can be set as follows: For more on random numbers see here. This includes methods to save and restore the state of the generator, and some preprogrammed methods to generate non-uniform random numbers."},{"name":"Bottomonium:qg2bbbar(3S1)[3S1(8)]q","link":"OniaProcesses.html#anchor53","text":"Colour-octet production of 3S1 bottomonium states via q g &rarr; bbbar[3S1(8)] q. Code 503."},{"name":"void Event::remove(int iFirst, int iLast,  bool shiftHistory = true)","link":"EventRecord.html#anchor23","text":"removes particles in the range between indices iFirst and iLast , including the endpoints. By default all mother and daughter indices above the removed range are shifted down by the number of removed entries, while indices in the removed range are put zero. Optionally these shifts can be omitted. Other information remains unchanged, which may lead to inconsistencies. If the decay products of a particle are removed, e.g., the mother particle status should be set positive, cf. Particle::undoDecay()."},{"name":"PhotonParton:ggm2ccbar","link":"ElectroweakProcesses.html#anchor40","text":"Scattering g gamma &rarr; c cbar. Code 272 (282)."},{"name":"int ParticleDataEntry::id()","link":"ParticleDataScheme.html#anchor97","text":"the PDG identity code."},{"name":"PhotonParton:all","link":"ElectroweakProcesses.html#anchor38","text":"Common switch for the processes 271-274 (also 281-284 when relevant)."},{"name":"void Vec4::reset()","link":"FourVectors.html#anchor5","text":"sets all components to 0."},{"name":"Diffraction:MBRepsilon","link":"Diffraction.html#anchor4","text":""},{"name":"Pythia8ToHepMC::Pythia8ToHepMC()","link":"HepMCInterface.html#anchor1","text":""},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; SlowJet::constituents(int i)","link":"EventAnalysis.html#anchor52","text":"gives a list of the indices of the particles that have been clustered into the i 'th jet,"},{"name":"StringFragmentation:eMinLeftJunction","link":"Fragmentation.html#anchor45","text":"Retry (up to 10 times) when the invariant mass-squared of the final leg and the leftover momentum of the first two treated legs falls below eMinLeftJunction times the energy of the final leg (in the junction rest frame)."},{"name":"Zprime:anue","link":"NewGaugeBosonProcesses.html#anchor11","text":"axial coupling of nu_e neutrinos."},{"name":"PromptPhoton:qg2qgamma","link":"ElectroweakProcesses.html#anchor2","text":"Scattering q g &rarr; q gamma. Code 201."},{"name":"void Particle::statusNeg()","link":"ParticleProperties.html#anchor24","text":"sets the status sign positive or negative, without changing the absolute value."},{"name":"Settings Pythia::settings","link":"ProgramFlow.html#anchor39","text":"the settings database, see here for further details."},{"name":"bool ParticleData::mayDecay(int id)","link":"ParticleDataScheme.html#anchor54","text":"a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for particle decays (or resonance decays ). All particles with tau0 below 1000 mm are by default initialized to allow decays."},{"name":"SigmaElastic:tAbsMin","link":"TotalCrossSections.html#anchor22","text":"since the Coulomb contribution is infinite a lower limit on |t| must be set to regularize the divergence, in units of GeV^2."},{"name":"MultipartonInteractions:bProfile","link":"MultipartonInteractions.html#anchor12","text":"Choice of impact parameter profile for the incoming hadron beams. no impact parameter dependence at all. a simple Gaussian matter distribution; no free parameters. a double Gaussian matter distribution, with the two free parameters coreRadius and coreFraction. an overlap function, i.e. the convolution of the matter distributions of the two incoming hadrons, of the form exp(- b^expPow) , where expPow is a free parameter. a Gaussian matter distribution with a width that varies according to the selected x value of an interaction, 1. + a1 log (1 / x) , where a1 is a free parameter. Note that once b has been selected for the hard process, it remains fixed for the remainder of the evolution. Also note that the machinery for a second hard process is not adapted to calculate the impact-parameter enhancement factor for this option."},{"name":"void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma)","link":"FourVectors.html#anchor67","text":"boost the four-momentum by beta = (beta_x, beta_y, beta_z) , where the gamma = 1/sqrt(1 - beta^2) is also input to allow better precision when beta is close to unity."},{"name":"ExcitedFermion:qqbar2nutauStarnutau","link":"CompositenessProcesses.html#anchor20","text":"Scatterings q qbar &rarr; nu_tau^* nu_taubar. Code 4036."},{"name":"void Particle::cols(int col, int acol)","link":"ParticleProperties.html#anchor28","text":"sets both colour and anticolour in one go."},{"name":"Vec4AMPERSAND Vec4::operator-=(const Vec4AMPERSAND v)","link":"FourVectors.html#anchor50","text":"subtract a four-vector from an existing one."},{"name":"double Particle::mT()","link":"ParticleProperties.html#anchor43","text":""},{"name":"HiggsBSM:gg2H2g(l:t)","link":"HiggsProcesses.html#anchor72","text":"Scattering g g &rarr; H^0 g via loop contributions primarily from top. Code 1034."},{"name":"void RotBstMatrix::rot(const Vec4AMPERSAND p)","link":"FourVectors.html#anchor77","text":"rotate so that a vector originally along the +z axis becomes parallel with p. More specifically, rotate by -phi , theta and phi , with angles defined by p."},{"name":"ProcessLevel:resonanceDecays","link":"MasterSwitches.html#anchor2","text":"Master switch to allow resonance decays; on/off = true/false. Normal hadrons and leptons do not count as resonances, so this is aimed specifically towards Z^0, W^+-, t, h^0 and similar objects beyond the Standard Model. Do not use this option if you may produce coloured resonances and intend to allow hadronization, since currently the program would not know how to handle this."},{"name":"double Info::enhanceMPIold()","link":"EventInformation.html#anchor96","text":""},{"name":"RHadrons:probGluinoball","link":"RHadrons.html#anchor8","text":"The fraction of produced gluino R-hadrons that are contain a 'valence' gluon, with the rest containing a meson or baryon quark flavour content."},{"name":"MultipartonInteractions:ecmPow","link":"MultipartonInteractions.html#anchor9","text":"The ecmPow energy rescaling pace introduced above."},{"name":"Merging:pTiMS","link":"CKKWLMerging.html#anchor11","text":"The value of the minimal transverse momentum cut pT i on final state partons, as used in the matrix element generation."},{"name":"HiggsH2:coup2H1Z","link":"HiggsProcesses.html#anchor95","text":"The H^0(H_2^0) coupling to a h^0(H_1^0) Z^0 pair. Vanishes in the MSSM."},{"name":"Pythia::Pythia(string xmlDir  = AMPERSANDquot;../share/Pythia8/xmldocAMPERSANDquot;, bool printBanner = true)","link":"ProgramFlow.html#anchor1","text":"creates an instance of the Pythia event generators, and sets initial default values, notably for all settings and particle data. You may use several Pythia instances in the same run; only when you want to access external static libraries could this cause problems. (This includes in particular Fortran libraries such as LHAPDF5 .) allows you to choose from which directory the default settings and particle data values are read in. If the PYTHIA8DATA environment variable has been set it takes precedence. Else this optional argument allows you to choose another directory location than the default one. Note that it is only the directory location you can change, its contents must be the ones of the xmldoc directory in the standard distribution. can be set false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia instances, where output needs to be restricted."},{"name":"ParticleAMPERSAND Event::back()","link":"EventRecord.html#anchor5","text":"returns a reference to the zeroth,"},{"name":"HiggsBSM:gg2H1ttbar","link":"HiggsProcesses.html#anchor32","text":"Scattering g g &rarr; h^0(H_1^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1008."},{"name":"TimeShower:pTmin","link":"TimelikeShowers.html#anchor12","text":"Parton shower cut-off pT for QCD emissions."},{"name":"int Particle::id()","link":"ParticleProperties.html#anchor1","text":"the identity of a particle, according to the PDG particle codes Yao06."},{"name":"void Settings::word(string key, string now,  bool force = false)","link":"SettingsScheme.html#anchor60","text":""},{"name":"PDF:piSetB","link":"PDFSelection.html#anchor8","text":"Parton density for pion beam B. If this option is set to void then the same PDF set as PDF:piSet is used."},{"name":"StringFlav:thetaPS","link":"FlavourSelection.html#anchor10","text":"gives the mixing angle theta_PS in the pseudoscalar meson sector (which is rather poorly determined), expressed in degrees. Here f is associated with eta' and f' with eta. (This standard but counterintuitive choice is fixed up in the code by replacing alpha &rarr; 90^0 - alpha so that eta &harr; eta' ; relative signs do not matter since we are interested in probabilities only.)"},{"name":"HiddenValley:qqbar2BvBvbar","link":"HiddenValleyProcesses.html#anchor18","text":"Pair production q qbar &rarr; Bv Bvbar via intermediate gluon. Code 4915."},{"name":"ParticleData:modeBreitWigner","link":"ParticleData.html#anchor1","text":"Selection of particle masses when the mSel(id) is called to provide a new mass: mass is fixed at the nominal m_0 value. particles registered as having a mass width are given a mass in the range m_min < m < m_max , according to a truncated nonrelativistic Breit-Wigner, i.e. linear in m. as above, except that the width is made mass-dependent: Gamma = Gamma_0 * sqrt( (m^2 - m_thr^2) / (m_0^2 - m_thr^2) ) where m is the current mass, m_0 the nominal one and m_thr is the mass threshold, given by the sum of the nominal masses of the decay products. In order to decouple production and decay the threshold is defined as the branching-ratio-weighted average over all allowed decay channels. particles registered as having a mass width are given a mass in the range m_min < m < m_max , according to a truncated relativistic Breit-Wigner, i.e. quadratic in m. as 3, but the width is modified as for 2, and the current mass is used for its phase-space prefactor, i.e. m_0 Gamma_0 &rarr; m Gamma(m). Note: this mode only applies to normal hadronic resonances like the rho. The more massive states of the isResonance() type, like Z^0 or top, are considered separately."},{"name":"ExcitedFermion:qqbar2tauStartau","link":"CompositenessProcesses.html#anchor19","text":"Scatterings q qbar &rarr; tau^*+- tau^-+. Code 4035."},{"name":"virtual bool TimeShower::isTimelike( const EventAMPERSAND event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor20","text":"This function should return true if the splitting that produced the particles event[iRad] , event[iRec] and event[iEmt] should be classified as timelike splittings (i.e. is handled by final state showers). The identifier name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"SpaceShower:pT0Ref","link":"SpacelikeShowers.html#anchor13","text":"Regularization of the divergence of the QCD emission probability for pT &rarr; 0 is obtained by a factor pT^2 / (pT0^2 + pT^2) , and by using an alpha_s(pT0^2 + pT^2). An energy dependence of the pT0 choice is introduced by the next two parameters, so that pT0Ref is the pT0 value for the reference cm energy, pT0Ref = pT0(ecmRef)."},{"name":"ColourReconnection:m2Lambda","link":"ColourReconnection.html#anchor15","text":"The m2Lambda parameter used in the definition of the approximate lambda measure above. It represents an approximate hadronic mass-square scale, cf. m0 in the previous model. Its value is uncertain up to factors of 2, but the lambda change induced by a potential move or flip is rather insensitive to the precise value, owing to large cancellations."},{"name":"virtual bool doVetoFragmentation(Particle had)","link":"UserHooks.html#anchor49","text":"This method can veto the production of a hadron, whereby the current string break is redone. is a (copy of) the hadron being produced, just before it is added to the event record."},{"name":"FourthBottom:qqbar2bPrimebPrimebar","link":"FourthGenerationProcesses.html#anchor3","text":"Scatterings q qbar &rarr; b' b'bar by gluon exchange. Code 802."},{"name":"bool Pythia::forceHadronLevel(bool findJunctions = true)","link":"ProgramFlow.html#anchor25","text":"hadronize the existing event record, i.e. perform string fragmentation and particle decays. There are two main applications. Firstly, you can use the same parton-level content as a basis for repeated hadronization attempts, in schemes intended to save computer time. Secondly, you may have an external program that can simulate the full partonic level of the event - hard process, parton showers, multiparton interactions, beam remnants, colour flow, and so on - but not hadronization. Further details are found here. normally this routine will search through the event record and try to figure out if any colour junctions are present. If so, the colour topology of such junctions must be sorted out. In tricky cases this might fail, and then hadronization will not work. A user who is aware of this and knows the intended colour flow can set up the junction information (if any) in the event record, and then call forceHadronLevel(false) so as not to have this information overwritten. (If the event record contains no unhadronized partons then no junction search will be performed in any case.) Note: The method returns false if the hadronization fails. The event record is then not consistent and should not be studied."},{"name":"Beams:sigmaPyA","link":"BeamParameters.html#anchor22","text":"The width of a Gaussian distribution of the p_y spread of the first incoming particle."},{"name":"Beams:sigmaPyB","link":"BeamParameters.html#anchor26","text":"The width of a Gaussian distribution of the p_y spread of the second incoming particle."},{"name":"double LHAup::xSecSum()","link":"LesHouchesAccord.html#anchor27","text":""},{"name":"double Info::pTnow()","link":"EventInformation.html#anchor82","text":"The current pT scale in the combined MPI, ISR and FSR evolution. Useful for classification in user hooks , but not once the event has been evolved."},{"name":"void ParticleDataEntry::initPtr(ParticleData*  particleDataPtrIn)","link":"ParticleDataScheme.html#anchor95","text":"initialize pointer back to the whole database (so that masses of decay products can be accessed, e.g.)."},{"name":"HardQCD:gg2gg","link":"QCDProcesses.html#anchor9","text":"Scatterings g g &rarr; g g. Code 111."},{"name":"string Info::nameSub()","link":"EventInformation.html#anchor27","text":""},{"name":"PartonLevel:MPI","link":"MasterSwitches.html#anchor4","text":"Master switch for multiparton interactions; on/off = true/false. Further options are found here."},{"name":"int Particle::colType()","link":"ParticleProperties.html#anchor70","text":"0 for colour singlets, 1 for triplets, -1 for antitriplets and 2 for octets. (A preliminary implementation of colour sextets also exists, using 3 for sextets and -3 for antisextets.)"},{"name":"Wprime:anglesWZ","link":"NewGaugeBosonProcesses.html#anchor45","text":"in the decay chain W'^+- &rarr; W^+- Z^0 &rarr;f_1 fbar_2 f_3 fbar_4 the decay angular distributions is taken to be a mixture of two possible shapes. This parameter gives the fraction that is distributed as in Higgs H^+- &rarr; W^+- Z^0 (longitudinal bosons), with the remainder (by default all) is taken to be the same as for W^+- &rarr; W^+- Z^0 (a mixture of transverse and longitudinal bosons)."},{"name":"Merging:doUMEPSSubt","link":"UMEPSMerging.html#anchor2","text":"Reweight events according to the UMEPS prescription of reweighted, integrated configurations. Please note that, in order for this to work smoothly, the switch Merging:doUMEPSTree has to be turned off."},{"name":"double m(const ParticleAMPERSAND pp1, const ParticleAMPERSAND pp2)","link":"ParticleProperties.html#anchor61","text":""},{"name":"Bottomonium:gg2bbbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor52","text":"Colour-octet production of 3S1 bottomonium states via g g &rarr; bbbar[3S1(8)] g. Code 502."},{"name":"HiggsH2:coup2A3H1","link":"HiggsProcesses.html#anchor96","text":"The H^0(H_2^0) coupling to an A^0(H_3^0) h^0(H_1^0) pair. Vanishes in the MSSM."},{"name":"double Info::xGammaA()","link":"EventInformation.html#anchor66","text":""},{"name":"LeptoQuark:all","link":"LeptoquarkProcesses.html#anchor1","text":"Common switch for the group of lowest-order LQ production processes, i.e. the four ones below."},{"name":"virtual bool LHAup::setInit()","link":"LesHouchesAccord.html#anchor4","text":"this pure virtual method has to be implemented in the derived class, to set relevant information when called. It should return false if it fails to set the info. In the no-beams extension this method need not do anything, since by default strategy 3 is chosen and the rest is set vanishing, but the method must exist."},{"name":"Charmonium:states(3S1)2","link":"OniaProcesses.html#anchor41","text":"The second 3S1 charmonium states of the charmonium pairs that can be produced from the following processes."},{"name":"HiggsBSM:qqbar2H1ttbar","link":"HiggsProcesses.html#anchor33","text":"Scattering q qbar &rarr; h^0(H_1^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1009."},{"name":"HiggsA3:coup2W","link":"HiggsProcesses.html#anchor104","text":"The A^0(H_3^0) coupling to W^+-. Vanishes in the MSSM."},{"name":"HiggsA3:coup2Z","link":"HiggsProcesses.html#anchor103","text":"The A^0(H_3^0) coupling to Z^0. Vanishes in the MSSM."},{"name":"virtual void SpaceShower::prepare( int iSys,  EventAMPERSAND event, bool limitPTmaxIn = true)","link":"ImplementNewShowers.html#anchor33","text":"This method is called immediately after a new interaction has been added, and should then be used to prepare the subsystem of partons for subsequent evolution. In the current code this involves identifying the colour and charge dipole ends: the position of radiating and recoiling partons, maximum pT scales, and possible higher-order matrix elements matchings to apply. Depending on what you have in mind you may choose to store slightly different quantities. You have to use the subsystem information described above to find the positions of the two incoming partons (and the outgoing ones) of the system, and from there the scales at which they were produced. The limitPTmax input agrees with the output of the previous method for the hardest process, and is always true for subsequent MPI, since there an unlimited pT for sure would lead to double-counting."},{"name":"A Python Interface","link":"PythonInterface.html","text":"A Python Interface Python is a powerful, high-level interpreted language that is widely used within the particle physics community. It is particularly useful as an interactive language that provides fast proto-typing of code. An experimental Python interface to PYTHIA is available. This interface has been generated using SWIG (Simplified Wrapper and Interface Generator). Please note that this interface has not been extensively tested and consequently issues may arise. If bugs are found or additional features are required, as usual, please report them to the PYTHIA authors. Features An attempt has been made to translate all PYTHIA classes and functions to the Python interface as directly as possible. The following features are included in the Python interface: The interface is compatible with Python version 2.1 and beyond, including 3.5 , the current version of Python. All PYTHIA classes and functions are available. See main01.py for a direct Python translation of the C++ main01.cc example. Most of the plugin classes are also available in the interface. See main34.py for a direct Python translation of the C++ main34.cc example which uses the LHAupMadgraph class from include/Pythia8Plugins/LHAMadgraph.h. When available, documentation through the built-in help function in Python is provided. Please note that this documentation is automatically generated, similar to the Doxygen documentation. Consequently, the inline Python documentation is not a replacement for this manual. All operators defined in C++, e.g. Vec4*double , as well as reverse operators, e.g. double*Vec4 , are available. Classes with defined [] operators are iterable, using standard Python iteration, e.g. for prt in pythia.event. Classes with a &lt&lt operator or a list function can be printed via the built-in print function in Python. Note this means that a string representation via str is also available for these classes in Python. Specific versions of templates needed by PYTHIA classes are available where the naming scheme is the template class name followed by its arguments (stripped of namespace specifiers); pointers to classes are prepended with Ptr. For example, vector&ltint&gt is available via the interface as VectorInt , map&ltstring, Mode&gt as MapStringMode , and vector&ltProcessContainer*&gt as VectorProcessContainerPtr. Derived classes in Python, for a subset of PYTHIA classes, can be passed back to PYTHIA. This is possible for all classes that can be passed to the Pythia class via the setXPtr functions and includes the following classes: BeamShape , DecayHandler , LHAup , MergingHooks , PDF , PhaseSpace , ResonanceWidths , RndmEngine , SigmaProcess , SpaceShower , TimeShower , and UserHooks. The protected functions and members of these classes are available through the Python interface. See main10.py for a direct Python translation of the C++ main10.cc example which uses a derived class from the UserHooks class to veto events. Limitations A variety of methods to interface C++ code with Python exist, each with its own advantages and disadvantages, some of which are being rapidly developed. Currently, for the purposes of an interface to PYTHIA, SWIG provides the best option. However, this may not remain the case, and the technical interface may be changed to some other method, e.g. cppyy , in the future. The Python interface to PYTHIA currently suffers the following limitations: In the CoupSUSY class all public members that are 3-by-3 arrays cannot be accessed, these include LsddX , LsuuX , LsduX , LsudX , LsvvX , LsllX , LsvlX , LslvX , as well as the equivalent R versions of these members. Additionally, rvLLE , rvLQD , and rvUDD cannot be accessed. In the MergingHooks class, the protected methods orderHistories , allowCutonRecState , and doWeakClustering with bool return values have been renamed as getOrderHistories , getAllowCutonRecState , and getDoWeakClustering , respectively, in the Python interface. The public headerStream , initStream , and eventStream members of the Writer class, used for writing LHEF output, cannot be accessed from the Python interface. For derived Python classes of the PYTHIA class LHAup , the protected member osLHEF cannot be accessed. The wrapper generated by SWIG is large (10 MB), and consequently the compile time can be significant. The only way to reduce the size of the wrapper is to remove functionality from the interface. Creating a derived Python class from a PYTHIA class, as described above in the features, is only possible for a subset of PYTHIA classes. However, if this feature is needed for specific classes, they can be added in the future upon request. This feature is not enabled by default for all classes to reduce the generated wrapper size. Python interfaces have not been generated for plugins within include/Pythia8Plugins which have direct external dependencies. This means there are no Python interfaces for any of the classes or functions defined in EvtGen.h , FastJet3.h , HepMC2.h , or LHAFortran.h. However, interfaces are available for all remaining plugins, including both LHAMadgraph.h and PowhegProcs.h. Installation To install the Python interface, both the python command, as well as the Python system header Python.h must be available. The directory containing the python command can be passed to the PYTHIA configuration via the option --with-python-bin , while the directory containing Python.h can be set with the option --with-python-include. An example configuration could be as follows, ./configure --with-python-include=/usr/include/python2.7 \    --with-python-bin=/usr/bin where the paths must be changed accordingly for the local system. If the location of Python.h is unknown, oftentimes the command python-config --includes will supply the correct path. Please note that the Python versions for the python command and Python.h header must match. This is of particular importance when compiling against Python 3. Many systems will provide the Python 3 command via python3 rather than python , so either a temporary alias should be made, or a soft link of the python3 command to python could also be made. However, take care, as many systems rely on Python 2 for things such as package managers, etc. Also note that if one wishes to utilize GZIP support (needed for the LHAupMadgraph plugin) then the option --with-gzip should also be provided. After configuring the Python interface for PYTHIA to be built and running make as usual, the following files should be generated in the directory lib. pythia8.py : the Python code for the interface. pythia8.pyc : the byte-compiled Python code for the interface. _pythia8.so : the C++ library needed for the interface. libpythia8.[so,dylib] : the standard shared PYTHIA library. To ensure that the pythia8.py module is available to Python, the system variable PYTHONPATH should be set similar to export PYTHONPATH=$(PREFIX_LIB):$PYTHONPATH where PREFIX_LIB is the directory lib which contains pythia8.py. Generally, the library paths should be set correctly, but it also may be necessary to set export LD_LIBRARY_PATH=$(PREFIX_LIB):$LD_LIBRARY_PATH where DYLD should be substituted for LD in OS X. Alternatively, it is also possible to define the Python path from within Python, as is done within the provided examples. Examples To use the Python interface for PYTHIA, start Python and import pythia8. The provided examples can be run by python mainXX.py where XX is the number of the example."},{"name":"Charmonium:O(3S1)[3P0(8)]","link":"OniaProcesses.html#anchor13","text":"The colour-octet long-distance matrix elements <O[3P0(8)]>/m_Q^2 for the 3S1 charmonium states. The remaining <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"StandardModel:Vud","link":"StandardModelParameters.html#anchor7","text":"The V_ud CKM matrix element."},{"name":"HiggsA3:coup2d","link":"HiggsProcesses.html#anchor98","text":"The A^0(H_3^0) coupling to down-type quarks."},{"name":"StandardModel:Vub","link":"StandardModelParameters.html#anchor9","text":"The V_ub CKM matrix element."},{"name":"bool LHAup::setInitLHEF(ifstreamAMPERSAND is,  bool readHeaders = false)","link":"LesHouchesAccord.html#anchor75","text":"read in and set all required initialization information from the specified stream. With second argument true it will also read and store header information, as described above. Return false if it fails."},{"name":"bool Pythia::init()","link":"ProgramFlow.html#anchor22","text":"initialize for collisions. The beams are not specified by input arguments, but instead by the settings in the Beam Parameters section. This allows the beams to be specified in the same file as other run instructions. The default settings give pp collisions at 14 TeV. Note: The method returns false if the initialization fails. It is then not possible to generate any events."},{"name":"HiggsA3:coup2l","link":"HiggsProcesses.html#anchor100","text":"The A^0(H_3^0) coupling to (charged) leptons."},{"name":"New-Gauge-Boson Processes","link":"NewGaugeBosonProcesses.html","text":"New-Gauge-Boson Processes This page contains the production of new Z'^0 and W'^+- gauge bosons, e.g. within the context of a new U(1) or SU(2) gauge group, and also a (rather speculative) horizontal gauge boson R^0. Left-right-symmetry scenarios also contain new gauge bosons, but are described separately. Z'^0 This group only contains one subprocess, with the full gamma^*/Z^0/Z'^0 interference structure for couplings to fermion pairs. It is possible to pick only a subset, e.g, only the pure Z'^0 piece. No higher-order processes are available explicitly, but the ISR showers contain automatic matching to the Z'^0 + 1 jet matrix elements, as for the corresponding &nbsp gamma^*/Z^0 process. The couplings of the Z'^0 to quarks and leptons can either be assumed universal, i.e. generation-independent, or not. In the former case eight numbers parametrize the vector and axial couplings of down-type quarks, up-type quarks, leptons and neutrinos, respectively. Depending on your assumed neutrino nature you may want to restrict your freedom in that sector, but no limitations are enforced by the program. The default corresponds to the same couplings as that of the Standard Model Z^0 , with axial couplings a_f = +-1 and vector couplings v_f = a_f - 4 e_f sin^2(theta_W) , with sin^2(theta_W) = 0.23. Without universality the same eight numbers have to be set separately also for the second and the third generation. The choice of fixed axial and vector couplings implies a resonance width that increases linearly with the Z'^0 mass. By a suitable choice of the parameters, it is possible to simulate just about any imaginable Z'^0 scenario, with full interference effects in cross sections and decay angular distributions and generation-dependent couplings; the default values should mainly be viewed as placeholders. The conversion from the coupling conventions in a set of different Z'^0 models in the literature to those used in PYTHIA is described in Cio08. Here are the couplings always valid for the first generation, and normally also for the second and third by trivial analogy: Here are the further couplings that are specific for a scenario with Zprime:universality switched off: The coupling to the decay channel Z'^0 &rarr; W^+ W^- is more model-dependent. By default it is therefore off, but can be switched on as follows. A massive Z'^0 is also likely to decay into Higgs bosons and potentially into other now unknown particles. Such possibilities clearly are quite model-dependent, and have not been included for now. Finally, to allow the exploration of more BSM physics scenarios, we include the possibility of the Z'^0 (and hence the gamma and Z^0 ) coupling to a fourth generation of fermions. This provides redundancy with and extensions beyond those processes implemented as fourth-generation processes. By default, the decay channels for the fourth-generation and not included. They are enabled using: Here are the further couplings that are specific for a scenario with Zprime:universality switched off: W'^+- The W'^+- implementation is less ambitious than the Z'^0. Specifically, while indirect detection of a Z'^0 through its interference contribution is a possible discovery channel in lepton colliders, there is no equally compelling case for W^+-/W'^+- interference effects being of importance for discovery, and such interference has therefore not been implemented for now. Related to this, a Z'^0 could appear on its own in a new U(1) group, while W'^+- would have to sit in a SU(2) group and thus have a Z'^0 partner that is likely to be found first. Only one process is implemented but, like for the W^+- , the ISR showers contain automatic matching to the W'^+- + 1 jet matrix elements. The couplings of the W'^+- are here assumed universal, i.e. the same for all generations. One may set vector and axial couplings freely, separately for the q qbar' and the l nu_l decay channels. The defaults correspond to the V - A structure and normalization of the Standard Model W^+- , but can be changed to simulate a wide selection of models. One limitation is that, for simplicity, the same Cabibbo--Kobayashi--Maskawa quark mixing matrix is assumed as for the standard W^+-. Depending on your assumed neutrino nature you may want to restrict your freedom in the lepton sector, but no limitations are enforced by the program. The coupling to the decay channel W'^+- &rarr; W^+- Z^0 is more model-dependent, like for Z'^0 &rarr; W^+ W^- described above. By default it is therefore off, but can be switched on as follows. Furthermore, we have left some amount of freedom in the choice of decay angular correlations in this channel, but obviously alternative shapes could be imagined. A massive W'^+- is also likely to decay into Higgs bosons and potentially into other now unknown particles. Such possibilities clearly are quite model-dependent, and have not been included for now. R^0 The R^0 boson (particle code 41) represents one possible scenario for a horizontal gauge boson, i.e. a gauge boson that couples between the generations, inducing processes like s dbar &rarr; R^0 &rarr; mu^- e^+. Experimental limits on flavour-changing neutral currents forces such a boson to be fairly heavy. In spite of being neutral the antiparticle is distinct from the particle: one carries a net positive generation number and the other a negative one. This particular model has no new parameters beyond the R^0 mass. Decays are assumed isotropic. For further details see Ben85."},{"name":"HiggsA3:coup2u","link":"HiggsProcesses.html#anchor99","text":"The A^0(H_3^0) coupling to up-type quarks."},{"name":"void Settings::resetAll()","link":"SettingsScheme.html#anchor16","text":"reset all current values to their defaults."},{"name":"StandardModel:Vus","link":"StandardModelParameters.html#anchor8","text":"The V_us CKM matrix element."},{"name":"TimeShower:nPartonsInBorn","link":"TimelikeShowers.html#anchor24","text":"The number of partons for Born-like phase space points. This number needs to be set if a different treatment of S-events (with Born-like kinematics) and H-events (with real-emission kinematics) is desired. This number has to be set if TimeShower:globalRecoilMode = 2."},{"name":"Beams:LHEF","link":"BeamParameters.html#anchor13","text":"The name of a Les Houches Event File, to be set if Beams:frameType = 4."},{"name":"friend double m2(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor34","text":"the (squared) invariant mass."},{"name":"StringFlav:thetaV","link":"FlavourSelection.html#anchor11","text":"gives the mixing angle theta_V in the vector meson sector (which is somewhat better determined), expressed in degrees. Here f is associated with omega and f' with phi."},{"name":"ExcitedFermion:qqbar2numuStarnumu","link":"CompositenessProcesses.html#anchor18","text":"Scatterings q qbar &rarr; nu_mu^* nu_mubar. Code 4034."},{"name":"HardQCD:qqbar2qqbarNew","link":"QCDProcesses.html#anchor14","text":"Scatterings q qbar &rarr; q' qbar' , where q' by default is a light quark ( u, d, s ) (see below). Code 116."},{"name":"vectorAMPERSANDlt;boolAMPERSANDgt; Settings::fvecDefault(string key)","link":"SettingsScheme.html#anchor45","text":""},{"name":"bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr)","link":"ProgramFlow.html#anchor15","text":"offers the possibility to link to an external random number generator. The rules for constructing your own class from the RndmEngine base class are described here. pointer to a RndmEngine -derived object. This object must be instantiated by you in your program. Note: The method returns true if the pointer is different from 0."},{"name":"ParticleDataEntry::~ParticleDataEntry","link":"ParticleDataScheme.html#anchor93","text":"the destructor is needed to delete any ResonanceWidths objects that have been created and linked to the respective particle."},{"name":"Merging:TMS","link":"CKKWLMerging.html#anchor5","text":"The value of the merging scale. The name is inspired by the scale in evolution equations, which is often called 't', and the suffix 'MS' stands for merging  scale.  In the particular case of kT -merging, this would be the value of the kT -cut  in GeV. For any merging scale definition, this input is considered the actual value of the merging scale."},{"name":"TauDecays:externalMode","link":"ParticleDecays.html#anchor13","text":"Choice of the external polarization and correlation mechanism for correlated tau pairs. all correlated pairs are treated as single uncorrelated tau leptons. Their polarization is still set via SPINUP. the mother of the tau pair is found. If the mother is from the list of available internal correlated processes, a correlated decay is performed. If the SPINUP for the mother is valid, this is used to set the mother polarization, otherwise the mother is assumed to be unpolarized. nothing is done. Note : option 1 has limited functionality as SPINUP is intended primarily for particles with 2 spin states. For massive vector bosons SPINUP is interpreted here as the transverse polarization and so the diagonal for the vector boson helicity density matrix is set as [(1 - SPINUP)/3, 1/3, (1 + SPINUP)/3]."},{"name":"JetMatching:nQmatch","link":"JetMatching.html#anchor23","text":"Controls the treatment of heavy quarks. All quarks (except top) are treated as light quarks for matching. Bottom quarks are treated separately.  Currently, they are unmatched."},{"name":"double CellJet::eT(i)","link":"EventAnalysis.html#anchor31","text":"gives the eT of the i 'th jet, where jets have been ordered with decreasing eT values,"},{"name":"Check:particleData","link":"ErrorChecks.html#anchor2","text":"Check the particle data tables for potential problems during initialization. This includes inconsistent use of charge in particle names, inconsistent setup of mass, mass range, width and lifetime, sum of branching ratios not unity (allowed but discouraged) or charge not conserved in a decay channel. Warnings should be viewed as reasons to check further, but need not indicate a true problem, and also not all problems may be caught. The pythia.particleData.checkTable(level) method, used for these checks, may also be called directly."},{"name":"Merging:incompleteScalePrescrip","link":"CKKWLMerging.html#anchor48","text":"When no complete parton shower history (i.e. starting from a 2 &rarr; 2 process)  for a matrix element with additional jets can be found, such a configuration is said to have an incomplete history. Since in incomplete histories, not all  shower starting scales are determined by clusterings, a prescription for setting the starting scale of trial showers in incomplete histories is needed. Three options are provided. Use factorisation scale as shower starting scale for  incomplete histories. Use sHat as shower starting scale for incomplete histories. Use s as shower starting scale for incomplete histories."},{"name":"double CellJet::phiWeighted(int i)","link":"EventAnalysis.html#anchor35","text":"gives the eta and phi coordinates of the eT -weighted center of the i 'th jet,"},{"name":"Vec4 BeamShape::deltaPB()","link":"BeamShape.html#anchor6","text":"read out the three-momentum shifts for beams A and B that were set by pick(). The energy components are put to zero at this stage, since they are most conveniently calculated after the original and the shift three-momenta have been added."},{"name":"void LHAupHelaconia::setEvents(int events)","link":"HelacOniaProcesses.html#anchor3","text":"the number of events to generate per HelacOnia run. Normally does not need to be set, but defaults to 10000."},{"name":"bool ParticleData::isGluon(int id)","link":"ParticleDataScheme.html#anchor70","text":"true for a gluon."},{"name":"string Info::getEventAttribute(string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor129","text":"return the value of the event attribute named key. Setting doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named key does not exist."},{"name":"bool LHAup::openLHEF(string filename)","link":"LesHouchesAccord.html#anchor85","text":"Opens a file with the filename indicated, and writes a header plus a brief comment with date and time information."},{"name":"SecondHard:PhotonAndJet","link":"ASecondHardProcess.html#anchor3","text":"A prompt photon recoiling against a quark or gluon jet."},{"name":"Merging:allowIncompleteHistoriesInReal","link":"NLOMerging.html#anchor17","text":"If switched on, this will allow to keep states with incomplete parton shower histories (i.e. states that cannot be projected onto an allowed underlying Born process) in the real contributions of an NLO input sample. By default, such configurations will instead be included through higher-multiplicity tree-level matrix elements. However, NLO input samples can contain a significant number of such configurations if Diagram Subtraction (DS) techniques had been applied. In order not to change the DS scheme, it is important not to remove incomplete histories from the real-emission contribution. Note that furthermore, if this switch turned on, you will have to ensure yourself that no double-counting between states with incomplete histories will occur between NLO samples and higher-multiplicity tree-level samples. This might for example entail using the MergingHooks facilities, and the function double MergingHooks::dampenIfFailCuts(const Event& event)' in particular."},{"name":"friend Vec4 operator*(double f, const Vec4AMPERSAND v)","link":"FourVectors.html#anchor55","text":""},{"name":"bool ParticleData::doForceWidth(int id)","link":"ParticleDataScheme.html#anchor60","text":"a flag applicable only for resonances (see isResonance above), whereby it is possible to force resonances to retain their assigned widths, whatever that is, see Resonance Decays for details. The normal behaviour is false , i.e. the width is based on hardcoded calculations whenever available."},{"name":"virtual bool UserHooks::canVetoResonanceDecays()","link":"UserHooks.html#anchor36","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoResonanceDecays(...) will be called immediately after the resonance decays have been selected and stored in the process event record, as described above for canVetoProcessLevel()."},{"name":"double Vec4::pz()","link":"FourVectors.html#anchor14","text":""},{"name":"LeftRightSymmmetry:ffbar2HRHR","link":"LeftRightSymmetryProcesses.html#anchor15","text":"Scatterings f fbar &rarr;  H_R^++ H_R^--. Code 3146."},{"name":"friend Hist operator/(const HistAMPERSANDamp; h1, double f)","link":"Histograms.html#anchor41","text":""},{"name":"bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn)","link":"ProgramFlow.html#anchor13","text":"offers linkage to an external generator that feeds in events in the LHA format, see Les Houches Accord , assuming that Beams:frameType = 5 has been set. pointer to a LHAup -derived object. Note: The method currently always returns true."},{"name":"bool Pythia::moreDecays()","link":"ProgramFlow.html#anchor26","text":"perform decays of all particles in the event record that have not been decayed but should have been done so. This can be used e.g. for repeated decay attempts, in schemes intended to save computer time. Further details are found here. Note: The method returns false if the decays fail. The event record is then not consistent and should not be studied."},{"name":"SpaceShower:pTminWeak","link":"SpacelikeShowers.html#anchor23","text":"Parton shower cut-off pT for weak branchings."},{"name":"HiggsH1:phiParity","link":"HiggsProcesses.html#anchor113","text":"The phi value of CP-mixing in the HiggsH1:parity = 4 option."},{"name":"double Info::pTmaxISR()","link":"EventInformation.html#anchor80","text":""},{"name":"ExtraDimensionsLED:gg2gammagamma","link":"ExtraDimensionalProcesses.html#anchor49","text":"Scatterings g g &rarr; (LED G*) &rarr; gamma gamma. Code 5027."},{"name":"Bottomonium:O(3PJ)[3S1(8)]","link":"OniaProcesses.html#anchor63","text":"The color-singlet long-distance matrix elements <O[3S1(8)]> for the 3PJ bottomonium states."},{"name":"ExcitedFermion:mugm2muStar","link":"CompositenessProcesses.html#anchor8","text":"Scatterings mu gamma &rarr; mu^*. Code 4013."},{"name":"SigmaProcess:alphaSorder","link":"CouplingsAndScales.html#anchor2","text":"Order at which alpha_strong runs, zeroth order, i.e. alpha_strong is kept fixed. first order, which is the normal value. second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"ExcitedFermion:qqbar2nueStarnueStar","link":"CompositenessProcesses.html#anchor22","text":"Scatterings q qbar &rarr; nu_e^* nu_e^*bar. Code 4052."},{"name":"LeftRightSymmmetry:lgm2HLe","link":"LeftRightSymmetryProcesses.html#anchor5","text":"Scatterings l_i gamma &rarr; H_L^-- e^+. Code 3122."},{"name":"HardQCD:qqbar2ggg","link":"QCDProcesses.html#anchor24","text":"Scatterings q qbar &rarr; g g g. Code 132."},{"name":"BeamRemnants:reducedKTatHighY","link":"BeamRemnants.html#anchor6","text":"For a system of mass m and energy E the dampening factor y_damp above is defined as y_damp = pow( E/m, r_red) , where r_red is the current parameter. The effect is to reduce the primordial kT of low-mass systems extra much if they are at large rapidities (recall that E/m = cosh(y) before kT is added). The reason for this dampening is purely technical, and for reasonable values should not have dramatic consequences overall."},{"name":"BoseEinstein:Pion","link":"BoseEinsteinEffects.html#anchor1","text":"Include effects or not for identical pi^+ , pi^- and pi^0."},{"name":"StringPT:expNSP","link":"Fragmentation.html#anchor34","text":"Exponent for the number of effective nearby string pieces, calculated as N(NSP) =1 + (N string -1)/(1+p 2 T had /    p 2 T 0 ) , where p 2 T had is the transverse momentum of the next produced hadron, estimated based on an educated guess of its momentum, and p 2 T 0 is the MPI regularization parameter MultipartonInteractions:pT0Ref. The width/temperature will get the prefactor N(NSP)^expNSP."},{"name":"friend double RRapPhi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor44","text":""},{"name":"SigmaElastic:rho","link":"TotalCrossSections.html#anchor20","text":"the ratio of the real to the imaginary parts of the nuclear scattering amplitude."},{"name":"LeftRightSymmmetry:coupHee","link":"LeftRightSymmetryProcesses.html#anchor19","text":"Yukawa coupling for H^-- &rarr; e- e-."},{"name":"bool Pythia8ToHepMC::fill_next_event( Pythia8::EventAMPERSAND pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1)","link":"HepMCInterface.html#anchor4","text":"convert a Pythia event to a HepMC one. Will return true if succeeded. the input Pythia event that is to be converted to HepMC format. the output GenEvt event, in its standard form. set the event number of the current event. If negative then the internal event number is used, which is incremented by one for each new event. pointer to the Pythia Info object, which is used to extract PFD values, and process and cross section information. Without such a pointer this information therefore cannot be stored, i.e. it is equivalent to the three set_store methods below being set false. pointer to the Pythia Settings object, which is used to decide whether hadronization is carried out, and therefore whether to warn about unhadronized partons. Without such a pointer the set_free_parton_warnings method below uniquely controls the behaviour. if true then the input event is appended to the current HepMC event record, rather than starting a new one. the root particle that defines the new production vertex for the particles to be added in the append = true option. used to set the bar code when append = true. If positive then start from iBarcode itself, if negative then start from the current size of the HepMC event record, and if 0 then set all bar codes to vanish."},{"name":"LeftRightSymmmetry:ffbar2HLHL","link":"LeftRightSymmetryProcesses.html#anchor9","text":"Scatterings f fbar &rarr;  H_L^++ H_L^--. Code 3126."},{"name":"PhotonParton:ggm2qqbar","link":"ElectroweakProcesses.html#anchor39","text":"Scattering g gamma &rarr; q qbar , where q is a light quark ( u, d, s ). Code 271 (281)."},{"name":"HiggsBSM:qqbar2H1g(l:t)","link":"HiggsProcesses.html#anchor68","text":"Scattering q qbar &rarr; h^0 g via an s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from g g &rarr; h^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1016."},{"name":"friend double cosphi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2,  const Vec4AMPERSAND v3)","link":"FourVectors.html#anchor43","text":"the (cosine) of the azimuthal angle between the first two vectors around the direction of the third, in the range 0 through pi."},{"name":"HardQCD:hardccbar","link":"QCDProcesses.html#anchor18","text":"Sum of the previous two event types. Codes 121 and 122."},{"name":"void Thrust::list()","link":"EventAnalysis.html#anchor16","text":"provides a listing of the above information."},{"name":"void ParticleData::hasChanged(int id, bool hasChanged)","link":"ParticleDataScheme.html#anchor61","text":""},{"name":"HiddenValley:ffbar2EvEvbar","link":"HiddenValleyProcesses.html#anchor26","text":"Pair production f fbar &rarr; Ev Evbar via intermediate gamma*/Z^*. Code 4931."},{"name":"void Particle::bstback(const Vec4AMPERSAND pBst, double mBst)","link":"ParticleProperties.html#anchor112","text":"as above, but with sign of boost flipped."},{"name":"ColourReconnection:allowJunctions","link":"ColourReconnection.html#anchor10","text":"This switch disables the formation of junctions in the colour reconnection."},{"name":"ColourReconnection:rHadron","link":"ColourReconnection.html#anchor23","text":"Width of the type I string in reconnection calculations, in fm, giving the radius of the Gaussian distribution in x and y separately."},{"name":"Bottomonium:O(3S1)[3S1(1)]2","link":"OniaProcesses.html#anchor80","text":"The color-singlet long-distance matrix elements <O[3S1(1)]> for the second 3S1 bottomonium states."},{"name":"FourthPair:ffbar2tPrimebPrimebar(s:W)","link":"FourthGenerationProcesses.html#anchor14","text":"Scatterings f fbar' &rarr; t' b'bar by s -channel exchange of a W^+- boson. Code 841."},{"name":"BeamRemnants:remnantMode","link":"BeamRemnants.html#anchor9","text":"Switch to choose between the two different colour models for the beam remnant. The old beam remnant model. The new beam remnant model."},{"name":"ExcitedFermion:qqbar2eStare","link":"CompositenessProcesses.html#anchor15","text":"Scatterings q qbar &rarr; e^*+- e^-+. Code 4031."},{"name":"double CellJet::etaWeighted(int i)","link":"EventAnalysis.html#anchor34","text":""},{"name":"HardQCD:gg2ccbar","link":"QCDProcesses.html#anchor16","text":"Scatterings g g &rarr; c cbar. Code 121."},{"name":"ParticleDataEntry::ParticleDataEntry(int id = 0,  string name = AMPERSANDquot; AMPERSANDquot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor90","text":""},{"name":"bool TimeShower::getHasWeaklyRadiated()","link":"ImplementNewShowers.html#anchor18","text":"This method is not virtual. It is used to tell whether a weak gauge boson has been emitted in the shower evolution."},{"name":"SpaceShower:QEDshowerByQ","link":"SpacelikeShowers.html#anchor25","text":"Allow quarks to radiate photons; on/off = true/false."},{"name":"virtual double TimeShower::pTnext( EventAMPERSAND event,  double pTbegAll, double pTendAll, bool isFirstTrial = false)","link":"ImplementNewShowers.html#anchor14","text":"This is the main driver routine for the downwards evolution. A new pT is to be selected based on the current information set up by the routines above, and along with that a branching parton or dipole. The pTbegAll scale is the maximum scale allowed, from which the downwards evolution should be begun (usually respecting the maximum scale of each individual parton). If no emission is found above pTendAll (and above the respective shower cutoff scales) then 0. should be returned and no emissions will be allowed. Both scales can vary from one event to the next: if a scale has already been selected for MPI or ISR it makes no sense to look for a scale smaller than that from FSR, since it would not be able to compete, so pTendAll is set correspondingly. As it happens, FSR is tried before ISR and MPI in the interleaved evolution, but this is an implementation detail that could well change. Typically the implementation of this routine would be to set up a loop over all possible radiating objects (dipoles, dipole ends, ...), for each pick its possible branching scale and then pick the one with largest scale as possible winner. At this stage no branching should actually be carried out, since MPI, ISR and FSR still have to be compared to assign the winner. The isFirstTrial is true only for the very first emission, and is currently used in the global recoil option."},{"name":"Main:spareWord3","link":"MainProgramSettings.html#anchor39","text":""},{"name":"Main:spareWord2","link":"MainProgramSettings.html#anchor38","text":""},{"name":"Main:spareWord1","link":"MainProgramSettings.html#anchor37","text":""},{"name":"SecondHard:SingleTop","link":"ASecondHardProcess.html#anchor12","text":"Production of a single top, either via a t- or an s- channel W^+- resonance."},{"name":"int MergingHooks::nHardOutPartons()","link":"CKKWLMerging.html#anchor19","text":"Returns the number of outgoing partons in the hard core process."},{"name":"ColourReconnection:timeDilationMode","link":"ColourReconnection.html#anchor13","text":"Disallow colour reconnection between strings that are not in causal contact; if either string has already decayed before the other string forms, there is no space-time region in which the reconnection could physically occur. The exact defintion of causal contact is not known, hence several possible defintions are included. They all include the boost factor, gamma , and the majority also rely on the typical hadronization scale, r , which is kept fixed at 1 fm. A tuneable dimensionless parameter is included, which can be used to control the overall amount of colour reconnection. All strings are allowed to reconnect. Strings are allowed to reconnect if gamma &lt timeDilationPar and all strings should be causally connected to allow a reconnection. Strings are allowed to reconnect if gamma &lt timeDilationPar * mDip * r and all strings should be in causal contact to allow a reconnection. Strings are allowed to reconnect if gamma &lt timeDilationPar * mDip * r and if a single pair of dipoles are in causal contact the reconnection is allowed. Strings are allowed to reconnect if gamma &lt timeDilationPar * mDip' * r and all strings should be in causal contact to allow a reconnection. mDip' is the invariant mass at the formation of the dipole (ie. the first time the colour tag appear in the perturbative expansion). Strings are allowed to reconnect if gamma &lt timeDilationPar * mDip' * r and if a single pair of dipoles are in causal contact the reconnection is allowed. mDip' is the invariant mass at the formation of the dipole (ie. the first time the colour tag appear in the perturbative expansion)."},{"name":"Merging:doCutBasedMerging","link":"CKKWLMerging.html#anchor9","text":"This switch will use cuts on ( pT i ), &Delta;R ij and Q ij to define when parton shower emissions are allowed. Please note for this particular merging scale definition, only light jets ( u,d,c,s,g ) are checked."},{"name":"void ParticleDataEntry::resInit(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  CoupSM* coupSMPtrIn)","link":"ParticleDataScheme.html#anchor161","text":"initialize the treatment of a resonance."},{"name":"SigmaDiffractive:mMin","link":"TotalCrossSections.html#anchor10","text":"Lowest mass of a diffractive system is set to be mHadron + mMin."},{"name":"void Settings::pvec(string key, vectorAMPERSANDlt;doubleAMPERSANDgt; now,  bool force = false)","link":"SettingsScheme.html#anchor63","text":""},{"name":"int LHAup::idProcess(i)","link":"LesHouchesAccord.html#anchor23","text":""},{"name":"ExcitedFermion:qqbar2nutauStarnutauStar","link":"CompositenessProcesses.html#anchor26","text":"Scatterings q qbar &rarr; nu_tau^* nu_tau^*bar. Code 4056."},{"name":"HiggsBSM:ff2H2ff(t:ZZ)","link":"HiggsProcesses.html#anchor40","text":"Scattering f f' &rarr; H^0(H_2^0) f f' via Z^0 Z^0 fusion. Code 1026."},{"name":"LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = AMPERSANDquot;helaconiarunAMPERSANDquot;, string exe = AMPERSANDquot;ho_clusterAMPERSANDquot;)","link":"HelacOniaProcesses.html#anchor1","text":"creates an instance of the LHAupHelaconia class. pointer to the Pythia instance, such that some of its facilities can be used inside the interface. the name of the run directory, into which HelacOnia puts its (intermediate) results. the name of the HelacOnia executable that LHAupHelaconia is meant to wrap. In addition it may be necessary to prepend the full pathname of the executable: '(something)/HELAC-Onia-2.0.1/cluster/bin/ho_cluster'."},{"name":"virtual void MyMerging::statistics()","link":"MatchingAndMerging.html#anchor6","text":"This function can be used to collect and print merging information at the end of the event generation. Pythia will call this function in the execution of a Pythia::stat() call."},{"name":"PhotonCollision:gmgm2qqbar","link":"ElectroweakProcesses.html#anchor32","text":"Scatterings gamma gamma &rarr; q qbar , where q is a light quark ( u, d, s ). Code 261."},{"name":"double CoupSM::af2(int idAbs)","link":"StandardModelParameters.html#anchor37","text":""},{"name":"Beams:offsetVertexZ","link":"BeamParameters.html#anchor38","text":"The z location of the interaction vertex is centered at this value."},{"name":"int LHAup::col1(int i)","link":"LesHouchesAccord.html#anchor43","text":""},{"name":"bool ParticleData::isOctetHadron(int id)","link":"ParticleDataScheme.html#anchor76","text":"true for an intermediate hadron-like state with a colour octet charge as used in the colour octet model for onia production."},{"name":"bool Pythia8ToHepMC::free_parton_exception()","link":"HepMCInterface.html#anchor8","text":"check and throw an exception when unhadronized gluons or quarks are encountered in the event record. Does not apply when Pythia hadronization is switched off. Default is to do this check. If an exception is thrown the PartonEndVertexException class will return a warning message. The calling code can choose action to take, also having access to the location ( index() ) and species ( pdg_id() ) of a bad parton."},{"name":"bool Settings::unfinishedInput()","link":"SettingsScheme.html#anchor79","text":"return true if input of a vector has been begun with am open brace { but no matching closing brace } has been found (so far), else false."},{"name":"int Info::getGeneratorSize()","link":"EventInformation.html#anchor116","text":""},{"name":"string Info::nameProc(int i = 0)","link":"EventInformation.html#anchor99","text":"returns the process name for process code i."},{"name":"virtual bool UserHooks::canReconnectResonanceSystems()","link":"UserHooks.html#anchor40","text":"In the base class this method returns false. If you redefine it to return true then the method doReconnectResonanceSystems(...) will be called immediately after the resonance decays and their associated final-state showers have been added to the event record."},{"name":"mapAMPERSANDlt;string, WordAMPERSANDgt; Settings::getWordMap(string match)","link":"SettingsScheme.html#anchor52","text":""},{"name":"void LHAupHelaconia::setSeed(int seed, int runs = 30081)","link":"HelacOniaProcesses.html#anchor4","text":"the random seed (sequence), normally not needed to be set explicitly. If the random seed is negative (default of -1), then the HelacOnia seed is taken as the Pythia parameter 'Random:seed' , which must be greater than 0. If the maximum number of allowed runs is exceeded (default of 30081) an error is thrown. The seed for a HelacOnia run is set as: (random seed - 1) * (maximum runs) + (number of runs) + 1. HelacOnia can only handle random seeds up to 30081 * 30081. So, with this strategy, one can generate Pythia jobs with seeds from 1 to 30081, with each job running HelacOnia less than 30081 times, and ensure a fully statistically independent sample. If more than 30081 jobs are needed, then the maximum allowed runs can be lowered accordingly, and if need be, setEvents can be used to increase the number of events generated per run."},{"name":"Beams:pyA","link":"BeamParameters.html#anchor8","text":"The p_y component of the first incoming particle, to be set if Beams:frameType = 3."},{"name":"int SigmaProcess::idTchan2()","link":"SemiInternalProcesses.html#anchor26","text":"the non-QCD 2 &rarr; 3 phase space selection machinery is rather primitive, as already mentioned. The efficiency can be improved in processes that proceed though t -channel exchanges, such as q qbar' &rarr; H^0 q qbar' via Z^0 Z^0 fusion, if the identity of the t -channel-exchanged particles on the two side of the event are provided. Only the absolute value is of interest."},{"name":"int ParticleDataEntry::heaviestQuark(int id)","link":"ParticleDataScheme.html#anchor149","text":"extracts the heaviest quark or antiquark, i.e. one with largest id number, for a hadron. Only the sign of the input argument is relevant."},{"name":"Beams:pyB","link":"BeamParameters.html#anchor11","text":"The p_y component of the second incoming particle, to be set if Beams:frameType = 3."},{"name":"double Particle::pAbs2()","link":"ParticleProperties.html#anchor46","text":"(squared) three-momentum size."},{"name":"TimeShower:scaleGluonToQuark","link":"TimelikeShowers.html#anchor34","text":"Extra scale parameter k for TimeShower:weightGluonToQuark options 5 - 8. Comes on top of TimeShower:renormMultFac , which affects alpha_s(pT^2) alike."},{"name":"  virtual bool canVetoTrialEmission()","link":"MatchingAndMerging.html#anchor18","text":""},{"name":"Weak Showers","link":"WeakShowers.html","text":"Weak Showers The emission of W^+- and Z^0 gauge bosons off fermions is intended to be an integrated part of the initial- and final-state radiation frameworks, and is fully interleaved with QCD and QED emissions. It is a new and still not fully explored feature, however, and therefore it is off by default. The weak-emission machinery is described in detail in Chr14 ; here we only bring up some of the most relevant points for using this machinery. In QCD and QED showers the real and virtual corrections are directly related with each other, which means that the appropriate Sudakov factors can be directly obtained as a by-product of the real-emission evolution. This does not hold for W^+- , owing to the flavour-changing character of emissions, so-called Bloch-Nordsieck violations. These effects are not expected to be large, but they are not properly included, since our evolution framework makes no distinction in this respect between QCD, QED or weak emissions. Another restriction is that there is no simulation of the full gamma^*/Z^0 interference: at low masses the QED shower involves a pure gamma^* component, whereas the weak shower generates a pure Z^0. The non-negligible W/Z masses have a considerable impact both on the matrix elements and on the phase space for their emission. The shower on its own is not set up to handle those aspects with a particularly good accuracy. Therefore the weak shower emissions are always matched to the matrix element for emission off a f fbar weak dipole, or some other 2 &rarr; 3 matrix element that resembles the topology at hand. Even if the match may not be perfect, at least the main features should be caught that way. Notably, the correction procedure is used throughout the shower, not only for the emission closest to the hard 2 &rarr; 2 process. In such extended applications, emission rates are normalized to the invariant mass of the dipole at the time of the weak emission, i.e. discounting the energy change by previous QCD/QED emissions. Also the angular distribution in the subsequent V = W^+-/Z^0 decay is matched to the matrix element expression for f fbar &rarr; f fbar V &rarr; f fbar f' fbar' (FSR) and f fbar &rarr; g^* V &rarr; g^* f' fbar' (ISR). Afterwards the f' fbar' system undergoes showers and hadronization just like any W^+-/Z^0 decay products would. Special for the weak showers is that couplings are different for left- and righthanded fermions. With incoming unpolarized beams this should average out, at least so long as only one weak emission occurs. In the case of several weak emissions off the same fermion the correlation between them will carry a memory of the fermion helicity. Such a memory is retained for the affected dipole end, and is reflected in the Particle::pol() property, it being +1 ( -1 ) for fermions considered righthanded (lefthanded), and 0 for the bulk where no choice has been made. Most events will not contain a W^+-/Z^0 emission at all, which means that dedicated generator studies of weak emissions can become quite  inefficient. In a shower framework it is not straightforward to force  such emissions to happen without biasing the event sample in some respect. An option is available to enhance the emission rate artificially, but it is then the responsibility of the user to correct the cross section accordingly, and not to pick an enhancement so big that the probability for more than one emission is non-negligible. (It is not enough to assign an event weight 1/e^n where e is the enhancement factor and n is the number of emitted gauge bosons. This still misses to account for the change in phase space for late emissions by the effect of earlier ones, or equivalently for the unwanted change in the Sudakov form factor. See Lon13a for a detailed discussion and possible solutions.) Another enhancement probability is to only allow some specific W^+-/Z^0 decay modes. By default the shower is inclusive, since it should describe all that can happen with unit probability. This also holds even if the W^+- and Z^0 produced in the hard process have been restricted to specific decay channels. The trick that allows this is that two new 'aliases' have been produced, a Zcopy with identity code 93 and a Wcopy with code 94. These copies are used specifically to bookkeep decay channels open for W^+-/Z^0 bosons produced in the shower. For the rest they are invisible, i.e. you will not find these codes in event listings, but only the regular 23 and 24 ones. The identity code duplication allows the selection of specific decay modes for 93 and 94, i.e. for only the gauge bosons produced in the shower. As above it is here up to the user to reweight the event to compensate for the bias introduced, and to watch out for possible complications. In this case there is no kinematics bias, but one would miss out on topologies where a not-selected decay channel could be part of the background to the selected one, notably when more than one gauge boson is produced. Note that the common theme is that a bias leads to an event-specific weight, since each event is unique. It also means that the cross-section information obtained e.g. by Pythia::stat() is misleading, since it has not been corrected for such weights. This is different from biases in a predetermined hard process, where the net reduction in cross section can be calculated once and for all at initialization, and events generated with unit weight thereafter. The weak shower introduces a possible doublecounting problem. Namely that it is now possible to produce weak bosons in association with jets from two different channels, Drell-Yan weak production with QCD emissions and QCD hard process with a weak emission. A method, built on a classification of each event with the kT jet algorithm, is used to remove the doublecounting. Specifically, consider a tentative final state consisting of a W/Z and two jets. Based on the principle that the shower emission ought to be softer than the hard emission, the emission of a hard W/Z should be vetoed in a QCD event, and that of two hard jets in a Drell-Yan event. The dividing criterion is this whether the first clustering step involves the W/Z or not. It is suggested to turn this method on only if you simulate both Drell-Yan weak production and QCD hard production with a weak shower. Do not turn on the veto algorithm if you only intend to generate one of the two processes. variables Below are listed the variables related to the weak shower and common to both the initial- and final-state radiation. For variables only related to the initial-state radiation (e.g. to turn the weak shower on for ISR) see Spacelike Showers and for final-state radiation see Timelike Showers."},{"name":"double Particle::m()","link":"ParticleProperties.html#anchor14","text":"the particle mass, stored with a minus sign (times the absolute value) for spacelike virtual particles."},{"name":"ExtraDimensionsG*:Gbb","link":"ExtraDimensionalProcesses.html#anchor13","text":"Coupling between graviton and bottom quark."},{"name":"Zprime:coup2gen4","link":"NewGaugeBosonProcesses.html#anchor30","text":"Z'^0 couples to 4th generation fermions."},{"name":"bool Settings::isWord(string key)","link":"SettingsScheme.html#anchor20","text":""},{"name":"double Info::x1()","link":"EventInformation.html#anchor32","text":""},{"name":"ExtraDimensionsLED:MD","link":"ExtraDimensionalProcesses.html#anchor61","text":"Fundamental scale of gravity in D = 4 + n dimensions."},{"name":"friend Hist operator*(const HistAMPERSANDamp; h1, double f)","link":"Histograms.html#anchor38","text":""},{"name":"Vec4 BeamShape::vertex()","link":"BeamShape.html#anchor7","text":"read out the production-vertex position and time that were set by pick()."},{"name":"double ParticleData::mMin(int id)","link":"ParticleDataScheme.html#anchor44","text":"the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there."},{"name":"int Pythia::mode(string key)","link":"ProgramFlow.html#anchor32","text":"read in an integer variable from the Settings database. the name of the variable to be read."},{"name":"double Thrust::oblateness()","link":"EventAnalysis.html#anchor14","text":"gives the thrust, major, minor and oblateness values, respectively,"},{"name":"PromptPhoton:gg2ggamma","link":"ElectroweakProcesses.html#anchor4","text":"Scattering g g &rarr; g gamma. Note: This is a box graph. The full quark-mass dependence in the loop leads to very complicated expressions. The current implementation is based on assuming five massless quarks (see below), and thus is questionable at small ( pT < m_b ) or large ( pT > m_t ) transverse momenta. Code 203."},{"name":"double Info::enhanceMPI()","link":"EventInformation.html#anchor87","text":"The choice of impact parameter implies an enhancement or depletion of the rate of subsequent interactions, as given by this number. Again the average is normalized to be unity for minimum-bias events (meaning more than that for events with hard processes)."},{"name":"Beams:sigmaPxB","link":"BeamParameters.html#anchor25","text":"The width of a Gaussian distribution of the p_x spread of the second incoming particle."},{"name":"Beams:sigmaPxA","link":"BeamParameters.html#anchor21","text":"The width of a Gaussian distribution of the p_x spread of the first incoming particle."},{"name":"Diffraction:MBRdyminSigDD","link":"Diffraction.html#anchor16","text":""},{"name":"Zprime:vtauPrime","link":"NewGaugeBosonProcesses.html#anchor35","text":"vector coupling of tau' leptons."},{"name":"int Event::setEvtPtr(int iSet = -1)","link":"EventRecord.html#anchor29","text":"send in the this pointer of the current Event itself to the particle iSet , by default the most recently appended particle. Also generates a pointer to the ParticleDataEntry object of the identity code of the particle."},{"name":"HiggsBSM:qqbar2H2ttbar","link":"HiggsProcesses.html#anchor43","text":"Scattering q qbar &rarr; H^0(H_2^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1029."},{"name":"SpaceShower:rapidityOrder","link":"SpacelikeShowers.html#anchor19","text":"Force emissions, after the first,  to be ordered in rapidity, i.e. in terms of decreasing angles in a backwards-evolution sense. Could be used to probe sensitivity to unordered emissions. Only affects QCD emissions, and only the hard subcollision of an event. (For the case 'soft QCD' processes the first MPI counts as the hard subcollision.)"},{"name":"double LHAup::scale(int i)","link":"LesHouchesAccord.html#anchor52","text":"for particle i in the range 0 <= i < sizePart(). (But again note that i = 0 is an empty line, so the true range begins at 1.)"},{"name":"StringPT:mT2suppression","link":"Fragmentation.html#anchor29","text":"If switched on the flavour composition is chosen based on the hadronic transverse mass, mT^2_had , and not based on the quark masses. This implies a mass suppression factor exp(-m_had^2 / 2 sigma^2)."},{"name":"bool Particle::isRescatteredIncoming()","link":"ParticleProperties.html#anchor35","text":"true for particles with a status code -34, -45, -46 or -54, else false. This singles out partons that have been created in a previous scattering but here are bookkept as belonging to the incoming state of another scattering."},{"name":"Diffraction:MBRbeta0","link":"Diffraction.html#anchor6","text":""},{"name":"Fourth-Generation Processes","link":"FourthGenerationProcesses.html","text":"Fourth-Generation Processes A fourth generation can be accommodated within the Standard Model, without the introduction of any new concepts. Many experimental constraints exist, but it has not been fully excluded. Therefore we offer a simple implementation, along the lines of the top. It could also be useful as a template for studies of other new particles with similar characteristics. The fourth generation are given names as in the third, but with a prime, i.e. b' with PDG code 7, t' with code 8, tau' with code 17, and nu'_tau with code 18. Most important for you is to assign a mass hierarchy, to decide which fermions can decay into which. The current implementation assumes that mass splittings are big enough that fourth-generation fermions can decay to third-generation ones by the emission of an on-shell W. To this end, the standard three-generation CKM mixing matrix has been extended to include a fourth generation, see below. Since no mixing has been implemented in the neutrino sector it would be assumed that the lighter of tau' and nu'_tau is stable. No decay modes have been implemented that go beyond the Standard Model, so modifications would be needed if e.g. also SUSY is included in the game. Production processes 1) b' processes Different ways to produce b' quarks, singly or in pairs. For a b' t' pair see section 3 below. 2) t' processes Different ways to produce t' quarks, singly or in pairs. For a b' t' pair see section 3 below. 3) Pair-processes with different flavours Different ways to produce two different fourth-generation fermions. Missing in this list is scatterings q q' &rarr; t' b' by t -channel exchange of a W^+- boson, since currently the matrix element for such processes have not been implemented for two massive particles in the final state. Since this process would involve two CKM-suppressed vertices it ought to be small. Parameters The Cabibbo-Kobayashi-Maskawa matrix is extended by seven further values. So as not to mess up the Standard Model, the normal 3 * 3 matrix is kept unitary, and so the new off-diagonal elements lead to a slight breaking of this. For exploratory studies this should be good enough; more detailed 4 * 4 tunes to data would only make sense the day there are evidence for the existence of a fourth generation."},{"name":"double SlowJet::pT(i)","link":"EventAnalysis.html#anchor46","text":"gives the transverse momentum pT of the i 'th jet,"},{"name":"void Settings::addMode(string key,  int default, bool hasMin, bool hasMax, int min, int max)","link":"SettingsScheme.html#anchor26","text":""},{"name":"Diffraction:MBRdyminSD","link":"Diffraction.html#anchor12","text":""},{"name":"Main:spareFlag2","link":"MainProgramSettings.html#anchor29","text":""},{"name":"void ParticleData::addParticle(int id,  string name = AMPERSANDquot; AMPERSANDquot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor22","text":""},{"name":"SigmaTotal:sigmaAX","link":"TotalCrossSections.html#anchor7","text":"Single Diffractive cross section A + B &rarr; A + X in mb."},{"name":"WeakBosonAndParton:ffbar2gmZgm","link":"ElectroweakProcesses.html#anchor25","text":"Scattering f fbar &rarr; gamma^*/Z^0 gamma. Code 243."},{"name":"Hist::Hist(string title, int numberOfBins, double xMin,  double xMax)","link":"Histograms.html#anchor2","text":"declare and define a histogram, where is a string with the title of the histogram at output, is the number of bin the x range will be subdivided into, limited to be at most 1000, is the lower edge of the histogram, is the upper edge of the histogram."},{"name":"MultipartonInteractions:pTmaxMatch","link":"MultipartonInteractions.html#anchor1","text":"Way in which the maximum scale for multiparton interactions is set to match the scale of the hard process itself. (i) if the final state of the hard process (not counting subsequent resonance decays) contains only quarks ( u, d, s, c, b ), gluons and photons then pT_max is chosen to be the factorization scale for internal processes and the scale value for Les Houches input; (ii) if not, interactions are allowed to go all the way up to the kinematical limit. The reasoning is that the former kind of processes are generated by the multiparton-interactions machinery and so would double-count hard processes if allowed to overlap the same pT range, while no such danger exists in the latter case. always use the factorization scale for an internal process and the scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some interactions that ought to have been simulated. always allow multiparton interactions up to the kinematical limit. This will simulate all possible event topologies, but may lead to double-counting. as option 0, but for case (i) the pT_max is chosen to be half the summed pT of the final-state particles. This may be more relevant than option 0 for multiparton final states, where the factorization scale could be associated with the lowest pT of any parton, as appropriate for parton showers, but not for MPI. The scale for no doublecounting and no gaps should rather be associated with the 'core' 2 &rarr; 2 hard process, which here is approximated by sum pT / 2. Note: If a 'second hard' process is present, the two are analyzed separately for the default 0 option, and for 3. It is enough that one of them only consists of quarks, gluons and photons to restrict the pT range. The maximum for MPI is then set by the hard interaction with lowest scale."},{"name":"double Settings::parm(string key)","link":"SettingsScheme.html#anchor35","text":""},{"name":"double Particle::tau()","link":"ParticleProperties.html#anchor22","text":"the proper lifetime, in mm/c. (Since c = 3 * 10^11 mm/s, Particle::tau() /(3 * 10^11) is the lifetime in seconds.) It is assigned for all hadrons with positive nominal tau , tau_0 > 0 , because it can be used by PYTHIA to decide whether a particle should or should not be allowed to decay, e.g. based on the decay vertex distance to the primary interaction vertex."},{"name":"ExtraDimensionsG*:KKgtL","link":"ExtraDimensionalProcesses.html#anchor25","text":"Coupling between KK-gluon and a left-handed top quark."},{"name":"WeakBosonAndParton:all","link":"ElectroweakProcesses.html#anchor22","text":"Common switch for the group of production of a single electroweak gauge boson, i.e. a gamma^*/Z^0 or a W^+- , in association with a parton, i.e. a quark, gluon, photon or lepton. These processes give first-order corrections to the ones in the WeakSingleBoson class, and both sets cannot be used simultaneously without unphysical double-counting. The current class should only be used to study the high- pT tail of the gauge-boson production processes (for LHC applications at least pT > 20 GeV), while the ones in WeakSingleBoson should be used for inclusive production."},{"name":"virtual bool SlowJetHook::include(int iSel,  const EventAMPERSAND event, Vec4AMPERSAND pSel, doubleAMPERSAND mSel)","link":"EventAnalysis.html#anchor68","text":"is the main method that you will need to write. It will be called once for each final-state particle in an event, subject to the value of the select switch in the SlowJet constructor. The value select = 2 may be convenient since then you do not need to remove e.g. neutrinos yourself, but use select = 1 for full control. The method should then return true if you want to see particle included in the jet clustering, and false if not. is the index in the event record of the currently studied particle. is an object of the Event class, most likely the pythia.event one, where the currently studied particle is found. is at input the four-momentum of the currently studied particle. You can change the values, e.g. to take into account energy smearing in the detector, to define the initial cluster value, without corrupting the event record itself. is at input the mass of the currently studied particle. You can change the value, e.g. to take into account particle misidentification, to define the initial cluster value, without corrupting the event record itself. Note that the changes of pSel and mSel must be coordinated such that E^2 - p^2 = m^2 holds."},{"name":"Semi-Internal Processes","link":"SemiInternalProcesses.html","text":"Semi-Internal Processes Normally users are expected to implement new processes via the Les Houches Accord. Then you do all flavour, colour and phase-space selection externally, before your process-level events are input for further processing by PYTHIA. However, it is also possible to implement a new process in exactly the same way as the internal PYTHIA ones, thus making use of the internal phase space selection machinery to sample an externally provided cross-section expression. The MadGraph5 program Alw11 allows you to do exactly that, i.e. it can be used to generate C++ code that can be linked into the existing PYTHIA framework, see here. Should you decide to go ahead on your own, this page gives a brief summary how to do that. If you additionally want to introduce a new resonance species, with its own internal width calculations, you will find further instructions here. It is strongly recommended to shop around for a similar process that has already been implemented, and to use that existing code as a template. Look for processes with the same combinations of incoming flavours and colour flows, rather than the shape of the cross section itself. With a reasonable such match the task should be of medium difficulty, without it more demanding. PYTHIA's internal phase-space generators are rather good at handling the phase space of 2 &rarr; 1 and 2 &rarr; 2 processes, are more primitive for 2 &rarr; 3 ones and do not at all address higher multiplicities. An option is therefore also provided for external phase-space generators to be used, which must then be encapsulated to inherit from PYTHIA's PhaseSpace base class (or one of its derivatives). The set of processes that can be implemented in this framework is therefore in principle unlimited, though the user must supply external phase-space generators for non-trivial 2 &rarr; 3 processes and all higher 2 &rarr; n multiplicities. Note, however, that the produced particles may be resonances, so it is possible to end up with bigger 'final' multiplicities through sequential decays, also with the internal phase-space generators, and to include further matrix-element weighting in those decays. For processes using PYTHIA's internal phase-space generators, there are three steps involved in implementing a process: making use of the PYTHIA-provided kinematics information to calculate the relevant cross section, writing a new class,  where the matrix elements are implemented, including information on incoming and outgoing flavours and colours, and making the process available. We consider these aspects in turn. An example where it all comes together is found in main22.cc. For processes for which an external phase-space generator will be used, step 1 above changes to writing a new class, where the phase-space generator is implemented, and making use of that to calculate the relevant cross section. There are no example programs illustrating how to do this yet, but the methodology is described below, under 'Implementing an external phase-space generator'. The Cross Section Calculation The key method for the cross section calculation is SigmaProcess::sigmaHat() , described below. At the point when it is called, the kinematics has already been set up, and from these phase space variables the differential cross section is to be calculated. For a 2 &rarr; 1 process, the returned value should be sigmaHat(sHat) , where mH (= mHat ), sH (= sHat ) and sH2 (= sHat^2 ) are available to be used. Incoming partons are massless. Overload the convertM2() method below if you instead plan to return |M|^2. For a 2 &rarr; 2 process, instead d(sigmaHat)/d(tHat) should be returned, based on provided mH, sH, sH2, tH, tH2, uH, uH2, m3, s3, m4, s4 and pT2 values ( s3 = m3*m3 etc.). Incoming partons are massless. Overload the convertM2() method below if you instead plan to return |M|^2. For a 2 &rarr; 3 process, instead |M|^2 should be returned, with normalization such that |M|^2 / (2 sHat) integrated over the three-body phase space gives the cross section. Here no standard set of Mandelstam-style variables exists. Instead the obvious ones, mH, sH, m3, s3, m4, s4, m5, s5 , are complemented by the four-vectors p3cm, p4cm, p5cm , from which further invariants may be calculated. The four-vectors are defined in the CM frame of the subcollision, with massless incoming partons along the +-z axis. In either case, alpha_s and alpha_em have already been calculated, and are stored in alpS and alpEM. Also other standard variables may be used, like CoupEW::sin2thetaW() , and related flavour-dependent vector and axial couplings in CoupEW and CKM combinations in VCKM. In case some of the final-state particles are resonances, their squared masses have already been selected according to a Breit-Wigner with a linearly running width Gamma(m) = Gamma(m_0) * m / m_0. More precisely, the mass spectrum is weighted according to w_BW(m^2) d(m^2) , where w_BW(m^2) = (1/pi) * (m * Gamma(m)) / ( (m^2 - m_0^2)^2 + (m * Gamma(m))^2 ). If you would like to have another expression, the above weights are stored in runBW3 , runBW4 and runBW5 , respectively. If you divide out one of these factors, you just remain with a phase space selection d(m^2) for this particle, and can multiply on your desired shape factor instead. Unfortunately, the Monte Carlo efficiency will drop if your new mass distribution differs dramatically from the input one. Therefore it does make sense to adjust the database value of the width to be slightly (but not too much) broader than the distribution you have in mind. Also note that, already by default, the wings of the Breit-Wigner are oversampled (with a compensating lower internal weight) by partly sampling like (a + b/m^2 + c/m^4) d(m^2) , where the last term is only used for gamma^*/Z^0. As alternative to the kinematics variables defined above, also the two arrays mME[5] and pME[5] , for masses and four-momenta, respectively, can be used for cross-section calculations. Here indices 0 and 1 are the two incoming beams, and 2 and onwards the outgoing particles. Note that this differs by one step from the normal internal labeling, where slot 0 is left empty. The four-momenta are defined in the rest frame of the subcollision, with the incoming partons along the +-z direction. The kinematics need not agree with the 'correct' one stored in the event record, for three reasons. 1) Gauge invariance forces matrix-element calculations to use the same masses for incoming as outgoing legs of a particle species, say b quarks. Therefore the kinematics of the two incoming partons is recalculated, relative to the normal event record, to put the partons on the mass shell. (Note that initial masses is a technical issue, not the correct physics picture: the incoming partons are likely to be spacelike virtual rather than on the mass shell.) 2) In principle each fermion flavour has to be treated separately, owing to a different mass. However, in many cases fermions can be assumed massless, which speeds up the calculations, and further gains occur if then different flavours can use the same cross-section expression. In MadGraph the default is that fermions up to and including the c quark and the mu lepton are considered massless, while the b quark and the tau lepton are considered massive. This can be modified however, and below we provide four flags that can be used to consider the 'borderline' fermions either as massless or as massive when matrix elements are evaluated, to match the assumptions made for the matrix elements themselves. 3) For 2 &rarr; 2 and 2 &rarr; 3 processes of massive identical particles (or antiparticles) in the final state, such as t tbar or W^+ W^- , the kinematics is here adjusted so that the two or three particles have the same mass, formed as a suitable average of the actual Breit-Wigner-distributed masses. This allows the evaluation of matrix-element expressions that only have meaning if the two/three have the same mass. Thus the mass array mME[5] and the four-momentum array pME[5] present values both for initial- and final-state particles based on these mass principles suited for matrix-element input. Note that these variables therefore differ from the kinematics stored in the event record proper, where incoming fermions are always massless and outgoing resonances have independent Breit-Wigner mass distributions. The conversion from the normal to the special kinematics is done by calling the setupForME() method. This you have to do yourself in the SigmaHat() member of your derived class. Alternatively it could be done in SigmaKin() , i.e. before the loop over incoming flavours, but then these would be considered massless. The identity of final-state particles is obtained from the id3Mass() , id4Mass() and id5Mass() methods. Should the conversion to mME[5] and pME[5] not work, setupForME() will return false , and then the cross section should be put zero. The Cross Section Class The matrix-element information has to be encoded in a new class. The relevant code could either be put before the main program in the same file, or be stored separately, e.g. in a matched pair of .h and .cc files. The latter may be more convenient, in particular if the cross sections are lengthy, or if you intend to build up your own little process library, but of course requires that these additional files are correctly compiled and linked. The class has to be derived either from Sigma1Process , for 2 &rarr; 1 processes, from Sigma2Process , for 2 &rarr; 2 ones, or from Sigma3Process , for 2 &rarr; 3 ones. (The Sigma0Process class is used for elastic, diffractive and minimum-bias events, and is not recommended for use beyond that.) These are in their turn derived from the SigmaProcess base class. The class can implement a number of methods. Some of these are compulsory, others strongly recommended, and the rest are to be used only when the need arises to override the default behaviour. The methods are: A constructor for the derived class obviously must be available. Here you are quite free to allow a list of arguments, to set the parameters of your model, or even to create a set of closely related but distinct processes. For instance, g g &rarr; Q Qbar , Q = c or b , is only coded once, and then the constructor takes the quark code (4 or 5)  as argument, to allow the proper amount of differentiation. A destructor is only needed if you plan to delete the process before the natural end of the run, and require some special behaviour at that point. If you call such a destructor you will leave a pointer dangling inside the Pythia object you gave it in to, if that still exists. Access to a process Once you have implemented a class, it is straightforward to make use of it in a run. Assume you have written a new class MySigma , which inherits from Sigma1Process , Sigma2Process or Sigma3Process , which in their turn inherit from SigmaProcess. You then create an instance of this class and hand it in to a pythia object with SigmaProcess* mySigma = new MySigma();     pythia.setSigmaPtr( mySigma); If an external phase-space generator should be used for this process (see 'Implementing an external phase-space generator' below), this should be specified as a second argument in the call to setSigmaPtr() , as in: pythia.setSigmaPtr( new mySigma(), new myPhaseSpaceGenerator() ); If you have several processes you can repeat the procedure any number of times. When pythia.init() is called these processes are initialized along with any internal processes you may have switched on, and treated in exactly the same manner. The pythia.next() will therefore generate a mix of the different kinds of processes without distinction. See also the Program Flow description. If the code should be of good quality and general usefulness, it would be simple to include it as a permanently available process in the standard program distribution. The final step of that integration ought to be left for the PYTHIA authors, but here is a description of what is required. A flag has to be defined, that allows the process to be switched on; by default it should always be off. The name of the flag should be chosen of the type model:process. Here the model would be related to the general scenario considered, e.g. Compositeness , while process would specify instate and outstate, separated by a 2 (= to), e.g. ug2u*g. When several processes are implemented and 'belong together' it is also useful to define a model:all switch that affects all the separate processes. The flags should normally be stored in the ProcessSelection.xml file or one of its daughters for a specific kind of processes. This is to make them easily found by users. You could create and use your own .xml file, so long as you then add that name to the list of files in the Index.xml file. (If not, the flags would never be created and the program would not work.) In the ProcessContainer.c file, the SetupContainers::init() method needs to be expanded to create instances of the processes switched on. This code is fairly repetitive, and should be easy to copy and modify from the code already there. The basic structure is (i) check whether a process is requested by the user and, if so, (ii) create an instance of the matrix-element class, (iii)create a container for the matrix element and its associated phase-space handling, and (iv) add the container to the existing process list. Two minor variations are possible. One is that a set of related processes are lumped inside the the same initial check, i.e. are switched on all together. The second is that the matrix-element constructor may take arguments, as specified by you (see above). If so, the same basic matrix element may be recycled for a set of related processes, e.g. one for a composite u and one for a composite d. Obviously these variations may be combined. Implementing an external phase-space generator An external phase-space generator can be interfaced by encapsulating it within a class inheriting from PYTHIA's PhaseSpace base class. The following three virtual methods must be defined: // Determine how phase space should be sampled.     virtual bool setupSampling();     // Select a trial event kinematics.     virtual bool trialKin(bool inEvent = true, bool repeatSame = false);     // Construct final (accepted) event kinematics.     virtual bool finalKin(); Optionally, a further virtual method is available to specify whether beam particles are resolved in partons or scatter directly, // Inform whether beam particles are resolved or scatter directly.     virtual bool isResolved(); with default return value true. In the setupSampling() step the main point is to determine the upper estimate of the cross section integrated over the allowed phase space regions, and this should be stored in sigmaMx. The ratio between the correct cross section and its upper estimate is a measure of the phase-space selection efficiency, and the purpose of this step is to optimize the sampling accordingly. To this end any convenient set of phase-space variables may be chosen. The x1H and x2H varables should be used to denote the incoming parton momentum fractions, however, to be used in PDF evaluations. In the trialKin() intermediate step the same set of internal variables can be used, and fed into the SigmaProcess code to evaluate the cross section in the given phase space point, multiplied by the integrated cross section. This value is to be stored in sigmaNw , and the ratio sigmaNw/sigmaMx will be used to determine whether the trial event is accepted or not. In the finalKin() step the output is more standardized. The key values are the ones stored in the mH[] and pH[] arrays, the former for masses and the latter for four-momenta. Here the first two slots represent the two incoming partons and the subsequent ones up to ten outgoing particles. Other particle properties, like the number of final-state particles, their identities and colours, and more, are defined by the SigmaProcess class. A tailor-made 2 &rarr; 3 generator could be defined, e.g., by starting from the code for PYTHIA's internal PhaseSpace2to3tauycyl base class, which provides a specific representation of 3-parton phase space, used for generic 2 &rarr; 3 processes in PYTHIA. The virtual functions described could then be redefined to generate a different sampling of 3-parton phase space. One example of this is provided by the existing PhaseSpace2to3yyycyl class, which PYTHIA uses for massless QCD processes. Note the interplay between the phase-space variables, generated and saved here, and how they are used by the matrix-element codes. For general processes, the user can define samplings in terms of their own phase-space parametrizations, as long as the corresponding matrix elements use the same variables to evaluate the cross-section expressions."},{"name":"ExtraDimensionsG*:KKgtR","link":"ExtraDimensionalProcesses.html#anchor24","text":"Coupling between KK-gluon and a right-handed top quark."},{"name":"bool Info::isDiffractiveC()","link":"EventInformation.html#anchor19","text":"is there soft central diffraction (a.k.a. double Pomeron exchange)?"},{"name":"SigmaProcess:renormScale3VV","link":"CouplingsAndScales.html#anchor8","text":"The Q^2 renormalization scale for 2 &rarr; 3 vector-boson-fusion processes, i.e. f_1 f_2 &rarr; H^0 f_3 f_4 with Z^0 or W^+- t -channel propagators. Here the transverse masses of the outgoing fermions do not reflect the virtualities of the exchanged bosons. A better estimate is obtained by replacing the final-state fermion masses by the vector-boson ones in the definition of transverse masses. We denote these combinations mT_Vi^2 = m_V^2 + pT_i^2. the squared mass m_V^2 of the exchanged vector boson. the geometric mean of the two propagator virtuality estimates, i.e. sqrt(mT_V3^2 * mT_V4^2). the geometric mean of the three relevant squared transverse masses, i.e. (mT_V3^2 * mT_V4^2 * mT_H^2)^(1/3). the arithmetic mean of the three relevant squared transverse masses, i.e. (mT_V3^2 + mT_V4^2 + mT_H^2)/3. squared invariant mass of the system, i.e. sHat. fix scale set in SigmaProcess:renormFixScale below."},{"name":"bool ResonanceWidths::initBSM()","link":"SemiInternalResonances.html#anchor6","text":"can normally be left dummy, but for advanced implementations it provides a possibility to initialize data members of the derived class at a very early stage during initialization, before any of the other members are called. An example is provided by the SUSYResonanceWidths class, in which an internal pointer to a derived Couplings class must be (re)set before any of the other methods are used. A return value of false can be used to signal that this initialization step failed."},{"name":"bool SlowJet::stopAtN(int nStop)","link":"EventAnalysis.html#anchor60","text":"calls the doStep() method until a total of nStop jet and cluster objects remain. Will return false if this is not possible, specifically if the number of objects already is smaller than nStop when the method is called. The stored jet and cluster information is still perfectly fine; it only does not have the expected multiplicity. Will also return false if useFJcore = true."},{"name":"bool ParticleData::isBaryon(int id)","link":"ParticleDataScheme.html#anchor75","text":"true for a baryon or antibaryon."},{"name":"Charmonium:qg2ccbar(3S1)[3PJ(8)]q","link":"OniaProcesses.html#anchor22","text":"Colour-octet production of 3S1 charmonium states via q g &rarr; ccbar[3PJ(8)] q. Code 409."},{"name":"StringPT:widthPreDiquark","link":"Fragmentation.html#anchor28","text":"Prefactor multiplying the Gaussian width for diquarks. In case of diquarks with one or two strange quarks the prefactor is calculated by multiplying widthPreDiquark once or twice respectively with widthPreStrange."},{"name":"void ParticleDataEntry::setAntiName(string antiName)","link":"ParticleDataScheme.html#anchor100","text":""},{"name":"SecondHard:TopPair","link":"ASecondHardProcess.html#anchor11","text":"Production of a top pair, either via QCD processes or via an intermediate gamma^*/Z^0 resonance."},{"name":"ExcitedFermion:coupF","link":"CompositenessProcesses.html#anchor28","text":"Strength f of the SU(2) coupling."},{"name":"Master Switches","link":"MasterSwitches.html","text":"Master Switches Sometimes it may be convenient to omit certain aspects of the event generation chain. This cannot be motivated in a full-blown production run, but can often be convenient for own understanding and for debug purposes. The flags on this page allow just that. The event generation is subdivided into three levels: the process level, the parton level and the hadron level, and flags are grouped accordingly. Process Level The ProcessLevel class administrates the initial step of the event generation, wherein the basic process is selected. Currently this is done either using some of the internal processes, or with Les Houches Accord input. There could not be a complete event without an initial process, so it would not be a normal action to switch off this step. Furthermore, without a process set, it is also not possible to carry out the tasks on the parton level. It is still possible, however, to hadronize a parton-level configuration provided by some external program. For ProcessLevel:all = on one part of the event generation on this level may be switched off individually: It is possible to stop the generation immediately after the basic process has been selected, see PartonLevel:all below. PartonLevel The PartonLevel class administrates the middle step of the event generation, i.e. the evolution from an input (hard) process from ProcessLevel , containing a few partons only, to a complete parton-level configuration to be handed on to HadronLevel. This step involves the application of initial- and final-state radiation, multiparton interactions and the structure of beam remnants. For PartonLevel:all = on some parts of the event generation on this level may be switched off individually: Switching off all the above MPI/ISR/FSR switches is not equivalent to setting PartonLevel:all = off. In the former case a minimal skeleton of parton-level operations are carried out, such as tying together the scattered partons with the beam remnants into colour singlets, and storing this information in the event record. It is therefore possible to go on and hadronize the event, if desired. In the latter case no operations at all are carried out on the parton level, and therefore it is also not possible to go on to the hadron level. It is possible to stop the generation immediately after the parton level has been set up, see HadronLevel:all below. HadronLevel The HadronLevel class administrates the final step of the event generation, wherein the partonic configuration from PartonLevel is hadronized, including string fragmentation and secondary decays. Most of the code in this class itself deals with subdividing the partonic content of the event into separate colour singlets, that can be treated individually by the string fragmentation machinery. When a junction and an antijunction are directly connected, it also breaks the string between the two, so that the topology can be reduced back to two separate one-junction systems, while still preserving the expected particle flow in the junction-junction string region(s). For HadronLevel:all = on some parts of the event generation on this level may be switched off individually: Printing"},{"name":"HardQCD:qg2qgg","link":"QCDProcesses.html#anchor25","text":"Scatterings q g &rarr; q g g and qbar g &rarr; qbar g g. Code 133."},{"name":"double LHAup::e(int i)","link":"LesHouchesAccord.html#anchor48","text":""},{"name":"bool Pythia::checkVersion()","link":"ProgramFlow.html#anchor6","text":"helper methods, that collects common tasks of the two constructors."},{"name":"ExtraDimensionsG*:Gtt","link":"ExtraDimensionalProcesses.html#anchor14","text":"Coupling between graviton and top quark."},{"name":"void ParticleDataEntry::setColType(int colType)","link":"ParticleDataScheme.html#anchor108","text":""},{"name":"PhaseSpace:Q2Min","link":"PhaseSpaceCuts.html#anchor8","text":"The minimum value for the DIS variable Q^2 = - tHat. Can only meaningfully be used for scattering processes between two non-identical particles, i.e. where tHat and uHat are experimentally distinguishable. No cut will be applied for Q2Min < pTHatMinDiverge^2."},{"name":"Particle Properties","link":"ParticleProperties.html","text":"Particle Properties A Particle corresponds to one entry/slot in the event record. Its properties therefore is a mix of ones belonging to a particle-as-such, like its identity code or four-momentum, and ones related to the event-as-a-whole, like which mother it has. Recall that energies, momenta and masses are all given in GeV, and space-time coordinates all in mm, i.e. units are chosen such that the speed of light c is unity. In particular, times are also in mm, not in seconds. What is stored for each particle is the identity code, the status code, two mother indices, two daughter indices, a colour and an anticolour index, the four-momentum and mass, the scale at which the particle was produced (optional), the polarization/spin/helicity of the particle (optional), the production vertex and proper lifetime (optional), a pointer to the particle kind in the particle data table, and a pointer to the event the particle belongs to. From these, a number of further quantities may be derived. Basic output methods The following member functions can be used to extract the most important information: Input methods The same method names as above are also overloaded in versions that set values. These have an input argument of the same type as the respective output above, and are of type void. There are also a few alternative methods for input: Further output methods In addition, a number of derived quantities can easily be obtained, but cannot be set, such as: Not part of the Particle class proper, but obviously tightly linked, are the two methods Properties of the particle species Each Particle contains a pointer to the respective ParticleDataEntry object in the particle data tables. This gives access to properties of the particle species as such. It is there mainly for convenience, and should be thrown if an event is written to disk, to avoid any problems of object persistency. Should an event later be read back in, the pointer will be recreated from the id code if the normal input methods are used. (Use the Event::restorePtrs() method if your persistency scheme bypasses the normal methods.) This pointer is used by the following member functions: Methods that may access the event the particle belongs to A particle can be created on its own. When inserted into an event record, it obtains a pointer to that event-as-a-whole. It is then possible to use methods that do not make sense for a particle in isolation. These methods are listed below. Whenever the pointer to the event is not defined, these will return an appropriate 'null' value, this being -1 for an integer, false for a bool, and empty for a vector, unless otherwise specified. Methods that perform operations There are some further methods, some of them inherited from Vec4 , to modify the properties of a particle. They are of little interest to the normal user. Constructors and operators Normally a user would not need to create new particles. However, if necessary, the following constructors and methods may be of interest."},{"name":"double RotBstMatrix::deviation()","link":"FourVectors.html#anchor87","text":"crude estimate how much a matrix deviates from the unit matrix: the sum of the absolute values of all non-diagonal matrix elements plus the sum of the absolute deviation of the diagonal matrix elements from unity."},{"name":"FourthTop:qq2tPrimeq(t:W)","link":"FourthGenerationProcesses.html#anchor11","text":"Scatterings q q' &rarr; t' q'' by t -channel exchange of a W^+- boson. Code 823."},{"name":"bool ParticleData::getIsInit()","link":"ParticleDataScheme.html#anchor89","text":"return true if the database has been initialized, else false."},{"name":"Merging:kFactor2j","link":"NLOMerging.html#anchor8","text":"The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of two-jet tree-level events."},{"name":"double Info::bMPIold()","link":"EventInformation.html#anchor95","text":""},{"name":"LHAup::LHAup( int strategy = 3)","link":"LesHouchesAccord.html#anchor1","text":"the base class constructor takes the choice of mixing/weighting strategy as optional input argument, and calls setStrategy , see below. It also reserves some space for processes and particles."},{"name":"void RotBstMatrix::rot(double theta = 0., double phi = 0.)","link":"FourVectors.html#anchor76","text":"rotate by this polar and azimuthal angle."},{"name":"Merging:doNL3Tree","link":"NLOMerging.html#anchor9","text":"This switch will allow the generation of the weight that should be applied to tree-level events in the NL 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Loop and the switch Merging:doNL3Subt have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested."},{"name":"void ParticleData::listFF(string outFile)","link":"ParticleDataScheme.html#anchor12","text":"read in free-format-style data from a file or write it out to a file. For the former one can also decide whether to reset all particles to scratch, or only overwrite those particles in the file. The former method is used by reInit above."},{"name":"Merging:nRecluster","link":"UMEPSMerging.html#anchor3","text":"Number of hard partons to integrate out in the UMEPS procedure."},{"name":"ExtraDimensionsG*:KKgbR","link":"ExtraDimensionalProcesses.html#anchor22","text":"Coupling between KK-gluon and a right-handed bottom quark."},{"name":"Beam Remnants","link":"BeamRemnants.html","text":"Beam Remnants Introduction The BeamParticle class contains information on all partons extracted from a beam (so far). As each consecutive multiparton interaction defines its respective incoming parton to the hard scattering a new slot is added to the list. This information is modified when the backwards evolution of the spacelike shower defines a new initiator parton. It is used, both for the multiparton interactions and the spacelike showers, to define rescaled parton densities based on the x and flavours already extracted, and to distinguish between valence, sea and companion quarks. Once the perturbative evolution is finished, further beam remnants are added to obtain a consistent set of flavours. The current physics framework is further described in Sjo04. The introduction of rescattering in the multiparton interactions framework further complicates the processing of events. Specifically, when combined with showers, the momentum of an individual parton is no longer uniquely associated with one single subcollision. Nevertheless the parton is classified with one system, owing to the technical and administrative complications of more complete classifications. Therefore the addition of primordial kT to the subsystem initiator partons does not automatically guarantee overall pT conservation. Various tricks are used to minimize the mismatch, with a brute force shift of all parton pT 's as a final step. Much of the above information is stored in a vector of ResolvedParton objects, which each contains flavour and momentum information, as well as valence/companion information and more. The BeamParticle method list() shows the contents of this vector, mainly for debug purposes. The BeamRemnants class takes over for the final step of adding primordial kT to the initiators and remnants, assigning the relative longitudinal momentum sharing among the remnants, and constructing the overall kinematics and colour flow. This step couples the two sides of an event, and could therefore not be covered in the BeamParticle class, which only considers one beam at a time. The methods of these classes are not intended for general use, and so are not described here. In addition to the parameters described on this page, note that the choice of parton densities is made in the Pythia class. Then pointers to the pdf's are handed on to BeamParticle at initialization, for all subsequent usage. Primordial kT The primordial kT of initiators of hard-scattering subsystems are selected according to Gaussian distributions in p_x and p_y separately. The widths of these distributions are chosen to be dependent on the hard scale of the central process and on the mass of the whole subsystem defined by the two initiators: sigma = (sigma_soft * Q_half + sigma_hard * Q) / (Q_half + Q)  * m / (m + m_half * y_damp) Here Q is the hard-process renormalization scale for the hardest process and the pT scale for subsequent multiparton interactions, m the mass of the system, and sigma_soft , sigma_hard , Q_half , m_half and y_damp parameters defined below. Furthermore each separately defined beam remnant has a distribution of width sigma_remn , independently of kinematical variables. A net kT imbalance is obtained from the vector sum of the primordial kT values of all initiators and all beam remnants. This quantity is compensated by a shift shared equally between all partons, except that the dampening factor m / (m_half + m) is again used to suppress the role of small-mass systems. Note that the current sigma definition implies that <pT^2> = <p_x^2>+ <p_y^2> = 2 sigma^2. It thus cannot be compared directly with the sigma of nonperturbative hadronization, where each quark-antiquark breakup corresponds to <pT^2> = sigma^2 and only for hadrons it holds that <pT^2> = 2 sigma^2. The comparison is further complicated by the reduction of primordial kT values by the overall compensation mechanism. Colour flow The colour in the separate subproccsses are tied together via the assignment of colour flow in the beam remnants. The assignment of colour flow is not known from first principles and therefore it is not an unambiguous procedure. Thus two different models have been implemented in Pythia. These will be referred to as new and old, based on the time of the implementation. The old model tries to reconstruct the colour flow in a way that a LO PS would produce the beam remnants. The starting point is the junction structure of the beam particle (if it is a baryon). The gluons are attached to a quark line and quark-antiquark pairs are added as if coming from a gluon splittings. Thus this model captures the qualitative behaviour that is expected from leading colour QCD. The model is described in more detail in Sjo04. The new model is built on the full SU(3) colour structure of QCD. The starting point is the scattered partons from the MPI. Each of these are initially assumed uncorrelated in colour space, allowing the total outgoing colour configuration to be calculated as an SU(3) product. Since the beam particle is a colour singlet, the beam remnant colour configuration has to be the inverse of the outgoing colour configuration. The minimum amount of gluons are added to the beam remnant in order to obtain this colour configuration. The above assumption of uncorrelated MPIs in colour space is a good assumption for a few well separated hard MPIs. However if the number of MPIs become large and ISR is included, such that the energy scale becomes lower (and thus distances becomes larger), the assumption loses its validity. This is due to saturation effects. The modelling of saturation is done in crude manner, as an exponential suppresion of high multiplet states. None of the models above can provide a full description of the colour flow in an event, however. Therefore additional colour reconfiguration is needed. This is referred to as colour reconnection. Several different models for colour reconnection are implemented, see Colour Reconection. Further variables When assigning relative momentum fractions to beam-remnant partons, valence quarks are chosen according to a distribution like (1 - x)^power / sqrt(x). This power is given below for quarks in mesons, and separately for u and d quarks in the proton, based on the approximate shape of low- Q^2 parton densities. The power for other baryons is derived from the proton ones, by an appropriate mixing. The x of a diquark is chosen as the sum of its two constituent x values, and can thus be above unity. (A common rescaling of all remnant partons and particles will fix that.) An additional enhancement of the diquark momentum is obtained by its x value being rescaled by the valenceDiqEnhance factor."},{"name":"ExcitedFermion:ug2uStar","link":"CompositenessProcesses.html#anchor3","text":"Scatterings u g &rarr; u^*. Code 4002."},{"name":"JetMatching:exclusive","link":"JetMatching.html#anchor13","text":"Exclusive or inclusive merging. The merging is run in inclusive mode. All partons must match jets, but additional jets are allowed, provided they are not harder than the matched jets. The merging is run in exclusive mode.  All partons must match jets, and no additional jets are allowed. If nJet < nJetMax , then the merging is run in exclusive mode, otherwise it is run in inclusive mode. For Madgraph-style matching, this is checked on an event-by-event basis, which is useful when an LHEF contains a 'soup' of partonic multiplicities. If nJetMax < 0 or nJet < 0 , then the algorithm defaults to exclusive mode."},{"name":"virtual bool MyHardProcess::allowCandidates(int iPos,  vectorAMPERSANDlt;intAMPERSANDgt; Pos1, vectorAMPERSANDlt;intAMPERSANDgt; Pos2, const EventAMPERSAND event)","link":"MatchingAndMerging.html#anchor28","text":"This function uses the input vectors of positions of particles in the input event to decide if the particle with iPos could be member of the core scattering. If the particle with position iPos cannot be part of the core scattering (e.g. because it is a final state parton, while the core scattering contains final state leptons only), then the function should return false. Else, return true to allow this candidate. Note that it might be possible to find multiple equally good core scattering candidates. In this case, all candidates should be found (with the findOtherCandidates function), and can be potentially be replaced (with exchangeCandidates )."},{"name":"double SlowJet::phi(int i)","link":"EventAnalysis.html#anchor48","text":"gives the rapidity y and azimuthal angle phi of the center of the i 'th jet (defined by the vector sum of constituent four-momenta),"},{"name":"Init:showChangedResonanceData","link":"MainProgramSettings.html#anchor6","text":"In the previous listing also include the resonances that are initialized at the beginning of a run and thus get new particle data, even if these may well agree with the default ones. Warning: this will be a rather long list."},{"name":"WeakSingleBoson:ffbar2gmZ","link":"ElectroweakProcesses.html#anchor13","text":"Scattering f fbar &rarr; gamma^*/Z^0 , with full interference between the gamma^* and Z^0. Code 221."},{"name":"double CoupSM::rf(int idAbs)","link":"StandardModelParameters.html#anchor34","text":"the weak isospin, left- and righthanded charges of a fermion, by the absolute sign of the PDF code ( t^3_f = a_f/2, l_f = (v_f + a_f)/2, r_f = (v_f - a_f)/2 ; you may find other conventions in the literature that differ by a factor of 2)."},{"name":"ExtraDimensionsG*:KKgbL","link":"ExtraDimensionalProcesses.html#anchor23","text":"Coupling between KK-gluon and a left-handed bottom quark."},{"name":"double Particle::constituentMass()","link":"ParticleProperties.html#anchor76","text":"will give the constituent masses for quarks and diquarks, else the same masses as with m0()."},{"name":"double Vec4::pAbs()","link":"FourVectors.html#anchor21","text":""},{"name":"int Particle::spinType()","link":"ParticleProperties.html#anchor65","text":"2 *spin + 1 when defined, else 0."},{"name":"void ParticleData::listAll()","link":"ParticleDataScheme.html#anchor14","text":""},{"name":"double LHAup::xSec(i)","link":"LesHouchesAccord.html#anchor24","text":""},{"name":"double Particle::yProd()","link":"ParticleProperties.html#anchor18","text":""},{"name":"Bottomonium:states(3S1)2","link":"OniaProcesses.html#anchor78","text":"The second 3S1 bottomonium states of the bottomonium pairs that can be produced from the following processes."},{"name":"Bottomonium:states(3S1)1","link":"OniaProcesses.html#anchor77","text":"The first 3S1 bottomonium states of the bottomonium pairs that can be produced from the following processes. Note that all vectors within this section, either of modes, flags, or parameters, must be the same length as this vector."},{"name":"virtual bool UserHooks::canVetoFSREmission()","link":"UserHooks.html#anchor25","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoFSREmission(...) will interrupt the final-state shower immediately after each emission and allow that emission to be vetoed."},{"name":"double Info::mergingWeightNLO()","link":"EventInformation.html#anchor84","text":"combined NLO merging weight assigned to the current event, if NLO multi-jet merging (i.e. NL 3 or UNLOPS merging) is attempted. If NLO multi-jet merging is performed, all histograms should be filled with this weight, as discussed in NLO Merging."},{"name":"string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor126","text":"Return the value of the <weights> tag's attribute named key. Setting doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named key does not exist."},{"name":"friend void table(const HistAMPERSANDamp; h1, const HistAMPERSANDamp; h2,  ostreamAMPERSAND os = cout, bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor15","text":""},{"name":"void Event::reset()","link":"EventRecord.html#anchor21","text":"empties the event record, as clear() above, but then fills the zero entry of the Particle vector with the pseudoparticle used to represent the event as a whole. At this point the pseudoparticle is not assigned any momentum or mass."},{"name":"PartonLevel:FSRinProcess","link":"MasterSwitches.html#anchor7","text":"Switch for final-state radiation in association with the hard process itself; on/off = true/false. In addition PartonLevel:FSR must be on for these emissions to occur."},{"name":"ParticleData::ParticleData()","link":"ParticleDataScheme.html#anchor1","text":"the constructor has no arguments and does not do anything. Internal."},{"name":"void Settings::flag(string key, bool now, bool force = false)","link":"SettingsScheme.html#anchor57","text":""},{"name":"BeamRemnants:primordialKThard","link":"BeamRemnants.html#anchor3","text":"The width sigma_hard in the above equation, assigned as a primordial kT to initiators in the hard-interaction limit."},{"name":"TimeShower:renormMultFac","link":"TimelikeShowers.html#anchor10","text":"The default pT^2 renormalization scale is multiplied by this prefactor. For QCD this is equivalent to a change of Lambda^2 in the opposite direction, i.e. to a change of alpha_strong(M_Z^2) (except that flavour thresholds remain at fixed scales)."},{"name":"void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD)","link":"LesHouchesAccord.html#anchor31","text":"tells which kind of process occurred, with what weight, at what scale, and which alpha_EM and alpha_strong were used (cf. IDPRUP, XWTGUP, SCALUP, AQEDUP, AQCDUP ). This method also resets the size of the particle list, and adds the empty zeroth line, so it has to be called before the addParticle method below."},{"name":"StringPT:temperature","link":"Fragmentation.html#anchor30","text":"the temperature T in the fragmentation process."},{"name":"SUSY:qg2chi+-squark","link":"SUSYProcesses.html#anchor19","text":"Associated chargino-squark production from quark-gluon initial states. annihilation. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated."},{"name":"Onia:all","link":"OniaProcesses.html#anchor3","text":"Common switch for the group of onia production."},{"name":"virtual double UserHooks::vetoProbability( string name)","link":"UserHooks.html#anchor44","text":"This function should return the probability of an emission that has been enhanced with the help of enhanceFactor(...) , for the same name arguments as above. An optimal choice depends on your personal needs. Using 0.5 as a baseline is perfectly acceptable. It should return 0. by default, i.e. for all input strings it does not propose to handle."},{"name":"Pythia::setMergingHooksPtr( MergingHooks* myMergingHooks)","link":"MatchingAndMerging.html#anchor2","text":""},{"name":"StringFlav:mesonSL1S0J1","link":"FlavourSelection.html#anchor18","text":"the relative pseudovector production ratio (L=1,S=0,J=1) /pseudoscalar for strange mesons."},{"name":"void Vec4::rescale4(double f)","link":"FourVectors.html#anchor60","text":"multiply all four-vector components by f."},{"name":"int LHAup::pdfGroupBeamA()","link":"LesHouchesAccord.html#anchor17","text":""},{"name":"int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0)","link":"ProgramFlow.html#anchor24","text":"perform a final-state shower evolution on partons in the event event record. This could be used for externally provided simple events, or even parts of events, for which a complete generation is not foreseen. Since the mother source of the parton system is not known, one cannot expect as good accuracy as in a normal generation. When two different timelike shower instances are set up, it is the one used for showering in resonance decays that is used here. The forceTimeShower method can be used in conjunction with the forceHadronLevel one below. Further comments are found here. the first and last entry of the event record to be affected by the call. the maximum pT scale of emissions. Additionally, as always, the scale variable of each parton sets the maximum pT scale of branchings of this parton. Recall that this scale defaults to 0 if not set, so that no radiation can occur. when positive, it sets the maximum number of branchings that are allowed to occur in the shower, i.e. the shower may stop evolving before reaching the lower cutoff. The argument has no effect when zero or negative, i.e. then the shower will continue to the lower cutoff. Note: The method returns the number of branchings that has been generated."},{"name":"Zprime:atPrime","link":"NewGaugeBosonProcesses.html#anchor34","text":"axial coupling of t' quarks."},{"name":"double LHAup::pdf1()","link":"LesHouchesAccord.html#anchor65","text":""},{"name":"double Particle::e()","link":"ParticleProperties.html#anchor12","text":"the particle four-momentum components."},{"name":"Merging:doUNLOPSSubtNLO","link":"NLOMerging.html#anchor15","text":"This switch will allow the processing of POWHEG NLO events, to produce NLO subtraction terms for the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSTree , Merging:doUNLOPSLoop and Merging:doUNLOPSSubt have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested. Furthermore, it is necessary to set the value of Merging:nRecluster to one."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Particle::motherList()","link":"ParticleProperties.html#anchor95","text":"returns a vector of all the mother indices of the particle. This is derived from the mother1 , mother2 and status information as explained above. This list is empty for entries 0, 1 and 2, i.e. the 'system' in line 0 is not counted as part of the history. Normally the list contains one or two mothers, but it can also be more, e.g. in string fragmentation the whole fragmenting system is counted as mothers to the primary hadrons. Many particles may have the same motherList. Mothers are listed in ascending order."},{"name":"HiggsH1:coup2Hchg","link":"HiggsProcesses.html#anchor86","text":"The h^0(H_1^0) coupling to H^+- (in loops). Is sin(beta - alpha) + cos(2 beta) sin(beta + alpha) / (2 cos^2theta_W) in the MSSM."},{"name":"int ClusterJet::size()","link":"EventAnalysis.html#anchor20","text":"gives the number of jets found, with jets numbered 0 through size() - 1."},{"name":"Zprime:vd","link":"NewGaugeBosonProcesses.html#anchor4","text":"vector coupling of d quarks."},{"name":"string LHAup::getFileName()","link":"LesHouchesAccord.html#anchor89","text":"Return the name of the LHE file above."},{"name":"SecondHard:SingleW","link":"ASecondHardProcess.html#anchor8","text":"Scattering q qbar' &rarr; W^+-."},{"name":"double SigmaProcess::weightDecayFlav( EventAMPERSAND process)","link":"SemiInternalProcesses.html#anchor10","text":"is called to allow a reweighting of the simultaneous flavour choices of resonance decay products. Is currently only used for the q qbar &rarr; gamma*/Z^0 gamma*/Z^0 process, and will likely not be of interest for you."},{"name":"StringFlav:mesonSvector","link":"FlavourSelection.html#anchor7","text":"the relative production ratio vector/pseudoscalar for strange mesons."},{"name":"double Info::Q2Ren()","link":"EventInformation.html#anchor49","text":"the Q or Q^2 renormalization scale at which alpha_strong and alpha_electromagnetic were evaluated."},{"name":"HiddenValley:gg2UvUvbar","link":"HiddenValleyProcesses.html#anchor9","text":"Pair production g g &rarr; Uv Uvbar. Code 4902."},{"name":"ParticleDataEntry*  ParticleData::particleDataEntryPtr(int id)","link":"ParticleDataScheme.html#anchor88","text":"returns a pointer to the ParticleDataEntry object. The methods in the next section can then be used to manipulate this object."},{"name":"User Hooks","link":"UserHooks.html","text":"User Hooks Sometimes it may be convenient to step in during the generation process: to modify the built-in cross sections, to veto undesirable events or simply to collect statistics at various stages of the evolution. There is a base class UserHooks that gives you this access at a few selected places. This class in itself does nothing; the idea is that you should write your own derived class for your task. One simple derived class ( SuppressSmallPT ) comes with the program, mainly as illustration, and the main10.cc program provides a complete (toy) example how a derived class could be set up and used. There are eleven sets of routines, that give you different kinds of freedom. They are, in no particular order: (i) Ones that give you access to the event record in between the process-level and parton-level steps, or in between the parton-level and hadron-level ones. You can study the event record and decide whether to veto this event. (ii) Ones that allow you to set a scale at which the combined parton-level MPI+ISR+FSR downwards evolution in pT is temporarily interrupted, so the event can be studied and either vetoed or allowed to continue the evolution. (iii) Ones that allow you to to study the event after the first few ISR/FSR emissions, or first few MPI, so the event can be vetoed or allowed to continue the evolution. (iv) Ones that allow you to study the latest initial- or final-state emission and veto that emission, without vetoing the event as a whole. (v) Ones that give you access to the properties of the trial hard process, so that you can modify the internal Pythia cross section, alternatively the phase space sampling, by your own correction factors. (vi) Ones that allow you to reject the decay sequence of resonances at the process level. (vii) Ones that let you set the scale of shower evolution, specifically for matching in resonance decays. (viii) Ones that allow colour reconnection, notably in connection with resonance decays. (ix) Ones that allow an enhanced rate of rare shower splittings. (x) Ones that give you access to to hadronization parameters in each step in the hadronization process, and allows for a veto of individual hadrons. (xi) Ones that allow on-the-fly assignment of vertex (space-time) information in MPI+FSR+ISR. They are described further in the following numbered subsections. All the possibilities above can be combined freely and also be combined with the standard flags. An event would then survive only if it survived each of the possible veto methods. There are no hidden interdependencies in this game, but of course some combinations may not be particularly meaningful. For instance, if you set PartonLevel:all = off then the doVetoPT(...) and doVetoPartonLevel(...) locations in the code are not even reached, so they would never be called. Normally you would gather all your changes into one derived class. In some cases it may be more convenient to separate different functionalities. Therefore it is possible to hand in several user hooks. See the section on 'Multiple user hooks' at the bottom of this page for further information on this possibility. The effect of the vetoes of types (i), (ii) and (iii) can be studied in the output of the Pythia::stat() method. The 'Selected' column represents the number of events that were found acceptable by the internal Pythia machinery, whereas the 'Accepted' one are the events that also survived the user cuts. The cross section is based on the latter number, and so is reduced by the amount associated by the vetoed events. Also type (v) modifies the cross section, while types (iv), (vi) and (vii) do not. A warning. When you program your own derived class, do remember that you must exactly match the arguments of the base-class methods you overload. If not, your methods will be considered as completely new ones, and compile without any warnings, but not be used inside Pythia. So, at the debug stage, do insert some suitable print statements to check that the new methods are called (and do what they should). The basic components For a derived UserHooks class to be called during the execution, a pointer to an object of this class should be handed in with the Pythia::setUserHooksPtr( UserHooks*) method. The first step therefore is to construct your own derived class, of course. This must contain a constructor and a destructor. The initPtr method comes 'for free', and is set up without any intervention from you. Next you overload the desired methods listed in the sections below. These often come in pairs or triplets, where the first must return true for the last method to be called. This latter method typically hands you a reference to the event record, which you then can use to decide whether or not to veto. Often the event record can be quite lengthy and difficult to overview. The following methods and data member can then come in handy. (i) Interrupt between the main generation levels (ii) Interrupt during the parton-level evolution, at a pT scale During the parton-level evolution, multiparton interactions (MPI), initial-state radiation (ISR) and final-state radiation (FSR) are normally evolved downwards in one interleaved evolution sequence of decreasing pT values. For some applications, e.g  matrix-element-matching approaches, it may be convenient to stop the evolution temporarily when the 'hard' emissions have been considered, but before continuing with the more time-consuming soft activity. Based on these hard partons one can make a decision whether the event at all falls in the intended event class, e.g. has the 'right' number of parton-level jets. If yes then, as for the methods above, the evolution will continue all the way up to a complete event. Also as above, if no, then the event will not be considered in the final cross section. Recall that the new or modified partons resulting from a MPI, ISR or FSR step are always appended to the end of the then-current event record. Previously existing partons are not touched, except for the status, mother and daughter values, which are updated to reflect the modified history. It is therefore straightforward to find the partons associated with the most recent occurrence. An MPI results in four new partons being appended, two incoming and two outgoing ones. An ISR results in the whole affected system being copied down, with one of the two incoming partons being replaced by a new one, and one more outgoing parton. An FSR results in three new partons, two that come from the branching and one that takes the recoil. The story becomes more messy when rescattering is allowed as part of the MPI machinery. Then there will not only be a new system, as outlined above, but additionally some existing systems will undergo cascade effects, and be copied down with changed kinematics. In this subsection we outline the possibility to interrupt at a given pT scale, in the next to interrupt after a given number of emissions. (iii) Interrupt during the parton-level evolution, after a step These options are closely related to the ones above in section (ii), so we do not repeat the introduction, nor the possibilities to study the event record, also by using subEvent(...) and workEvent. What is different is that the methods in this section give access to the event as it looks like after each of the first few steps in the downwards evolution, irrespective of the pT scales of these branchings. Furthermore, it is here assumed that the focus normally is on the hardest subprocess, so that ISR/FSR emissions associated with additional MPI's are not considered. For MPI studies, however, a separate simpler alternative is offered to consider the event after a given number of interactions. (iv) Veto emissions The methods in this group are intended to allow the veto of an emission in ISR, FSR or MPI, without affecting the evolution in any other way. If an emission is vetoed, the event record is 'rolled back' to the way it was before the emission occurred, and the evolution in pT is continued downwards from the rejected value. The decision can be based on full knowledge of the kinematics of the shower branching or MPI. To identify where shower emissions originated, the ISR/FSR veto routines are passed the system from which the radiation occurred, according to the Parton Systems class (see Advanced Usage ). Note, however, that inside the veto routines only the event record has been updated; all other information, including the Parton Systems, reflects the event before the shower branching or MPI has taken place. (v) Modify cross-sections or phase space sampling This section addresses two related but different topics. In both cases the sampling of events in phase space is modified, so that some regions are more populated while others are depleted. In the first case, this is assumed to be because the physical cross section should be modified relative to the built-in Pythia form. Therefore not only the relative population of phase space is changed, but also the integrated cross section of the process. In the second case the repopulation is only to be viewed as a technical trick to sample some phase-space regions better, so as to reduce the statistical error. There each event instead obtains a compensating weight, the inverse of the differential cross section reweighting factor, in such a way that the integrated cross section is unchanged. Below these two cases are considered separately, but note that they share many points. One derived class is supplied as an example how this facility can be used to reweight cross sections in the same spirit as is done with QCD cross sections for the minimum-bias/underlying-event description: The second main case of the current section involves three methods, as follows. (vi) Reject the decay sequence of resonances Resonance decays are performed already at the process level, as an integrated second step of the hard process itself. One reason is that the matrix element of many processes encode nontrivial decay angular distributions. Another is to have equivalence with Les Houches input, where resonance decays typically are provided from the onset. The methods in this section allow you to veto that decay sequence and try a new one. Unlike the veto of the whole process-level step, in point (i), the first step of the hard process is retained, i.e. where the resonances are produced. For this reason the cross section is not affected here but, depending on context, you may want to introduce your own counters to check how often a new set of decay modes and kinematics is selected, and correct accordingly. The main method below is applied after all decays. For the production of a t tbar pair this typically means after four decays, namely those of the t , the tbar , the W+ and the W-. If Les Houches events are processed, the rollback is to the level of the originally read events. For top, that might mean either to the tops, or to the W bosons, or no rollback at all, depending on how the process generation was set up. (vii) Modify scale in shower evolution The choice of maximum shower scale in resonance decays is normally not a big issue, since the shower here is expected to cover the full phase space. In some special cases a matching scheme is intended, where hard radiation is covered by matrix elements, and only softer by showers. The below two methods support such an approach. Note that the two methods are not used in the TimeShower class itself, but when showers are called from the PartonLevel generation. Thus user calls directly to TimeShower are not affected. (viii) Allow colour reconnection PYTHIA contains only a limites set of possibilities for colour reconnection , and none of them are geared specifically towards rapidly decaying resonances. Notably, with the default PartonLevel:earlyResDec = off , resonances will only decay after colour reconnection has already been considered. Thus a coloured parton like the top may be reconnected but, apart from this external connection with the rest of the event, the top decay products undergo no colour reconnection. For PartonLevel:earlyResDec = on the resonance will decay earlier, and thus the decay products may undergo reconnections, but not necessarily by models that are specifically geared towards this kind of events. For tryout purposes, a user hook can be called directly after the resonance decays, and there modify the colour flow. This holds whether the resonance decay is handled early or late, but is especially appropriate for the latter default possibility. While intended specifically for resonance decays, alternatively it is possible to switch off the built-in colour reconnection and here implement your own reconnection model for the whole event. (ix) Enhanced rate of rare shower splittings PYTHIA also offers possibilities to enhance the frequency of rare splittings.  This is not a trivial task, since a simple 'upweighting' of splittings would produce a mismatch between emission and no-emission probabilities, leading to a violation of the principle that the parton shower should not change the inclusive (input) cross section. Nevertheless, a general algorithm that allows for increased emission probabilities, while keeping no-emission factors intact, was presented in Lon13a. In Lon13a two types of enhancements are proposed: those of 'regular' shower emissions, and those of trial shower emissions, the latter as part of the mandatory Sudakov reweighting in ME+PS merging schemes. Both of these possibilities are accessible through UserHooks , but cannot be used at the same time. The price to pay for these enhancements is that events come with a compensatory weight. The advantages of obtaining higher statistics for rare branchings thus is mitigated, and the usefulness has to be evaluated case by case. Currently enhancements of ISR and FSR branchings have been included. These enhancements are currently not phase-space dependent, i.e. emissions will be enhanced uniformly in phase space. It should also be noted that the threshold region for gluon branchings to a pair of heavy quarks, specifically g &rarr; c + cbar and g &rarr; b + bbar , are not enhanced in this algorithm. Technically it is because this case is handled separately in the code, but there also remain some physics issues to understand. To increase statistics of rare emissions in the showers, e.g. QED or weak radiation, Pythia supplies the following functions implementing the strategy of section 4 in Lon13a. In the context of merging, it can be beneficial to allow for enhanced trial emissions. As discussed in section 3 of Lon13a , this means that the Sudakov factors that are commonly generated by event vetoes based on trial emissions (see e.g. Lon11 ) are instead given by small but non-vanishing event weights. This can have advantages, since all events of an input sample will be retained. Pythia allows users to enhance trial emissions by using the following functions. Trial emission enhancements also necessitate corrective weights. These are handled internally, so that users only have to ensure that Info::mergingWeight() or Info::mergingWeightNLO() are correctly taken into account. A simple example of enhanced regular emissions is provided in main63.cc , whereas main64.cc illustrates the usefulness of enhanced trial emissions for expert users. (x) Modified hadronization The methods in this group are intended to allow for modifications of the string hadronization model, involving changes to hadronization parameters based on local properties of the string. Given information on the hadronization history of a single string,  parameters can be changed to control the selection of quark flavour, z and pT in string breaks. Furthermore there is a option to veto the creation of a hadron before it is added to the event record, thus repeating a step in the hadronization procedure. (xi) Vertex information The methods in this group can be used to add vertex information to produced particles, at creation time, in MPI, FSR and ISR. The assigned vertex information will afterwards be accessible as properties of the individual particles. Particles produced in other types of processes than the ones mentioned above will not have vertex information assigned (i.e. hard process, beam remnants etc.), neither will particles produced in the weak shower. Multiple user hooks In addition to the Pythia::setUserHooksPtr( UserHooks*) method there is a second Pythia::addUserHooksPtr( UserHooks*) method that works almost like the former, but it allows the addition of further user hooks. These are stored as a vector and all of them will be called consecutively at the respective locations where they are set up to be active. If two or more of them are active at the same location it is up to the user to ensure that the joint action is the one intended. In cases where weights are assigned the net result will be a weight that is is the product of them. In cases where vetoes are involved, a veto will be returned if either hook wants to veto, i.e. the no-veto survival probability is combined multiplicatively. It is not meaningful to let two hooks set the resonance scale or change fragmentation parameters, so warnings will be issued if this occurs."},{"name":"Vec4 BeamShape::deltaPA()","link":"BeamShape.html#anchor5","text":""},{"name":"Vec4 SlowJet::p(int i)","link":"EventAnalysis.html#anchor49","text":""},{"name":"void RotBstMatrix::reset()","link":"FourVectors.html#anchor86","text":"reset to no rotation/boost; i.e. the default at creation."},{"name":"int LHAup::mother1(int i)","link":"LesHouchesAccord.html#anchor41","text":""},{"name":"Photon:showUnres","link":"Photoproduction.html#anchor2","text":"Show the evolution steps of the beam photon in the event record, if on."},{"name":"ExtraDimensionsG*:GZZ","link":"ExtraDimensionalProcesses.html#anchor17","text":"Coupling between graviton and Z boson."},{"name":"ParticleData:muRun","link":"ParticleData.html#anchor4","text":"the u quark MSbar mass at 2 GeV scale."},{"name":"bool Info::atEndOfFile()","link":"EventInformation.html#anchor25","text":"true if a linked Les Houches class refuses to return any further events, presumably because it has reached the end of the file from which events have been read in."},{"name":"Diffraction:PomFluxRescale","link":"Diffraction.html#anchor34","text":"Rescale the Pomeron flux by this uniform factor. It should be 1 / PDF:PomRescale to preserve the convolution of Pomeron flux and PDFs, but for greater flxibility the two can be set separately."},{"name":"Init:showAllSettings","link":"MainProgramSettings.html#anchor4","text":"Print a list of all flag/mode/parameter/word settings. Warning: this will be a long list."},{"name":"BeamRemnants:allowJunction","link":"BeamRemnants.html#anchor19","text":"The off option is intended for debug purposes only, as follows. When more than one valence quark is kicked out of a baryon beam, as part of the multiparton interactions scenario, the subsequent hadronization is described in terms of a junction string topology. This description involves a number of technical complications that may make the program more unstable. As an alternative, by switching this option off, junction configurations are rejected (which gives an error message that the remnant flavour setup failed), and the multiparton interactions and showers are redone until a junction-free topology is found."},{"name":"Bottomonium:all","link":"OniaProcesses.html#anchor8","text":"Common switch for the group of bottomonium production, e.g. Upsilon and chi_b."},{"name":"double Particle::pT2()","link":"ParticleProperties.html#anchor42","text":"(squared) transverse momentum."},{"name":"friend Hist operator-(const HistAMPERSANDamp; h1, double f)","link":"Histograms.html#anchor35","text":""},{"name":"TimeShower:pTminWeak","link":"TimelikeShowers.html#anchor30","text":"Parton shower cut-off pT for weak branchings."},{"name":"bool Info::isLHA()","link":"EventInformation.html#anchor24","text":"has the process been generated from external Les Houches Accord information?"},{"name":"void Hist::takeLog(bool tenLog = true)","link":"Histograms.html#anchor21","text":"by default take 10-logarithm of current contents bin by bin. With optional argument false instead take e -logarithm of contents bin by bin. If to be used, then right before the histogram is output."},{"name":"Vec4 Particle::vDec()","link":"ParticleProperties.html#anchor60","text":"the decay vertex coordinates, in mm or mm/c. This decay vertex is calculated from the production vertex, the proper lifetime and the four-momentum assuming no magnetic field or other detector interference. It can be used to decide whether a decay should be performed or not, and thus is defined also for particles which PYTHIA did not let decay."},{"name":"bool ParticleData::isDiquark(int id)","link":"ParticleDataScheme.html#anchor71","text":"true for a diquark or antidiquark."},{"name":"Check:epTolErr","link":"ErrorChecks.html#anchor7","text":"Maximum allowed summed deviation of E , p_x , p_y and p_z between the incoming beams and the final state, as a fraction of the initial energy, above which the event is counted as aborted. (Unfortunately roundoff errors do not scale linearly with the energy, and also have a very long tail. So while most events at lower energies may be correct to better than 1e-10, at LHC it does not have to signal any fundamental bug if also the default tolerance above is violated occasionally.)"},{"name":"Merging:allowSQCDClustering","link":"CKKWLMerging.html#anchor53","text":"Allow clustering of gluon emission off squarks."},{"name":"HiggsH2:etaParity","link":"HiggsProcesses.html#anchor115","text":"The eta value of CP-violation in the HiggsH2:parity = 3 option."},{"name":"Higgs:useBSM","link":"HiggsProcesses.html#anchor22","text":"Master switch to initialize and use the two-Higgs-doublet states. If off, only the above SM Higgs processes can be used, with couplings as predicted in the SM. If on, only the below BSM Higgs processes can be used, with couplings that can be set freely, also found further down on this page."},{"name":"double Info::xGammaB()","link":"EventInformation.html#anchor67","text":"x fractions of lepton momenta carried by the photons."},{"name":"doubleAMPERSAND operator[](int i)","link":"FourVectors.html#anchor16","text":"returns component by index, where 1 gives p_x , 2 gives p_y , 3 gives p_z , and anything else gives e."},{"name":"ParticleDecays:allowPhotonRadiation","link":"ParticleDecays.html#anchor17","text":"Allow or not photon radiations in decays to a lepton pair, see above. Note: The current default is to have radiation switched off, in order to avoid double-counting of emissions if you link to an external QED-radiation program, as is the norm in many collaborations."},{"name":"Merging:Process","link":"CKKWLMerging.html#anchor6","text":"The string specifying the hard core process, in MG4/ME notation."},{"name":"HiggsBSM:qqbar2A3ttbar","link":"HiggsProcesses.html#anchor53","text":"Scattering q qbar &rarr; A^0(A_3^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1049."},{"name":"double CoupSM::vf2af2(int idAbs)","link":"StandardModelParameters.html#anchor39","text":"common quadratic combinations of the above couplings: e_f^2, v_f^2, a_f^2, e_f * v_f, v_f^2 + a_f^2."},{"name":"bool Pythia::forceRHadronDecays()","link":"ProgramFlow.html#anchor27","text":"perform decays of R-hadrons that were previously considered stable. This could be if an R-hadron is sufficiently long-lived that it may interact in the detector between production and decay, so that its four-momentum is changed. Further details are found here. Note: The method returns false if the decays fail. The event record is then not consistent and should not be studied."},{"name":"JetMatching:coneMatchHeavy","link":"JetMatching.html#anchor20","text":"The coneMatchHeavy parameter used when JetMatching:jetMatch = 1."},{"name":"WeakSingleBoson:ffbar2ffbar(s:gmZ)","link":"ElectroweakProcesses.html#anchor16","text":"Scattering f fbar &rarr; gamma^*/Z^0 &rarr; f' fbar'. Equivalent to process 221, but written as a 2 &rarr; 2 process, so that pT could be used as cut or ordering variable. Final-state flavour selection is based on the Z^0 allowed decay modes, and the WeakZ0:gmZmode options are implemented. Not included in the WeakSingleBoson:all set. Code 224."},{"name":"string Settings::output(string key, bool fullLine = true)","link":"SettingsScheme.html#anchor13","text":"provide the value of a variable as a character string, whatever the type. If the variable does not exist then unknown is returned. the name of the settings variable. If true then a whole 'line' is returned, ' key = value\n ', while if false only the value string."},{"name":"friend double cross4(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2,  const Vec4AMPERSAND v3)","link":"FourVectors.html#anchor37","text":"the cross-product of three four-vectors: v_i = epsilon_{iabc} v1_a v2_b v3_c."},{"name":"BeamRemnants:xGluonCutoff","link":"BeamRemnants.html#anchor18","text":"The gluon PDF is approximated with g(x) ~ (1 - x)^p / x , which integrates to infinity when integrated from 0 to 1. This cut-off is introduced as a minimum to avoid the problems with infinities."},{"name":"Merging:doUNLOPSLoop","link":"NLOMerging.html#anchor13","text":"This switch will allow the processing of POWHEG NLO events in the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSTree , Merging:doUNLOPSSubt and Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested."},{"name":"MergingHooks::setHardProcessPtr( HardProcess* myHardProcess)","link":"MatchingAndMerging.html#anchor3","text":""},{"name":"PhaseSpace:RsepMin","link":"PhaseSpaceCuts.html#anchor13","text":"The minimum separation R in (eta, phi) space between any two outgoing partons in QCD 2 &rarr; 3 processes."},{"name":"double Settings::parmDefault(string key)","link":"SettingsScheme.html#anchor43","text":""},{"name":"istream* LHAup::openFile(const char *fn, ifstream AMPERSANDifs)","link":"LesHouchesAccord.html#anchor82","text":""},{"name":"LeftRightSymmmetry:coupHtautau","link":"LeftRightSymmetryProcesses.html#anchor24","text":"Yukawa coupling for H^-- &rarr; tau- tau-."},{"name":"ExtraDimensionsUnpart:gg2llbar","link":"ExtraDimensionalProcesses.html#anchor79","text":"Scatterings g g &rarr; (U*) &rarr; l lbar. Code 5049."},{"name":"void ParticleData::checkTable(int verbosity)","link":"ParticleDataScheme.html#anchor21","text":"check that the particle decay table makes sense, especially for decays. level of checks. 0 is only minimal, e.g. if a particle has no open decay channels. 1, which is the level of the first method, provides warning if any individual channel is closed, except for resonances. 2 also prints the branching-ratio-averaged threshold mass. 11 and 12 are like 1 and 2, but also include resonances in the detailed checks."},{"name":"ExtraDimensionsUnpart:gg2Ug","link":"ExtraDimensionalProcesses.html#anchor71","text":"Scatterings g g &rarr; U g. Code 5045."},{"name":"SecondHard:generate","link":"ASecondHardProcess.html#anchor1","text":"Generate two hard scatterings in a collision between hadron beams. The hardest process can be any combination of internal processes, available in the normal process selection machinery, or external input. Here you must further specify which set of processes to allow for the second hard one, see the following."},{"name":"ParticleDecays:multRefMass","link":"ParticleDecays.html#anchor22","text":"The above multRefMass parameter."},{"name":"HiddenValley:kappa","link":"HiddenValleyProcesses.html#anchor4","text":"If the Fv have spin 1 then their production cross section depends on the presence of anomalous magnetic dipole moment, i.e. of a kappa different from unity. For other spins this parameter is not used."},{"name":"void Vec4::rot(double theta, double phi)","link":"FourVectors.html#anchor63","text":"rotate the three-momentum with the polar angle theta and the azimuthal angle phi."},{"name":"void ParticleData::list(int idList)","link":"ParticleDataScheme.html#anchor17","text":""},{"name":"MultipartonInteractions:a1","link":"MultipartonInteractions.html#anchor16","text":"When bProfile = 4 , this gives the a1 constant in the Gaussian width. When a1 = 0. , this reduces back to the single Gaussian case."},{"name":"aMC@NLO Matching","link":"aMCatNLOMatching.html","text":"aMC\@NLO Matching The aMC\@NLO package Fri02 attempts to automate the MC\@NLO matching procedure Fri02. MC\@NLO interprets the parton shower as NLO subtraction method, and removes unwanted parton-shower contributions by extending the subtraction scheme used to generate NLO fixed-order results. Upon showering, an NLO accurate prediction for inclusive observables is achieved. This makes MC\@NLO a convenient NLO+PS matching scheme. A consistent extended subtraction in the NLO fixed-order result makes analytic knowledge of the shower emission probability necessary. Once this is known, interfacing the (parton-shower specific) NLO calculation with the shower is straightforward. To allow for a fast, automatic generation of shower subtractions that are used in the fixed-order calculation, Pythia allows to generate emissions with a 'global' recoil scheme, in which the recoil of an emission is shared among all final state particles. When using aMC\@NLO, this global recoil must be switched on. Please see Timelike Showers for details and options. A minimal set of settings necessary for a consistent treatment of aMC\@NLO inputs is &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; SpaceShower:pTmaxMatch = 1 &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; SpaceShower:pTmaxFudge = 1. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; TimeShower:pTmaxMatch = 1 &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; TimeShower:pTmaxFudge = 1. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; SpaceShower:MEcorrections = off &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; TimeShower:MEcorrections = off &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; TimeShower:globalRecoil = on &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; TimeShower:weightGluonToQuark = 1 and further (process-specific) settings related global recoils. Some comments are in order. The settings SpaceShower:pTmaxMatch = 1 , SpaceShower:pTmaxFudge = 1. , TimeShower:pTmaxMatch = 1 , TimeShower:pTmaxFudge = 1. are included to ensure that the correct parton shower starting scale (i.e. the scale set when generating the subtractions in MC\@NLO) is used within Pythia. Note that the last three options are default in Pythia8, and that the first option differs from the default only if the input state does not contain final state partons. Matrix element corrections to the parton shower splitting kernels have to be switched off by SpaceShower:MEcorrections = off and TimeShower:MEcorrections = off. This is necessary because the matrix element corrections are not suitable for showers in the global recoil scheme, and because it is not viable to include process-specific shower probabilities in an automatic framewrok like aMC\@NLO. TimeShower:globalRecoil = on is necessary. Formally, it is allowed to switch back to a local recoil treatment beyond the first proposed emission of any of the hard scattering partons in Born-type events. Pythia offers three choices at which stage the global recoil is dropped in favour of a local strategy. It is necessary to supplement the setting TimeShower:globalRecoil = on by additional settings specifying which global recoil strategy should be used. As these choices are up to the user, please consult Timelike Showers for details on these options. Finally, TimeShower:weightGluonToQuark = 1 is not default any longer, but was it at the time the subtractions were first implemented, and so is required  for consistency until further notice."},{"name":"HiggsHchg:tanBeta","link":"HiggsProcesses.html#anchor108","text":"The tan(beta) value, which leads to an enhancement of the H^+- coupling to down-type fermions and suppression to up-type ones. The same angle also appears in many other places, but this particular parameter is only used for the charged-Higgs case."},{"name":"Merging:doXSectionEstimate","link":"CKKWLMerging.html#anchor29","text":"If on, estimate cross section after merging scale cut. This switch has to be used in conjunction with a merging scale definition (e.g. Merging:doPTLundMerging = on ). Then, this merging scale definition will be used as a cut on the input events. After the requested number of Monte Carlo events, the cross section after the cut can be extracted by inferring the Info::sigmaGen() method, and the number of accepted events by using Info::nAccepted()"},{"name":"virtual double TimeShower::getSplittingProb( const  EventAMPERSAND event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor24","text":"This function should return the probability of an emission of the particle with index iEmt from the particles with index iRad and iRec All indices are relative to the input event. The identifier name can be used for additional flexibility."},{"name":"Zprime:atau","link":"NewGaugeBosonProcesses.html#anchor25","text":"axial coupling of tau leptons."},{"name":"bool Particle::hasVertex()","link":"ParticleProperties.html#anchor36","text":"production vertex has been set; if false then production at the origin is assumed."},{"name":"int Particle::iBotCopyId(bool simplify = false)","link":"ParticleProperties.html#anchor94","text":"also trace top mother and bottom daughter, but do not require carbon copies, only that one can find an unbroken chain, of mothers or daughters, with the same flavour id code. When it encounters ambiguities, say a g &rarr; g g branching or a u u &rarr; u u hard scattering, it will stop the tracing and return the current position. It can be confused by nontrivial flavour changes, e.g. a hard process u d &rarr; d u by W^+- exchange will give the wrong answer. These methods therefore are of limited use for common particles, in particular for the gluon, but should work well for 'rare' particles. By default all mothers and daughters are studied in each step, but with simplify = true only the first and last mother/daughter are checked, which saves time and almost always gives the same result."},{"name":"virtual bool UserHooks::canBiasSelection()","link":"UserHooks.html#anchor33","text":"In the base class this method returns false. If you redefine it to return true then the method biasSelectionBy(...) will allow you to modify the phase space sampling, with a compensating event weight, such that the cross section is unchanged. You cannot combine this kind of reweighting with the selection of a second hard process."},{"name":"HiggsSM:gmgm2H","link":"HiggsProcesses.html#anchor9","text":"Scattering gamma gamma &rarr; H^0 via loop contributions primarily from top and W. Code 903."},{"name":"LeftRightSymmmetry:all","link":"LeftRightSymmetryProcesses.html#anchor1","text":"Common switch for the group of implemented processes within a left-right-symmetric scenario."},{"name":"StringFlav:heavyLeadingBSup","link":"FlavourSelection.html#anchor40","text":"extra suppression of leading-baryon production for a heavy-quark jet, i.e. c or b , when suppressLeadingB = on. Thus 0 means no leading-baryon production at all, while 1 means full rate."},{"name":"HiggsBSM:bg2H+-t","link":"HiggsProcesses.html#anchor56","text":"Scattering b g &rarr; H^+ tbar. At hadron colliders this is the dominant process for single-charged-Higgs production. Code 1062."},{"name":"int Info::nFSRinProc()","link":"EventInformation.html#anchor77","text":""},{"name":"NLO Merging","link":"NLOMerging.html","text":"NLO Merging Pythia offers two NLO merging approaches. Both of these methods have been presented in Lon13. The goal of NLO merging is to extend tree-level multi-jet merging methods to next-to-leading order accuracy in QCD, for every available jet multiplicity. If for example NLO calculations for Higgs + 0 jet, Higgs + 1 jet and Higgs + 2 jets were available, NLO merging allows to simultaneously describe 0-, 1- and 2-jet observables with NLO accuracy. Further jets can, depending on additional tree-level input, be described by additional tree-level matrix elements. In the example, it would be possible to achieve NLO accuracy for 0-, 1- and 2-jet observables, tree-level accuracy for 3-, 4- and 5-jet configurations, and use the parton shower approximation for events with more than five jets. The two NLO merging methods implemented in Pythia are called NL 3 (for Nils Lavesson + Leif L&ouml;nnblad) and UNLOPS (for unitarised NLO+PS merging). Both of these schemes require Les Houches Event File input that is generated by tree-level or NLO matrix element generators. Currently, Pythia requires NLO input generated within the POWHEG framework. The generation of sensible input will be discussed below. The two NLO merging methods are illustrated in the sample main programs main87.cc (introducing NL 3 ) and main88.cc (introducing UNLOPS). Before describing these programs, we would like to outline the differences between the two approaches. NL 3 is a generalisation of CKKW-L tree-level merging. The main idea of NL 3 is to start from CKKW-L-reweighted multi-jet merging, and replace the &alpha; s n+0 - and &alpha; s n+1 -terms by the NLO result of POWHEG. This 'replacement' means that we subtract the &alpha; s n+0 - and &alpha; s n+1 -terms from the CKKW-L-reweighted tree-level samples, and add another sample -- the POWHEG input. All 'higher orders' are unchanged w.r.t. CKKW-L. We have implemented the 'inclusive' scheme of Lon13 in Pythia. This means that the POWHEG input will contain contributions for hard, resolved real emission jets, which are already taken care of by higher-multiplicity samples in CKKW-L. Thus, explicit phase space subtractions are also included. The sample program main87.cc , together with the input file main87.cmnd , illustrates the procedure. UNLOPS is a generalisation of the UMEPS multi-jet merging scheme. Since UMEPS is already slightly more complicated than CKKW-L, this makes UNLOPS more complicated than NL 3. The basic idea however remains the same: Start from a tree-level merging scheme (in this case UMEPS), remove all undesirable &alpha; s n+0 - and &alpha; s n+1 -terms from this result, and add back the 'correct' description via POWHEG input samples. Again, since the 'inclusive' scheme of Lon13 was implemented in Pythia, it is necessary to handle explicit phase space subtractions. Similar to UMEPS, UNLOPS further ensures that the lowest-multiplicity cross section is given by the NLO result. This means that the UMEPS philosophy of 'subtract what you add' needs to be extended to multi-leg NLO inputs. UNLOPS is a theoretically more appealing definition of NLO merging than NL 3 , and should thus be considered the preferred choice. However, we believe it valuable to include both methods into Pythia, so that the variation of NLO merged results due to different NLO merging schemes can be studied in situ. Furthermore, NLO merging can be outlined more pedagogically when starting from NL 3. The two NLO merging methods share parts of code with CKKW-L and UMEPS, and correspondingly share many input settings with these schemes. In particular, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( Merging:Process ) needs to be defined exactly as in CKKW-L (see Defining the hard process in the CKKW-L documentation ). &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( Merging:TMS ) has to be set. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons in tree-level events ( Merging:nJetMax ) has to be set. All settings listed under the sections ' Matrix element merging and HepMC output for RIVET ' and ' Further variables ' in  the CKKW-L documentation can be accessed in NLO merging as well. Furthermore, the Merging:nRecluster switch (see the UMEPS documentation ) is important.  Also, all MergingHooks routines that allow for user interference in CKKW-L merging are also usable for NLO merging -- with the exception of a user-defined merging scale. The NLO merging schemes currently implemented in Pythia do not allow for a merging scale definition that differs from the parton shower evolution variable. Since this merging scale definition is not completely obvious, the NLO merging schemes also share the Merging:enforceCutOnLHE switch with CKKW-L. In this way, it is possible to use LHE files that are regularised only with weak cuts as input, while the merging machinery imposes the stronger merging scale cut automatically. This means that no merging scale implementation is required from the user side, but also means that it is the user's responsibility to ensure that the cuts used for generating input LHE files are always looser than the cut given by the merging scale value Merging:TMS. This will lead to warnings of the form ' Les Houches Event fails merging scale cut. Cut by rejecting event '. These warning should rather be regarded as information. An example of inclusive matrix element generation cuts would be pT jet = 5 GeV , &Delta;R jetA jetB = 0.01 and Q jetA jetB = 5 GeV , if NLO merging with a desired merging scale value of Merging:TMS = 15 is attempted for Higgs + jets events at the LHC. In the following, we will first describe the generation of NLO input samples, and list input settings for NLO merging in Pythia. Then, we will examine the sample main programs main87.cc and main88.cc , which implement NL 3 and UNLOPS merging, respectively. Inputs for NLO merging The NLO merging schemes in Pythia currently require Les Houches Event File input. To perform a merging with up to M additional partons described by tree-level matrix elements, and with up to N &le; M-1 additional partons at NLO accuracy, the user needs to supply &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; LHE files for 0... M additional partons, taken from a tree-level matrix element generator, and &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; LHE files for 0... N additional partons, taken from a POWHEG NLO generator. All input files need to be regularised, if they contain additional partons. Large files with fairly inclusive (i.e. loose) cuts are recommended. The input LHE files should further be generated with fixed renormalisation and factorisation scales. (In the POWHEG-BOX program, this means using the settings runningscales 0, btlscalereal 1, btlscalect 1, ckkwscalup 0. Some older processes in the POWHEG-BOX program need the input runningscale 0 instead of runningscales 0 .) When attempting NLO merging, the following Pythia settings are relevant. All further settings will be discussed while examining the sample main programs. NL 3 merging with main87.cc NL 3 -style NLO merging in Pythia is illustrated by the sample main program main87.cc. This program works together with an input file (e.g. main87.cmnd ) for Pythia settings, and requires LHE input files that follow the naming convention name_tree_#nAdditionalJets.lhe (tree-level samples) and name_powheg_#nAdditionalJets.lhe (POWHEG NLO samples). main87.cc produces HepMC event output Dob01 , which can be used for analysis (e.g. using RIVET Buc10 ), or as input for detector simulations. For users not familiar with HepMC output, it is of course possible remove the HepMC code in the sample program, and use Pythia's histogramming routines instead. Histograms should then be filled as indicated for the histPTFirstSum histograms in main84.cc , i.e. using weightNLO*normhepmc. If the user only wants to change the number of requested events ( Main:numberOfEvents ), the hard process ( Merging:Process ), the merging scale value ( Merging:TMS ) and the maximal number of additional tree-level or NLO-accuracte jets ( Merging:nJetMax and Merging:nJetMaxNLO , respectively), and HepMC output is desired, then there is no need to change the main87.cc code. The input LHE files are also part of the (command line) input for main87.exe. The default settings in main87.cmnd are intended to work with the (very short) sample LHEF inputs ( w_production_tree_0.lhe , w_production_tree_1.lhe , w_production_tree_2.lhe and w_production_powheg_0.lhe , w_production_powheg_1.lhe ). For these input files, the main87.exe executable can be run with the command ./main87.exe main87.cmnd w_production myhepmc.hepmc to produce a file myhepmc.hepmc of NLO merged HepMC event output. All mandatory Pythia input settngs have been outlined earlier. Please refrain from adding input switches than invoke any other merging scheme (e.g. e.g. Merging:doKTMerging ) into the input file that you want to use in conjunction with main87.cc. In the following, we will explain main87.cc in depth. Users who are willing to accept the default choices do not need to know all details, but are still encouraged to read further. Program flow main87.cc can be divided into four steps: &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 1. Estimate the cross section for tree-level and NLO samples after the merging scale cut. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2. Produce reweighted tree-level    events, which do not contain &alpha; s 0 -    and &alpha; s 1 -terms. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3. Add POWHEG NLO events. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 4. Subtract phase space points with an    extra (real-emission) jet above the merging scale from the POWHEG result,    since such configurations have already been taken into account by    processing other samples. The first step is necessary to produce the correct weights for HepMC output events. The estimation of tree-level cross sections after the merging scale cut is generated by invoking the switch Merging:doXSectionEstimate together with Merging:doNL3Tree. In this configuration, the latter switch will only act to define the merging scale.  After the tree-level cross sections have been estimated, main87.cc estimates the NLO cross sections after application of the merging scale cut, by inferring Merging:doXSectionEstimate together with Merging:doNL3Loop. Again, in this configuration, the latter switch only acts as the merging scale definition. When generating the estimates, all showering, multiparton interactions and hadronisation is turned off to not unnecessarily waste processor time. For all estimates, is further mandatory to set the value of Merging:nRequested to the jet multiplicity of the current event sample (e.g. to '2' for a sample containing W + 2 jet events). This is necessary in order to correctly apply the merging scale cut. POWHEG NLO input files for W + 1 jet e.g. contain W + 1 jet and W + 2 jet (i.e. real emission) kinematics. However, the merging scale cut aims at regularising the 'underlying Born' configuration (i.e. the W + 1 states in our example). Setting Merging:nRequested = 1 for the  W + 1 jet POWHEG sample ensures that even for real-emission (W + 2 jet) kinematics, the merging scale cut is applied to W + 1 jet states. After the cross section estimation step, main87.cc proceeds to perform the actual merging. Before explaining this part, we would like to make some comments about K-factors. main87.cc is prepared to use fixed K-factors to rescale the weight of tree-level events. This rescaling does not affect the NLO accuracy of the method, and was investigated in Lon13. By default, main87.cc does not use K-factors. However, if the user wants to include K-factors, this can be done by using the following input settings. If the variables k0, k1, k2 in main87.cc are set to non-unity values, K-factors will be applied. The K-factor of highest jet multiplicity will then be used to also rescale tree-level samples with a number of additional jets beyond the number of the highest-multiplicity real-emission sample. If we, for example, attempt an NLO merging of W+0 jet and W+1 jet at NLO accuracy, and with W+&le;4 jets at tree-level accuracy, then Merging:kFactor2j is used to rescale the W+2 jet , W+3 jets and W+4 jets tree-level samples. We recommend to not include a K-factor rescaling of the tree-level samples. Let us turn to the production of NLO merged events. The first step in the procedure is to generate reweighted tree-level samples. This is implemented by using the following switch. The weight of tree-level events can be accessed by calling the function double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, should be used as event weight (or weight of histogram bins). For Merging:doNL3Tree = on , the weight double Info::mergingWeightNLO() contains the CKKW-L weight, subtracted, if necessary, by &alpha; s 0 - and &alpha; s 1 -terms. This weight can become negative. As an example, imagine we attempt an NLO merging of W + 0 jet and W + 1 jet at NLO accuracy, and with  W + 2 jets at tree-level accuracy. This weight will then be &nbsp; Info::mergingWeightNLO() = CKKW-L-weight for zero jets  - &alpha; s 0 -terms  - &alpha; s 1 -terms for events in the zero-jet sample, &nbsp; Info::mergingWeightNLO() = CKKW-L-weight for one jet  - &alpha; s 0 -terms  - &alpha; s 1 -terms for events in the one-jet sample, and &nbsp; Info::mergingWeightNLO() = CKKW-L-weight for two jets for events in the two-jet sample. After the tree-level events have been reweighted, main87.cc will move on to process the POWHEG NLO input. This is done by switching to the following flag. Also in this case, the NLO merging weight of the events can be accessed by calling the function double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For Merging:doNL3Loop = on , the weight double Info::mergingWeightNLO() is either one or zero (see Appendix E in Lon13 ).  After the processing of POWHEG NLO events, main87.cc continues by generating explicit phase space subtractions. This is facilitated by the following switch. These contributions are necessary because we have implemented the 'inclusive scheme' of Lon13 in Pythia. The benefit of this scheme is the user does not have to intrusively change the POWHEG-BOX program to implement very particular cuts. Let us explain this comment with an example (a more detailed explanation of the idea is given in Appendix A.2 of Lon13 ). When generating W + 0 jet events with the POWHEG-BOX program, the output LHE files will contain W  + 1 jet real emission events. Some of these events will contain a jet above the merging scale. However, in NLO merging methods, such configurations have already been included by a separate W + 1 jet sample. Thus, to avoid counting such events twice, we have to remove the configurations from the POWHEG-BOX output. We choose to remove such events by explicit subtraction. As always, the NLO merging weight of the events can be accessed by calling the function double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For Merging:doNL3Subt = on , the weight double Info::mergingWeightNLO() is either one or zero (see Appendix E in Lon13 ). After these steps, all necessary events for NL 3 merging have been produced. main87.cc finishes by returning the NL 3 -merged total cross section. UNLOPS merging with main88.cc UNLOPS-style NLO merging in Pythia is illustrated by the sample main program main88.cc , which relies on an input file (e.g. main88.cmnd ) for Pythia settings. As for all merging methods in Pythia, main88.cc requires LHE input files. To use main88.cc without any changes, these input files should follow the naming convention name_tree_#nAdditionalJets.lhe (for tree-level samples) and name_powheg_#nAdditionalJets.lhe (for POWHEG NLO samples). main88.cc produces HepMC event output, which can e.g. be analysed with RIVET, or used as input for detector simulations. For users not familiar with HepMC output, it is of course possible remove the HepMC code in the sample program, and use Pythia's histogramming routines instead. Histograms should then be filled as indicated for the histPTFirstSum histograms in main84.cc , i.e. using weightNLO*normhepmc. As for NL 3 , it is not necessary to change main88.cc if the user is only interested in changing standard settings. Thus, if the user only wants to change the number of requested events ( Main:numberOfEvents ), the hard process ( Merging:Process ), the merging scale value ( Merging:TMS ) and the maximal number of additional tree-level or NLO-accuracte jets ( Merging:nJetMax and Merging:nJetMaxNLO , respectively), and HepMC output is desired, then there is no need to change the main88.cc code. The input LHE files are also part of the (command line) input for main88.exe. The default settings in main88.cmnd are intended to work with the (very short) sample LHEF inputs ( w_production_tree_0.lhe , w_production_tree_1.lhe , w_production_tree_2.lhe and w_production_powheg_0.lhe , w_production_powheg_1.lhe ). For these input files, the main88.exe executable can be run with the command ./main88.exe main88.cmnd w_production myhepmc.hepmc to produce a file myhepmc.hepmc of UNLOPS merged HepMC event output. Please refrain from adding input switches than invoke any other merging scheme (e.g. Merging:doKTMerging ) into the input file that you want to use in conjunction with main88.cc. In the following, we will explain main88.cc in depth. To not be overly repetitive, we will at times refer to the relevant parts in the discussion of main87.cc. Users who are willing to accept the default choices do not need to know all details, but are still encouraged to read further. Program flow main88.cc can be divided into five steps: &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 1. Estimate the cross section for tree-level and NLO samples after the merging scale cut. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2. Produce reweighted tree-level    events, which do not contain &alpha; s 0 -    and &alpha; s 1 -terms. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3. Add POWHEG NLO events. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 4. Subtract integrated, reweighted    tree-level events, to ensure that the inclusive NLO cross section remains    intact upon inclusion of multi-jet tree-level events. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 5. Subtract integrated POWHEG NLO    events, to ensure that the inclusive NLO cross section remains    intact upon inclusion of multi-jet tree-level events. The estimation of cross sections after the application of the merging scale cut is nearly identical to the first step in main87.cc , and we refer to the first paragraph of the 'Program flow' discussion for main87.cc for details. For main88.cc , the flags Merging:doUNLOPSTree or Merging:doUNLOPSLoop supply the merging scale definition used in the cross section estimation. After the cross section estimation step, main88.cc proceeds to perform the actual NLO merging. The discussion of K-factors given in the NL 3 section (i.e. of Merging:kFactor0j , Merging:kFactor1j and Merging:kFactor2j ) also applies to main88.cc. Although UNLOPS is considerably more stable than NL 3 upon changing the K-factors, we do not recommend the use of K-factors. The production of UNLOPS-merged events with main88.cc starts by generating reweighted tree-level events. The processing of tree-level events can be invoked by setting the following flag. The weight of tree-level events is returned by the function double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, should be used as event weight (or weight of histogram bins). For Merging:doUNLOPSTree = on , the weight double Info::mergingWeightNLO() contains the UMEPS weight, subtracted, if necessary, by &alpha; s 0 - and &alpha; s 1 -terms. This weight can become negative. As an example, assume that we attempt an UNLOPS merging of W + 0 jet and W + 1 jet at NLO accuracy, and with  W + 2 jets at tree-level accuracy. This weight will then be &nbsp; Info::mergingWeightNLO() = UMEPS-weight for one jet  - &alpha; s 0 -terms  - &alpha; s 1 -terms for events in the one-jet sample, and &nbsp; Info::mergingWeightNLO() = UMEPS-weight for two jets for events in the two-jet sample. After reweighted tree-level events have been generated, main88.cc processes the POWHEG NLO input files. This is facilitated by the following switch. The NLO merging weight of the events can be accessed by calling the function double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For Merging:doUNLOPSLoop = on , the weight double Info::mergingWeightNLO() is either one or zero (see Appendix E in Lon13 ). After processing the POWHEG NLO events, main88.cc continues by generating the reweighted subtraction terms of UMEPS. This part is implemented by setting the following flag. By using this switch, main88.cc ensures that the inclusive cross section is preserved. At variance with UMEPS however, the event weight contains the UMEPS weight, subtracted, if necessary, by &alpha; s +0 - and &alpha; s 1 -terms. Otherwise, &alpha; s n+0 - and &alpha; s n+1 -terms of the UMEPS procedure would be introduced, although our goal is to describe all &alpha; s n+0 - and &alpha; s n+1 -terms by n-jet POWHEG input. The weight of these integrated, subtractive tree-level events is, as always, returned by the function double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, and with -1 , should be used as event weight (or weight of histogram bins). As for the case of tree-level events in UNLOPS, this weight can become negative. For the example given before, i.e. attempting an UNLOPS merging of W + 0 jet and  W + 1 jet at NLO accuracy, and with W + 2 jets at tree-level accuracy, this weight will be &nbsp; Info::mergingWeightNLO() = UMEPS-weight for the integrated  one-jet sample - &alpha; s 0 -terms  - &alpha; s 1 -terms for events in the integrated one-jet sample, and &nbsp; Info::mergingWeightNLO() = UMEPS-weight for the integrated  two-jet sample for events in the integrated two-jet sample. This choice of weights already incorporates the fact that we have implemented the 'inclusive scheme' of Lon13 , meaning that the 'explicit phase space subtractions' of NL 3 are (partially) included though these weights. To ensure that the NLO inclusive cross section is unchanged, UNLOPS further requires the introduction of another sample. If POWHEG NLO events with one or more jets are included, it is necessary to subtract these samples in an integrated form. In main88.cc , this is done by setting the following flag. This sample also provides some 'explicit phase space subtractions' of NL 3 , which are necessary because we implemented the 'inclusive scheme' of Lon13. Let us again look at the example of UNLOPS merging of W + 0 jet and W + 1 jet at NLO accuracy. The integrated  W + 1 jet NLO events, which are produced by the setting Merging:doUNLOPSSubtNLO = on , contain a tree-level part. This part will exactly cancel the real-emission events with one jet above the merging scale in the  W + 0 jet NLO events. The NLO merging weight of these 'integrated' events can be accessed by calling the function double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For Merging:doUNLOPSSubtNLO = on , the weight double Info::mergingWeightNLO() is either one or zero (see Appendix E in Lon13 ). After these five steps (estimation of cross sections, tree-level processing, POWHEG processing, integrated tree-level processing, integrated POWHEG processing) we have produced a UNLOPS-merged HepMC event file. main88.cc finishes by returning the UNLOPS-merged total cross section. NLO merging and 'exclusive' NLO inputs Currently, both sample main programs for NLO merging ( main87.cc and main88.cc ) are intended for 'inclusive' POWHEG input. Inclusive input means that all real emission phase space points are included in the POWHEG output files. In order to avoid double counting with higher-multiplicity matrix elements, it is then necessary remove phase space points with too many jets from the real-emission configurations. This can be done by introducing explicit phase space subtractions. Another way of removing the undesired configurations is by implementing a cut in the NLO generator. This is not a completely trivial task, since it is necessary to ensure numerical stability and the correct cancellation of (finite) dipole regularisation terms. One way of producing such exclusive NLO output is by setting the (tree-level) real-emission matrix element in the NLO generator to zero if the real-emission phase space point contains too many jets above the merging scale. This will however not be numerically stable for too low merging scale values. We should be very clear that using exclusive NLO input is not recommended, since it requires hacking the NLO generator.  Only for the expert user, we briefly summarise the necessary changes for using exclusive NLO input. For the moment, assume that the NLO input has been produced in an 'exclusive' way. This input can then be processed by some trivial changes in main87.cc : estimate the cross section for tree-level and NLO samples after the merging scale cut, still using inclusive NLO samples, remove the last part of main87.cc , i.e. the part that produces explicit phase space subtractions, and use the exclusive NLO files as input files for the processing of 'POWHEG NLO files'. The changes to main88.cc (implementing UNLOPS) are slightly more complicated. This is the case because the weights of integrated tree-level samples change when using exclusive input, as can be seen in Appendix D in Lon13. The correct weights can be produced by Pythia by using the following flag. Then, it is necessary to add code for processing another sample to main88.cc , since when using exclusive inputs, it is also necessary to enforce two integrations on tree-level events (the '&uarr;'-contributions in Appendix D of Lon13 ). This can be achieved by adding the following code at the end of main88.cc. cout << endl << endl << endl;  cout << 'Shower subtractive events' << endl;   // Switch on processing of counter-events.  pythia.settings.flag('Merging:doUNLOPSTree',false);  pythia.settings.flag('Merging:doUNLOPSLoop',false);  pythia.settings.flag('Merging:doUNLOPSSubt',true);  pythia.settings.flag('Merging:doUNLOPSSubtNLO',false);  pythia.settings.mode('Merging:nRecluster',2);   nMaxCT      = nMaxNLO+1;  njetcounterCT  = nMaxCT;  iPathSubt    = iPath + '_tree';   while(njetcounterCT >= 2){    // From njet, choose LHE file    stringstream in;    in  << '_' << njetcounterCT << '.lhe';    string LHEfile = iPathSubt + in.str();    cout << endl << endl << endl       << 'Start subtractive treatment for ' << njetcounterCT << ' jets\n'       << 'Recluster at least 2 times' << endl;    pythia.readString('Beams:frameType = 4');    pythia.settings.word('Beams:LHEF', LHEfile);    pythia.settings.mode('Merging:nRequested', njetcounterCT);    pythia.init();    // Remember position in vector of cross section estimates.    int iNow = sizeLO-1-njetcounterCT;    // Start generation loop    for( int iEvent=0; iEvent < nEvent; ++iEvent ){      // Generate next event     if( !pythia.next() ) {      if( pythia.info.atEndOfFile() ) break;      else continue;     }      // Get event weight(s).     double weightNLO  = pythia.info.mergingWeightNLO();     double evtweight  = pythia.info.weight();     weightNLO      *= evtweight;     // Do not print zero-weight events.     if ( weightNLO == 0. ) continue;      // Construct new empty HepMC event.     HepMC::GenEvent* hepmcevt = new HepMC::GenEvent();     // Get correct cross section from previous estimate.     double normhepmc = -1*xsecLO[iNow] / nAcceptLO[iNow];     // Set hepmc event weight.     hepmcevt->weights().push_back(weightNLO*normhepmc);     // Fill HepMC event.     ToHepMC.fill_next_event( pythia, hepmcevt );     // Add the weight of the current event to the cross section.     sigmaTotal += weightNLO*normhepmc;     errorTotal += pow2(weightNLO*normhepmc);     // Report cross section to hepmc.     HepMC::GenCrossSection xsec;     xsec.set_cross_section( sigmaTotal*1e9, pythia.info.sigmaErr()*1e9 );     hepmcevt->set_cross_section( xsec );     // Write the HepMC event to file. Done with it.     ascii_io << hepmcevt;     delete hepmcevt;    } // end loop over events to generate    // print cross section, errors    pythia.stat();    // Restart with ME of a reduced the number of jets    if( njetcounterCT > 2 )     njetcounterCT--;    else     break;   } Further variables More advanced manipulations of the merging machinery are of course possible, and additional switches can be found at the end of the CKKW-L tree-level merging documentation. Here, we only document switches that only apply to NLO merging."},{"name":"double Info::pTmaxFSR()","link":"EventInformation.html#anchor81","text":"Maximum pT scales set for MPI, ISR and FSR, given the process type and scale choice for the hard interactions. The actual evolution will run down from these scales."},{"name":"void ParticleDataEntry::setIsVisible(bool isVisible)","link":"ParticleDataScheme.html#anchor128","text":""},{"name":"Charmonium:states(3DJ)","link":"OniaProcesses.html#anchor33","text":"The 3DJ charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"unsigned int Info::getWeightsCompressedSize()","link":"EventInformation.html#anchor124","text":""},{"name":"ExtraDimensionsG*:qg2G*q","link":"ExtraDimensionalProcesses.html#anchor5","text":"Scatterings q g &rarr; G^* q. Code 5004."},{"name":"Diffraction:primKTwidth","link":"Diffraction.html#anchor23","text":"The width of Gaussian distributions in p_x and p_y separately that is assigned as a primordial kT to the two beam remnants when a gluon is kicked out of a diffractive system."},{"name":"LesHouches:setQuarkMass","link":"LesHouchesAccord.html#anchor72","text":"setting of mass for final-state quarks. The reason here is that some matrix-element generators assume all quarks to be massless, except for the top, so as to simplify calculations. Especially for c and b quarks this is a poor approximation, although PYTHIA most of the time still manages to shower and hadronize even such events. The reason is the resilience of the string fragmentation model, where the excess gluons near (in colour and momentum) to a massless b are 'eaten up' when string fragmentation needs to gather enough invariant mass to give to the B hadron. Nevertheless it is an uncomfortable situation, to be avoided where possible. For d , u and s quarks the issue is less critical. Incoming or intermediate quarks are not affected by this procedure. all quark masses are taken from the Les Houches input. if the input c or b mass is more than 50% away from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. if the input mass, for all quarks except the top, is more than 50% away from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. Warning: when the mass is changed, also energy and/or momentum need to be shifted. This cannot be done for the quark in isolation, but should be made so as to preserve the energy and momentum of the event as a whole. An attempt is therefore made to find another final-state particle recoiler that can transfer the appropriate amount of energy and momentum. The recoiler may be unstable, and if so the transfer is inherited by its decay products. The choice is straightforward if only two final-state particles exist, or in a two-body decay of an intermediate resonance. If no recoiler is found this way a matching opposite-coloured parton is searched for. Should also this fail the potential final-state recoiler with largest relative invariant mass is picked. In either case, if the transfer fails because the intended recoiler has too little energy to give up, then instead the energy is recalculated for the new mass without any transfer. The energy violation is partly compensated by changed energies for the incoming partons to the hard collision if LesHouches:matchInOut = true , but not always perfectly. One possibility then is to change the tolerance to such errors."},{"name":"void Particle::rescale5(double fac)","link":"ParticleProperties.html#anchor105","text":"multiply the four-momentum components and the mass by fac."},{"name":"double AlpgenPar::getParam(const string AMPERSANDamp;paramIn)","link":"AlpgenEventInterface.html#anchor12","text":""},{"name":"virtual bool MyMergingHooks::setShowerStartingScales( bool      isTrial, bool doMergeFirstEmm,      doubleAMPERSAND pTscaleIn, const EventAMPERSAND event,      doubleAMPERSAND pTmaxFSRIn, boolAMPERSAND limitPTmaxFSRin,      doubleAMPERSAND pTmaxISRIn, boolAMPERSAND limitPTmaxISRin,      doubleAMPERSAND pTmaxMPIIn, boolAMPERSAND limitPTmaxMPIin )","link":"MatchingAndMerging.html#anchor14","text":"This function allows to set the starting scales for timelike and spacelike showering as well as multiparton interactions. It is thus necessary to properly start trial showers (that generate necessary no-emission probabilities), and for setting the correct starting conditions for parton showering of accepted (non-zero weight) events. The input event gives the hard process before showers and MPI are attempted. If isTrial=true , this means that the function is currently called from within a trial shower object (to produce no-emission probabilities). If doMergeFirstEmm=true , then the function is called to set starting conditions for the shower evolution of an (accepted) event. The double arguments pTscaleIn , pTmaxFSRIn , pTmaxISRIn and pTmaxMPIIn are tentative values for the starting scales of FSR, ISR and MPI. The function may overwrite these with the desired values. Similarly, limitPTmaxFSRin , limitPTmaxFSRin and limitPTmaxMPIin inform Pythia if the phase space for FSR/ISR/MPI is restricted (true) or unrestricted (false). Again, the tentative values can be overwritten."},{"name":"WeakShower:externalSetup","link":"WeakShowers.html#anchor6","text":"This flags tells the shower to use an external setup stored in the info pointer. This is mainly expected to be used in conjunction with the weak merging, and has to be switched on when the weak merging is used."},{"name":"R-hadrons","link":"RHadrons.html","text":"R-hadrons When a coloured SUSY particle is longer-lived than typical hadronization scales, i.e. around c*tau > 1 fm, or equivalently width Gamma < 0.2 GeV, it will have time to hadronize into a colour singlet hadronic state, a R-hadron. Currently a set of such R-hadrons have been implemented for the case of a long-lived gluino, stop or sbottom. Needless to say, the normal case would be that only one of them will be long-lived enough to form R-hadrons. For simplicity all gluino-mesons are assumed to have light-flavour spin 1, since those are the lightest and favoured by spin-state counting. Further, all gluino-baryons are bookkept as having light-flavour spin 3/2, and flavours are listed in descending order. This is more for convenience of notation, however, since the normal baryon octet e.g. has no uuu = 'p++' state. When a diquark is extracted, a mixture of spin 0 and spin 1 is allowed. Names and codes are essentially in agreement with the PDG conventions, e.g. 1000993 R0(~g g) (or gluinoball) 1009213 R+(~g u dbar) (or gluino-rho+) 1092214 R+(~g uud) (or gluino-Delta+) For internal bookkeeping of momenta, the code 1009002, Rtemp(~g q) , is used to denote the intermediate state formed when only one of the two string pieces attached to the gluino has broken. For the stop- and sbottom-hadrons the spin counting is simpler, since it is entirely given by the constituent quark or diquark spin. Again names and codes follow PDG conventions, e.g. 1000612 R+(~t dbar) 1006211 R+(~t ud0) The spin and electromagnetic charge of the new particle plays only a minor role in the hadronization process, that can be neglected to first approximation. Therefore it is possible to use the same R-hadrons framework instead for other BSM scenarios with long-lived coloured particles, e.g. with massive extra-dimensions copies of gluons and quarks, or with leptoquarks. This can be regulated by the switches below. Note that the codes and names of the R-hadrons is not changed when the heavy particle involved is switched, for reasons of administrative simplicity. R-hadron mass spectra and other relevant particle data is automatically updated to reflect the change, however."},{"name":"Merging:doNL3Loop","link":"NLOMerging.html#anchor10","text":"This switch will allow the processing of POWHEG NLO events in the NL 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Tree and the switch Merging:doNL3Subt have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested."},{"name":"HiddenValley:ffbar2BvBvbar","link":"HiddenValleyProcesses.html#anchor24","text":"Pair production f fbar &rarr; Bv Bvbar via intermediate gamma*/Z^*. Code 4925."},{"name":"void Hist::table(ostreamAMPERSANDamp; os = cout,  bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor11","text":""},{"name":"TimeShower:pTminChgL","link":"TimelikeShowers.html#anchor14","text":"Parton shower cut-off pT for pure QED branchings. Assumed smaller than (or equal to) pTminChgQ."},{"name":"double ParticleDataEntry::m0Max()","link":"ParticleDataScheme.html#anchor119","text":"similar to mMax() above, except that for particles with no width the m0(id) value is returned."},{"name":"Bottomonium:states(3PJ)","link":"OniaProcesses.html#anchor61","text":"The 3PJ bottomonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"double CoupSM::V2CKMid(int id1, int id2)","link":"StandardModelParameters.html#anchor43","text":"the CKM mixing element,or the square of it, for flavours id1 and id2 , both in the range from -18 to +18. The sign is here not checked (so it can be used both for u + dbar &rarr; W+ and u &rarr; d + W+ , say), but impossible flavour combinations evaluate to zero. The neutrino sector is numbered by flavor eigenstates, so there is no mixing in the lepton-neutrino system."},{"name":"void ParticleDataEntry::setChargeType(int chargeType)","link":"ParticleDataScheme.html#anchor105","text":""},{"name":"ExcitedFermion:qq2cStarq","link":"CompositenessProcesses.html#anchor13","text":"Scatterings q q(bar) &rarr; c^* q(bar). Code 4024."},{"name":"ParticleDecays:limitCylinder","link":"ParticleDecays.html#anchor7","text":"When on, only particles with a decay within a volume limited by rho = sqrt(x^2 + y^2) < xyMax and |z| < zMax are decayed. There is assumed to be no magnetic field or other detector effects."},{"name":"JetMatching:setMad","link":"JetMatching.html#anchor1","text":"When enabled, the merging parameters are set according to the values in the LHEF header. Specifically, the header must set the ickkw , xqcut , maxjetflavor and alpsfact values, and ickkw must be nonzero. Note that these labels are Madgraph-specific. For other programs with LHEF output, or for Madgraph files lacking this information, these parameters should be set by the user (or one can rely on the default values). The following parameters (described below) must then be specified: JetMatching:doMerge = ickkw , JetMatching:qCut = xqcut , JetMatching:nQmatch = maxjetflavor , JetMatching:clFact = alpsfact. With this flag on, the values from the LHEF for these parameters take precedence over other values."},{"name":"void LHAup::setPtr(Info* infoPtr)","link":"LesHouchesAccord.html#anchor3","text":"this method only sets the pointer that allows some information to be accessed, and is automatically called by Pythia::init()."},{"name":"int Info::code()","link":"EventInformation.html#anchor14","text":"the name and code of the process that occurred."},{"name":"mapAMPERSANDlt;string, ModeAMPERSANDgt; Settings::getModeMap(string match)","link":"SettingsScheme.html#anchor50","text":""},{"name":"double LHAup::alphaQCD()","link":"LesHouchesAccord.html#anchor37","text":"scale and couplings at that scale."},{"name":"Check:nErrList","link":"ErrorChecks.html#anchor6","text":"The number of erroneous events, in the above check, for which event listing and other detailed information will be printed. After that, only the normal error messages will be issued. Error counters are always updated, and accumulated numbers can be shown with pythia.stat() at the end of the run."},{"name":"SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true)","link":"UserHooks.html#anchor32","text":"The optional arguments of the constructor provides further variability. corresponds to the additional factor k in the above formula. It is by default equal to 1 but can be used to explore deviations from the expected value. if this number n is bigger than the default 0, the corresponding number of alpha_strong factors is also reweighted from the normal renormalization scale to a modified one, i.e. a further suppression factor ( alpha_s((k*pT0)^2 + Q^2_ren) / alpha_s(Q^2_ren) )^n is introduced. regulates which kind of new alpha_strong value is evaluated for the numerator in the above expression. It is by default the same as set for multiparton interactions (i.e. same starting value at M_Z and same order of running), but if false instead the one for hard subprocesses. The denominator alpha_s(Q^2_ren) is always the value used for the 'original', unweighted cross section."},{"name":"SoftQCD:nonDiffractive","link":"QCDProcesses.html#anchor2","text":"The inelastic nondiffrative part of the total cross section, i.e. what would often be called the 'minimum-bias component'. The formalism is based on an eikonalized description of all the hard QCD processes, so includes them in combination with low- pT events. Code 101. Since the current description is handled by the multiparton-interactions machinery as part of the parton-level processing, no hard process at all is defined at the process-level part of the event generation. Fortunately, in this case a special codeSub() method provides information on the first, i.e. hardest, subprocess selected by the multiparton-interactions machinery. Note : this event class is almost equivalent to the minimum-bias component of the total cross section. 'Minimum-bias' usually refers to the experimental selection procedure, however, while '(inelastic) non-diffractive' better relates to the way events are generated in the program code. (Although also what separates diffractive from nondiffractive physics can be a matter of definition, especially once colour reconnection is to be modelled.)"},{"name":"int LHAup::pdfSetBeamB()","link":"LesHouchesAccord.html#anchor20","text":"for the beam properties."},{"name":"int DecayChannel::multiplicity()","link":"ParticleDataScheme.html#anchor178","text":"set or get the number of decay products in a channel, at most 8. (Is normally not to be set by hand, since it is automatically updated whenever the products list is changed.)"},{"name":"double CoupSM::Lambda4()","link":"StandardModelParameters.html#anchor22","text":""},{"name":"virtual bool SpaceShower::branch( EventAMPERSAND event)","link":"ImplementNewShowers.html#anchor36","text":"This method will be called once ISR has won the competition with MPI and FSR to do the next branching. The candidate branching found in the previous step should here be carried out in full. The pre-branching partons should get a negative status code and new replacement ones added to the end of the event record. Also the subsystem information should be updated, and possibly also the beams. Should some problem be encountered in this procedure, e.g. if some not-previously-considered kinematics requirement fails, it is allowed to return false to indicate that no branching could be carried out. Also a complete restart of the parton-level description may be necessary, see doRestart() below."},{"name":"Bottomonium:states(3DJ)","link":"OniaProcesses.html#anchor70","text":"The 3DJ bottomonium states that can be produced from the following processes. Currently, no 3DJ states are included in the default ParticleData and so none are included here. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"JetMatching:scheme","link":"JetMatching.html#anchor3","text":"The parton-jet MLM-style matching scheme. The one inspired by the Madgraph matching code, here implemented in the JetMatchingMadgraph class. The one inspired by the ALPGEN matching code, here implemented in the JetMatchingAlpgen class."},{"name":"ExtraDimensionsTEV:ffbar2ttbar","link":"ExtraDimensionalProcesses.html#anchor32","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; t tbar , Code 5066."},{"name":"HiggsBSM:ffbar2H+-","link":"HiggsProcesses.html#anchor55","text":"Scattering f fbar' &rarr; H^+- , where f, fbar' sums over available incoming flavours. Since couplings are assumed generation-diagonal, in practice this means c sbar &rarr; H^+ and s cbar &rarr; H^-. Code 1061."},{"name":"int SigmaProcess::resonanceA()","link":"SemiInternalProcesses.html#anchor20","text":""},{"name":"HiddenValley:ffbar2UvUvbar","link":"HiddenValleyProcesses.html#anchor21","text":"Pair production f fbar &rarr; Uv Uvbar via intermediate gamma*/Z^*. Code 4922."},{"name":"SpaceShower:QEDshowerByL","link":"SpacelikeShowers.html#anchor26","text":"Allow leptons to radiate photons; on/off = true/false."},{"name":"FourthTop:gg2tPrimetPrimebar","link":"FourthGenerationProcesses.html#anchor9","text":"Scatterings g g &rarr; t' t'bar. Code 821."},{"name":"virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0)","link":"ImplementNewShowers.html#anchor4","text":"You have to store your local copy of the pointers to these objects, since they have to be used during the generation, as explained above. The pointers could be zero; e.g. a local copy of TimeShower is created to handle showers in decays such as Upsilon &rarr; q qbar from inside the ParticleDecays class. This is also the place to do initialization of whatever parameters you plan to use, e.g. by reading in them from a user-accessible database like the Settings one."},{"name":"ContactInteractions:QCffbar2mumubar","link":"CompositenessProcesses.html#anchor35","text":"Scatterings f fbar &rarr; mu- mu+ including contact interactions. Code 4204."},{"name":"Bottomonium:gg2bbbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor67","text":"Colour-octet production of 3PJ bottomonium states via g g &rarr; bbbar[3S1(8)] g. Code 514."},{"name":"POWHEG Merging","link":"POWHEGMerging.html","text":"POWHEG Merging POWHEG Nas04 in its character is very much like a parton shower, with a Sudakov factor arising from the ordering of emissions. Both POWHEG-BOX Ali10 and PYTHIA are based on a combined evolution of ISR and FSR in pT -related 'hardness' variables, and thus are kindred spirits. The hardness definitions differ, however. Frequently we will therefore need to distinguish between POWHEG-hardness and PYTHIA-hardness in the following. The simplest merging solution, of continuing the PYTHIA shower at the LHA scale hardness where POWHEG leaves off, is obtained if you set SpaceShower:pTmaxMatch = 1 and TimeShower:pTmaxMatch = 1. But then mismatches are bound to happen: some regions may be doublecounted, while others may not be counted at all. Depending on the choice of hardness, such mismatches might be small. There are no guarantees, however, so a (hopefully) more accurate merging scheme is coded up in the include/Pythia8Plugins/PowHegHooks.h file, with a realistic user example in the examples/main31 files. Here we would like to discuss the (POWHEG-specific) input settings for main31.cc , see main31.cmnd , and attempt to give some recommendations on how to use the main program to perform a matching of POWHEG-BOX with PYTHIA 8. POWHEG-BOX inputs contain Born-like events (with no resolved emission) and Real-type events (containing an additional parton). The mismatch between POWHEG-hardness and PYTHIA-hardness can be minimised if the PYTHIA shower knows a) The POWHEG-hardness criterion (through which the separation of Born- and Real-like events is defined), and b) The POWHEG-hardness value (which separates Born- and Real-like events). If these definitions are known, then PYTHIA can fill missing phase space regions through vetoed showering: let the shower sweep over the full phase space, using its PYTHIA-hardness ordering, and use the POWHEG-hardness to veto those emissions that POWHEG should already have covered. This is only possible since the POWHEG-hardness criterion and the shower ordering criterion are very similar. In the more general case a truncated showering would be needed Nas04. For vetoed showering, it is necessary to define the POWHEG-hardness criterion. In the presence of multiple partons, the definition quickly becomes complicated, and allows for different choices. Similar decisions have already been made in the implementation of POWHEG, one example being the choice in defining which 'hardness value' is transferred as POWHEG-hardness, e.g. by deciding if the 'singular regions' of the FKS or the CS approach are used. If the POWHEG-hardness definition were to be changed, or extended to more objects, the PowhegHooks.h code would need to be modified accordingly. The merging code is designed to be very flexible, and allows access to many possible choices. However, this flexibility means that many parameters can be changed, potentially leading to confusion. Thus, recommendations might prove helpful. All mistakes and inaccuracies rest with the author. We recommend the usage of vetoed showers. This means using &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:veto = 1 This means that PYTHIA will sweep over the full phase space, and apply a veto on parton shower emissions for which the POWHEG-hardness separation between radiator and emission is above the POWHEG-hardness value of the current input event. The variation POWHEG:veto = 0 can be used to assess how much phase space is under- or double-counted. To define the POWHEG-hardness criterion, use &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:pTdef = 1 Other values can be used by experts to assess variations. Both POWHEG-BOX and PYTHIA 8 generate emissions through a parton shower step, meaning that both programs have a clear definition of a radiator that emits particles, which is very similar (if not identical). To fix the ambiguity if the radiator or the emitted particle should be called 'the emission', use &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:emitted = 0 More complicated choices can be used by experts. For instance, use POWHEG:emitted = 2 to check the POWHEG-hardness of both radiator and emitted. To exhaustively fix the criterion by which to veto parton shower emissions, it is important to decide which partons/parton pairs are used to calculate the POWHEG hardness of a PYTHIA 8 emission. The minimal and recommended choice is &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:pTemt = 0 This means that only the POWHEG hardness with respect to the radiating leg is checked, and recoil effects are neglected. This prescription should be very similar to how a hardness value is assigned to a Real-type event in the POWHEG-BOX, since in the (implementation of FKS in the) POWHEG-BOX, initial state splittings only have singular regions with the radiating initial state parton, and final state splittings only have singular regions with respect to the radiating final state line. Other choices of POWHEG:pTemt are available. A warning is that the impact of changes can be huge, particularly for inputs with many jets. Other choices therefore should only be made by experts, and a high degree of caution is advised. It is furthermore necessary to decide on a value of the hardness criterion. POWHEG-BOX transfers this value in the SCALUP member of Les Houches Events, and we recommend using this value by setting &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:pThard = 0 As a variation, in order to estimate the uncertainty due this choice of POWHEG-hardness definition, it can be useful to also check POWHEG:pThard = 2. This will recalculate the POWHEG-hardness value as promoted in Ole12. You need to decide how many emissions the vetoed shower should check after an allowed emission has been constructed. If the hardness definitions in POWHEG-BOX and PYTHIA 8 where identical, all checking could be stopped after the first allowed PS emission. To be prudent, we recommend setting &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG:vetoCount = 3 which will then check up to three allowed emissions. Higher values of POWHEG:vetoCount have not lead to visible differences for the processes which have been tested. Finally, for many POWHEG processes, the Sudakov effects from electroweak emissions (here we are concerned mainly with photon emissions, but this could apply also to W/Z emissions) are not included. This effect can be investigated using POWHEG:QEDveto = 0,1, or 2. For the default  value of POWHEG:pTemt = 0 , only POWHEG:QEDveto = 2 has any effect. For this choice, a hard photon and subsequent QCD radiation is retained. In many cases, particularly when the Born contributions are small, the choice has little effect. The modes Note that the modes have generally been defined with several default values below corresponding to the 'off' state, and thus do not agree with the recommended values described above."},{"name":"PhaseSpace:useBreitWigners","link":"PhaseSpaceCuts.html#anchor6","text":"Allows masses to be selected according to Breit-Wigner shapes in 2 &rarr; 2 processes, whenever particles have been declared with a nonvanishing width above the threshold below. In those cases also the limits below will be used for the mass selection. For 2 &rarr; 1 processes the Breit-Wigner shape is part of the cross section itself, and therefore always included."},{"name":"virtual void BeamShape::pick()","link":"BeamShape.html#anchor4","text":"this method is the key one to supply in the derived class. Here you are free to pick whatever parametrization you desire for beam momenta and vertex position, including correlations between the two. At the end of the day, you should set a few protected double numbers: deltaPxA, deltaPyA, deltaPzA for the three-momentum shift of the first incoming beam, relative to the nominal values; deltaPxB, deltaPyB, deltaPzB for the three-momentum shift of the second incoming beam, relative to the nominal values; vertexX, vertexY, vertexZ, vertexT for the production-vertex position and time. As usual, momentum is given in GeV, and space and time in mm, with c = 1."},{"name":"MultipartonInteractions:ySepRescatter","link":"MultipartonInteractions.html#anchor21","text":"used for some of the MultipartonInteractions:rescatterMode options above, as the rapidity for which a scattered parton has a 50% probability to be considered as a potential rescatterer. A ySep > 0 generally implies that some central partons cannot rescatter at all, while a ySep < 0 instead allows central partons to scatter against either beam."},{"name":"HiggsBSM:gg2H1bbbar","link":"HiggsProcesses.html#anchor64","text":"Scattering g g &rarr; h^0 b bbar. This process is yet one order higher of the b bbar &rarr; h^0 and b g &rarr; h^0 b chain, where now two quarks should be required above some large pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1012."},{"name":"void LHAup::setInfoHeader(const string AMPERSANDkey,  const string AMPERSANDval)","link":"LesHouchesAccord.html#anchor80","text":"is used to send header information on to the Info class."},{"name":"Zprime:vb","link":"NewGaugeBosonProcesses.html#anchor20","text":"vector coupling of b quarks."},{"name":"Zprime:vc","link":"NewGaugeBosonProcesses.html#anchor14","text":"vector coupling of c quarks."},{"name":"HiggsBSM:gg2H2bbbar","link":"HiggsProcesses.html#anchor70","text":"Scattering g g &rarr; H^0 b bbar. This process is yet one order higher of the b bbar &rarr; H^0 and b g &rarr; H^0 b chain, where now two quarks should be required above some large pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1032."},{"name":"Zprime:ve","link":"NewGaugeBosonProcesses.html#anchor8","text":"vector coupling of e leptons."},{"name":"Main:numberOfEvents","link":"MainProgramSettings.html#anchor20","text":"The number of events to be generated."},{"name":"virtual bool TimeShower::allowedSplitting( const EventAMPERSAND event,  int iRad, int iEmt)","link":"ImplementNewShowers.html#anchor25","text":"This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the timelike shower if a particular combination of radiator and emission could have resulted from a splitting. The function arguments are the event which contains the radiator and emission, and the position of the radiator ( iRad ) and emission ( iEmt ) in said event. The function should return true if the combination was possible, and false otherwise."},{"name":"ExtraDimensionsUnpart:ratio","link":"ExtraDimensionalProcesses.html#anchor84","text":"Ratio, lambda'/lambda , between the two possible coupling constants of the spin-2 ME. Warning: A ratio value different from one give rise to an IR divergence which makes the event generation very slow, so this values is fixed to ratio = 1 for the moment."},{"name":"BeamRemnants:rescatterRestoreY","link":"BeamRemnants.html#anchor8","text":"Is only relevant when rescattering is switched on in the multiparton interactions scenario. For a normal interaction the rapidity and mass of a system is preserved when primordial kT is introduced, by appropriate modification of the incoming parton momenta. Kinematics construction is more complicated for a rescattering, and two options are offered. Differences between these can be used to explore systematic uncertainties in the rescattering framework. The default behaviour is to keep the incoming rescattered parton as is, but to modify the unrescattered incoming parton so as to preserve the invariant mass of the system. Thereby the rapidity of the rescattering is modified. The alternative is to retain the rapidity (and mass) of the rescattered system when primordial kT is introduced. This is made at the expense of a modified longitudinal momentum of the incoming rescattered parton, so that it does not agree with the momentum it ought to have had by the kinematics of the previous interaction. For a double rescattering, when both incoming partons have already scattered, there is no obvious way to retain the invariant mass of the system in the first approach, so the second is always used."},{"name":"int MergingHooks::nHardInPartons()","link":"CKKWLMerging.html#anchor21","text":"Returns the number of incoming partons in the hard core process."},{"name":"Zprime:vs","link":"NewGaugeBosonProcesses.html#anchor12","text":"vector coupling of s quarks."},{"name":"Zprime:vt","link":"NewGaugeBosonProcesses.html#anchor22","text":"vector coupling of t quarks."},{"name":"Zprime:vu","link":"NewGaugeBosonProcesses.html#anchor6","text":"vector coupling of u quarks."},{"name":"virtual double UserHooks::scaleResonance( int iRes,  const EventAMPERSAND event)","link":"UserHooks.html#anchor39","text":"can optionally be called, as described above. You should return the maximum scale, in GeV, from which the shower evolution will begin. The base class method returns 0, i.e. gives no shower evolution at all. You can study, but not modify, the event event record of the partonic process to check which resonance is decaying, and into what. is the location in the event record of the resonance that decayed to the particles that now will shower. the event record contains a list of all partons generated so far, specifically the decaying resonance and its immediate decay products."},{"name":"Merging:useShowerPlugin","link":"CKKWLMerging.html#anchor54","text":"Use the splitting probabilities, evolution variables and phase space mappings of an external shower plugin. This will become possible as soon as new showers containing the necessary ingredients are available in Pythia."},{"name":"MultipartonInteractions:processLevel","link":"MultipartonInteractions.html#anchor6","text":"Set of processes included in the machinery. only the simplest 2 &rarr; 2 QCD processes between quarks and gluons, giving no new flavours, i.e. dominated by t -channel gluon exchange. also 2 &rarr; 2 QCD processes giving new flavours (including charm and bottom), i.e. proceeding through s -channel gluon exchange. also 2 &rarr; 2 processes involving one or two photons in the final state, s -channel gamma boson exchange and t -channel gamma/Z^0/W^+- boson exchange. also charmonium and bottomonium production, via colour singlet and colour octet channels."},{"name":"Zprime:at","link":"NewGaugeBosonProcesses.html#anchor23","text":"axial coupling of t quarks."},{"name":"HiggsSM:qg2Hq(l:t)","link":"HiggsProcesses.html#anchor20","text":"Scattering q g &rarr; H^0 q via loop contributions primarily from top. Not to be confused with the HiggsSM:qg2Hq process above, with its direct fermion-to-Higgs coupling. Code 915."},{"name":"TimeShower:pTminChgQ","link":"TimelikeShowers.html#anchor13","text":"Parton shower cut-off pT for photon coupling to coloured particle."},{"name":"double ParticleData::m0Max(int id)","link":"ParticleDataScheme.html#anchor48","text":"similar to mMax() above, except that for particles with no width the m0(id) value is returned."},{"name":"ExtraDimensionsUnpart:ffbar2llbar","link":"ExtraDimensionalProcesses.html#anchor78","text":"Scatterings f fbar &rarr; (U*) &rarr; l lbar , where l is a charged lepton. If the unparticle contribution is zero, the results corresponds to the SM contribution, i.e. similar to WeakSingleBoson:ffbar2gmZ. Does not include t-channel amplitude relevant for e^+e^- to e^+e^- and no K-factor is used. Code 5048."},{"name":"ContactInteractions:QCqq2qq","link":"CompositenessProcesses.html#anchor32","text":"Scatterings q q &rarr; q q including contact interactions. Code 4201."},{"name":"Init:showOneParticleData","link":"MainProgramSettings.html#anchor8","text":"Print particle and decay data for the particle with this particular identity code. Default means that no particle is printed."},{"name":"string Settings::wordDefault(string key)","link":"SettingsScheme.html#anchor44","text":""},{"name":"Merging:nJetMaxNLO","link":"NLOMerging.html#anchor1","text":"The maximal number of additional jets for which NLO event samples are supplied by the user."},{"name":"void LHAupMadgraph::setJets(int jets)","link":"MadGraph5Processes.html#anchor5","text":"Set the number maximum number of jets generated by MadGraph. If negative (default of -1) then the number of jets is determined automatically, to be the maximum number of jets produced at leading order."},{"name":"Diffraction:sampleType","link":"Diffraction.html#anchor33","text":"Type of process the user wants to generate. Depends strongly on how an event is classified as diffractive. Generate an inclusive sample of both diffractive and nondiffractive hard processes, MPI-unchecked. Generate an inclusive sample of both diffractive and nondiffractive hard processes, MPI-checked. Generate an exclusive diffractive sample, MPI-unchecked. Generate an exclusive diffractive sample, MPI-checked."},{"name":"Top Processes","link":"TopProcesses.html","text":"Top Processes Different ways to produce top quarks, singly or in pairs. By default top always decays to a W and a down-type quark. It is possible to switch on the t &rarr; H+ b decay mode. Note that its partial width is calculated using the tan(beta) value stored in HiggsHchg:tanBeta , so that it can be used without having to read in a SUSY parameter file. For the H+ to decay also Higgs:useBSM = on is necessary."},{"name":"HiggsH2:coup2Hchg","link":"HiggsProcesses.html#anchor92","text":"The H^0(H_2^0) coupling to H^+- (in loops). Is cos(beta - alpha) + cos(2 beta) cos(beta + alpha) / (2 cos^2theta_W) in the MSSM."},{"name":"PhaseSpace:pTHat3Max","link":"PhaseSpaceCuts.html#anchor10","text":"The maximum invariant pT of the highest- pT parton in QCD 2 &rarr; 3 processes A value below pTHat3Min means there is no upper limit."},{"name":"SpaceShower:weakShower","link":"SpacelikeShowers.html#anchor21","text":"Allow a weak shower, yes or no."},{"name":"Merging:pickByPoPT2","link":"CKKWLMerging.html#anchor38","text":"If on, pick parton shower histories of the matrix element by the shower  splitting kernels divided by the evolution pT."},{"name":"Fragmentation","link":"Fragmentation.html","text":"Fragmentation Fragmentation in PYTHIA is based on the Lund string model And83, Sjo84. Several different aspects are involved in the physics description, which  here therefore is split accordingly. This also, at least partly, reflect the set of classes involved in the fragmentation machinery. The variables collected here have a very wide span of usefulness. Some would be central in any hadronization tuning exercise, others should not be touched except by experts. The fragmentation flavour-choice machinery is also used in a few other places of the program, notably particle decays, and is thus described on the separate Flavour Selection page. Fragmentation functions The StringZ class handles the choice of longitudinal lightcone fraction z according to one of two possible shape sets. The Lund symmetric fragmentation function And83 is the only alternative for light quarks. It is of the form f(z) = (1/z) * (1-z)^a * exp(-b m_T^2 / z) with the two main free parameters a and b to be tuned to data. They are stored in In principle, each flavour can have a different a. Then, for going from an old flavour i to a new j one the shape is f(z) = (1/z) * z^{a_i} * ((1-z)/z)^{a_j} * exp(-b * m_T^2 / z) This is only implemented for s quarks and diquarks relative to normal quarks: Finally, the Bowler modification Bow81 introduces an extra factor 1/z^{r_Q * b * m_Q^2} for heavy quarks. To keep some flexibility, a multiplicative factor r_Q is introduced, which ought to be unity (provided that quark masses were uniquely defined) but can be set in Within the string framework, the b parameter is universal, i.e. common for all flavours. Nevertheless, for fits to experimental data, better agreement can be obtained if both a_Q and b_Q can be set freely in a general expression f(z) = 1/z^{1 + r_Q * b_Q * m_Q^2} * (1-z)^a_Q * exp(-b_Q m_T^2 / z) The below switches and values can be used to achieve this. They should be used with caution and constitute clear deviations from the Lund philosophy. As another nonstandard alternative, it is possible to switch over to the Peterson/SLAC formula Pet83 f(z) = 1 / ( z * (1 - 1/z - epsilon/(1-z))^2 ) for charm, bottom and heavier (defined as above) by the three flags When switched on, the corresponding epsilon values are chosen to be Fragmentation pT The StringPT class handles the choice of fragmentation pT. At each string breaking the quark and antiquark of the pair are supposed to receive opposite and compensating pT kicks. How they are distributed depends on the following flag: Gaussian Distribution For StringPT:thermalModel = off the quarks receive pT kicks according to a Gaussian distribution in p_x and p_y separately. Call sigma_q the width of the p_x and p_y distributions separately, i.e. d(Prob) = exp( -(p_x^2 + p_y^2) / 2 sigma_q^2). Then the total squared width is <pT^2> = <p_x^2> +  <p_y^2> = 2 sigma_q^2 = sigma^2. It is this latter number that is stored in Since a normal hadron receives pT contributions for two string breakings, it has a <p_x^2>_had = <p_y^2>_had = sigma^2 , and thus <pT^2>_had = 2 sigma^2. Some studies on isolated particles at LEP has indicated the need for a slightly enhanced rate in the high- pT tail of the above distribution. This would have to be reviewed in the context of a complete retune of parton showers and hadronization, but for the moment we stay with the current recipe, to boost the above pT by a factor enhancedWidth for a small fraction enhancedFraction of the breakups, where In the context of some toy studies Fis16 the following three options have also been introduced, but are not part of any recommended framework. Thermal Distribution For StringPT:thermalModel = on the quark pT is generated such that the resulting hadron pT follows a thermal distribution d(Prob) = exp( -pT_had/T) d^2pT_had with temperature T , whose value is given by Common setup for enhanced width If strings are closely packed, e.g. as a consequence of MPIs, it is likely that they receive an increased string tension, which translates into a broader pT spectrum, see further Fis16. It also means an enhanced rate (or rather reduced suppression) of heavy-particle production relative to pions. This can be regulated by the flag and parameters below. Jet joining procedure String fragmentation is carried out iteratively from both string ends inwards, which means that the two chains of hadrons have to be joined up somewhere in the middle of the event. This joining is described by parameters that in principle follows from the standard fragmentation parameters, but in a way too complicated to parametrize. The dependence is rather mild, however, so for a sensible range of variation the parameters in this section should not be touched. This W_min_smeared is then compared with the current remaining W_transverse to determine if there is energy left for further particle production. If not, i.e. if W_transverse < W_min_smeared , the final two particles are produced from what is currently left, if possible. (If not, the fragmentation process is started over.) Simplifying systems There are a few situations when it is meaningful to simplify the original task, one way or another. Ministrings The MiniStringFragmentation machinery is only used when a string system has so small invariant mass that normal string fragmentation is difficult/impossible. Instead one or two particles are produced, in the former case shuffling energy-momentum relative to another colour singlet system in the event, while preserving the invariant mass of that system. With one exception parameters are the same as defined for normal string fragmentation, to the extent that they are at all applicable in this case.  A discussion of the relevant physics is found in Nor00. The current implementation does not completely abide to the scheme presented there, however, but has in part been simplified. (In part for greater clarity, in part since the class is not quite finished yet.) Junction treatment A junction topology corresponds to an Y arrangement of strings i.e. where three string pieces have to be joined up in a junction. Such topologies can arise if several valence quarks are kicked out from a proton beam, or in baryon-number-violating SUSY decays. Special attention is necessary to handle the region just around the junction, where the baryon number topologically is located. The junction fragmentation scheme is described in Sjo03. The parameters in this section should not be touched except by experts."},{"name":"Bottomonium:qqbar2bbbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor76","text":"Colour-octet production of 3DJ bottomonium states via q qbar &rarr; bbbar[3PJ(8)] g. Code 520."},{"name":"StringFlav:lightLeadingBSup","link":"FlavourSelection.html#anchor39","text":"extra suppression of leading-baryon production for a light-quark jet, i.e. d , u or s , when suppressLeadingB = on. Thus 0 means no leading-baryon production at all, while 1 means full rate."},{"name":"double Info::enhanceMPIavg()","link":"EventInformation.html#anchor88","text":"The average enhancement factor expected for hard processes in those cases where it can be calculated already at initialization, i.e. excluding the x -dependent b profile."},{"name":"virtual bool SpaceShower::limitPTmax( EventAMPERSAND event,  double Q2Fac = 0.,  double Q2Ren = 0.)","link":"ImplementNewShowers.html#anchor31","text":"The question is whether the ISR should be allowed to occur at larger scales than the hard process it surrounds. This is process-dependent. For instance, if the hard process is Z^0 production we know that ISR should be allowed to go right up to the kinematical limit. If it is a 2 &rarr; 2 QCD process the ISR should not exceed the scale of the hard process, since if so one would double-count. The SpaceShower:pTmaxMatch switch allows you to force the behaviour, or else to program your own logic. The current default implementation limits pT whenever the final state contains a quark (except top), gluon or photon, since then the danger of double-counting is there. You may replace by your own logic, or leave as is. The internal PYTHIA implementation also allows intermediate options, where emissions can go up to the kinematical limit but be dampened above the factorization or renormalization scale. Therefore the (square of the) latter two are provided as optional input parameters."},{"name":"bool LHAupMadgraph::readString(string line,  Stage stage = Auto)","link":"MadGraph5Processes.html#anchor2","text":"allows the user to send commands to MadGraph. the command to be sent to MadGraph. Any string begining with 'configure ' is used for the initial MadGraph configuration with 'configure ' stripped from the begining. In general, only the process and run settings need to be provided. Run settings must begin with ' set' ; note the leading space. The output and launch commands, random seed, and shower choice are automatically handled. For example, the following will produce di-muon events from 13 TeV proton proton collisions at NLO in QCD: readString('generate p p > mu+ mu- [QCD]'); if the stage is set to Auto, commands beginning with ' set' are used in the launch stage, commands begining with 'configure' are used in the configuration stage, and all remaining commands (excluding output and launch ) are used in the generate stage. Output, launch, seed, and shower commands are automatically handled. If the user wishes to override commands, then the stage can be specified. This will prevent any automatically generated commands from being used for that stage. This should only be done if the user understands what additional commands are needed."},{"name":"NewGaugeBoson:ffbar2gmZZprime","link":"NewGaugeBosonProcesses.html#anchor1","text":"Scattering f fbar &rarr;Z'^0. Code 3001."},{"name":"Zprime:ae","link":"NewGaugeBosonProcesses.html#anchor9","text":"axial coupling of e leptons."},{"name":"Merging:QijMS","link":"CKKWLMerging.html#anchor10","text":"The value of the invariant mass cut Q ij of pairs of final state partons used in the matrix element generation."},{"name":"Settings::Settings()","link":"SettingsScheme.html#anchor1","text":"the constructor, which takes no arguments. Internal."},{"name":"HiggsA3:coup2H1Z","link":"HiggsProcesses.html#anchor101","text":"The A^0(H_3^0) coupling to a h^0(H_1^0) Z^0 pair. Is cos(beta - alpha) in the MSSM."},{"name":"Diffraction:expPow","link":"Diffraction.html#anchor31","text":"When bProfile = 3 it gives the power of the assumed overlap shape exp(- b^expPow). Default corresponds to a simple exponential drop, which is not too dissimilar from the overlap obtained with the standard double Gaussian parameters. For expPow = 2 we reduce to the simple Gaussian, bProfile = 1 , and for expPow &rarr; infinity to no impact parameter dependence at all, bProfile = 0. For small expPow the program becomes slow and unstable, so the min limit must be respected."},{"name":"Merging:kFactor1j","link":"NLOMerging.html#anchor7","text":"The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of one-jet tree-level events."},{"name":"ParticleDataEntry::ParticleDataEntry(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor91","text":"there are two alternative constructors, that both expect the properties of a particle as input. The first assumes that there is only one particle, the latter that there is a particle-antiparticle pair (but if the antiparticle name is void one reverts back to the particle-only case)."},{"name":"LeftRightSymmmetry:coupHmue","link":"LeftRightSymmetryProcesses.html#anchor20","text":"Yukawa coupling for H^-- &rarr; mu- e-."},{"name":"HardQCD:gg2qqbar","link":"QCDProcesses.html#anchor10","text":"Scatterings g g &rarr; q qbar , where q by default is a light quark ( u, d, s ) (see below). Code 112."},{"name":"bool DecayChannel::contains(int id1, int id2, int id3)","link":"ParticleDataScheme.html#anchor185","text":"find if the decay product list contains the one, two or three particle identities provided. If the same code is repeated then so must it be in the products list. Matching also requires correct sign."},{"name":"bool ParticleData::hasAnti(int id)","link":"ParticleDataScheme.html#anchor27","text":"bool whether a distinct antiparticle exists or not. Is true if an antiparticle name has been set (and is different from void )."},{"name":"int Particle::idAbs()","link":"ParticleProperties.html#anchor31","text":"the absolute value of the particle identity code."},{"name":"HardQCD:qqbar2qqbargDiff","link":"QCDProcesses.html#anchor28","text":"Scatterings q qbar &rarr; q' qbar' g , where q' by default is a light quark ( u, d, s ) (see HardQCD:nQuarkNew above). Code 136."},{"name":"MultipartonInteractions:Kfactor","link":"MultipartonInteractions.html#anchor5","text":"Multiply all cross sections by this fix factor."},{"name":"Event Statistics","link":"EventStatistics.html","text":"Event Statistics At the end of the run you will want to write out the final statistics on number of events generated, the corresponding cross sections and the number of errors encountered. This is done with the pythia.stat() method, assuming pythia is an instance of the Pythia class.The method is steered entirely by settings values, see here. Cross-section statistics The ProcessLevel::statistics() method cannot be accessed directly, but only via the Pythia::stat() call above. When called it will loop over the list of existing processes, and for each write out name, code, the number of tried, selected and accepted events, the cross section and the estimated error on the latter. The three different event numbers are related to the Monte Carlo method used, whereby an initial upper estimate of the cross section is used to select a large number of trial phase-space points, whereof then not all survive. Rejections are normally done by the internal machinery, but can also be obtained by user hooks. Therefore: tried events reflect the original number of phase-space points probed, as part of the upper estimate; selected events correspond to those that survive the internal Monte-Carlo selection procedure; accepted events are those that also survive the additional user cuts. In most runs there would be no user hooks implemented, and then the numbers of selected and of accepted events will agree. Aborted events (see below) usually appear in the selected statistics but not in the accepted one. For Les Houches events the total cross section will be correctly displayed; however the (optional) error value will not be used, so that the reported error will be smaller than the correct statistical ones, and often vanish completely. Furthermore, while the number of events is shown for each user process, the cross section is only for the sum of them. Error messages When Pythia is run, errors may occur, and give rise to warning messages. These may be of varying severity, as follows: Abort means things went seriously wrong, and the initialization or event generation failed. In the former case it is not possible to generate events at all, in the latter the current event is flawed and should be skipped. In either case the respective method, Pythia::init() or Pythia::next() , then also returns the value false. There are occasions where an abort may be deliberate, such as when a file of Les Houches Events is read and the end of the file is reached. Error normally is less severe. Typically the program will back up one step and try again. There are cases where this is not possible, in particular during the initialization and the generation of a hard process, and then the error may be followed by an abort as a direct consequence (with two separate messages). Warning is even less severe. In some cases the program will try again, with  good chances of success, in others no measure at all need to be taken. The error messages is handled by a small part of the Info class. It is handed any abort, error or warning messages during the event generation phase, and will store each distinct message, with a counter for how many times it is issued. Thus it is possible to limit the number of identical messages issued, currently hardcoded so that each kind of error message is only printed once ( static const int TIMESTOPRINT = 1 ). This can be overridden by the calling routine, so that all messages of this kind are shown, which is particularly relevant for the initialization  stage. The summary table printed by Pythia::stat() provides a table with all the different messages issued, in alphabetical order, with the total number of times each was generated. Multiparton-interactions statistics If you call Pythia::stat() with Stat:showPartonLevel = true also statistics on multiparton interactions is printed, comprising a list of all allowed subprocesses with how many times each of them has been generated. For the nondiffractive process this also includes the hardest interaction, while else the hardest process is excluded from the statistics. (This is because the hardest process is of the same character and generated by the same machinery in the former case but not in the latter. Also, for the former case only, the standard statistics listing only lists nondiffractive as one single process, i.e. does not further specify the character of the hardest subprocess, so there is not any overlap between the two.)"},{"name":"HiddenValley:ffbar2DvDvbar","link":"HiddenValleyProcesses.html#anchor20","text":"Pair production f fbar &rarr; Dv Dvbar via intermediate gamma*/Z^*. Code 4921."},{"name":"void Settings::resetWord(string key)","link":"SettingsScheme.html#anchor72","text":""},{"name":"double Info::x2pdf()","link":"EventInformation.html#anchor41","text":"x fractions of the two partons for which parton density values are defined."},{"name":"Main-Program and Related Settings","link":"MainProgramSettings.html","text":"Main-Program and Related Settings Introduction The main program is up to the user to write. However, sample main programs are provided. In one such class of programs, key settings of the run are read in from a 'cards file'. For experimental collaborations this is actually the most common way to run a program like PYTHIA. The commands in such a file may be of two types (a) instructions directly to Pythia , like which processes to generate, and (b) instructions to the main program for what it should do, like how many events to generate, and how many events should be listed. In principle these two kinds could be kept completely separate. However, to make life simpler, a few useful main-program settings are defined on this page, so that they are recognized by the Settings machinery. They can thus be put among the other cards without distinction. It is up to you to decide which ones, if any, you actually want to use when you write your main program. To further reduce the necessary amount of main-program code, some of the tasks that you can steer from your main program can also be done internally. This in particular relates to some information printing. To give an example, pythia.event.list() can be inserted to print an event, i.e. all the particles belonging to it. Given the length of these listings one would list only a few events at the beginning of the run, to get some feeling for the character of events. This could be achieved e.g. with a main-program statement if (iEvent < 3) pythia.event.list() to list the first three events in a loop over iEvent , after pythia.next() has been used to generate the next event. Alternatively a Next:numberListEvent = 3 setting, e.g. in a command file, would achieve the same, by an internal call at the end of pythia.next(). The settings names on this page thus fall into four main groups Init:... denote actions that automatically may be taken during the pythia.init() call. Next:... denote actions that automatically may be taken during the pythia.next() call. Stat:... denote actions that automatically may be taken during the pythia.stat() call. Main:... denote actions that you yourself have the freedom to make use of in your main program. Initialization settings Event-generation settings Statistics Main-program settings The settings in this section must be under the control of the user, i.e. there are no internal equivalents. The first one is especially important and would be a standard feature of any separate command file. The Main:... options works like this. Once you have used the pythia.readFile(fileName) method to read in the cards file, where the values have been set, you can interrogate the Settings database to make the values available in your main program. A slight complication is that you need to use a different Settings method for each of the four possible return types that you want to extract. To save some typing the same method names are found directly in the Pythia class, and these just send on to the Settings ones to do the job, e.g. int nEvent = pythia.mode('Main:numberOfEvents'); The area of subruns is covered separately below. A few spares are also defined after that, for unforeseen applications. Subruns You can use subruns to carry out several tasks in the same run. In that case you will need repeated instances of the first setting below in your command file, and could additionally use the second and third as well. Spares For currently unforeseen purposes, a few dummy settings are made available here. The user can set the desired value in a 'cards file' and then use that value in the main program as desired."},{"name":"void LHAup::addParticle( int id, int status, int mother1,  int mother2, int colourTag1, int colourTag2, double p_x, double p_y,  double p_z, double e, double m, double tau, double spin, double scale)","link":"LesHouchesAccord.html#anchor32","text":"gives the properties of the next particle handed in (cf. IDUP, ISTUP, MOTHUP(1,..), MOTHUP(2,..), ICOLUP(1,..), ICOLUP(2,..),  PUP(J,..), VTIMUP, SPINUP ; while scale is a new optional property, see further below)."},{"name":"SigmaProcess:muMassiveME","link":"SemiInternalProcesses.html#anchor3","text":"Let the mu lepton be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"virtual void TimeShower::rescatterUpdate( int iSys,  EventAMPERSAND event)","link":"ImplementNewShowers.html#anchor12","text":"This method is called immediately after rescattering in the description of multiparton interactions. Thus the information on one or several systems is out-of-date, while that of the others is unchanged. We do not provide the details here, since we presume few implementors of new showers will want to touch the technicalities involved in obtaining a description of rescattering."},{"name":"double LHAup::eBeamB()","link":"LesHouchesAccord.html#anchor16","text":""},{"name":"bool DecayChannel::contains(int id1, int id2)","link":"ParticleDataScheme.html#anchor184","text":""},{"name":"Bottomonium:gg2bbbar(3DJ)[3DJ(1)]g","link":"OniaProcesses.html#anchor73","text":"Colour-singlet production of 3PJ bottomonium states via g g &rarr; bbbar[3DJ(1)] g. Code 517."},{"name":"int Event::append(Particle entryIn)","link":"EventRecord.html#anchor24","text":"appends a particle to the bottom of the event record and returns the index of this position."},{"name":"ParticleDataEntryAMPERSAND particleDataEntry()","link":"ParticleProperties.html#anchor89","text":"a reference to the ParticleDataEntry."},{"name":"HardQCD:qqbar2bbbar","link":"QCDProcesses.html#anchor20","text":"Scatterings q qbar &rarr; b bbar. Code 124."},{"name":"HiddenValley:ffbar2SvSvbar","link":"HiddenValleyProcesses.html#anchor22","text":"Pair production f fbar &rarr; Sv Svbar via intermediate gamma*/Z^*. Code 4923."},{"name":"PhotonParton:qgm2qgm","link":"ElectroweakProcesses.html#anchor43","text":"Scattering q gamma &rarr; q gamma. Code 275 (285)."},{"name":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  double px, double py, double pz,  double e, double m = 0.,  double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor25","text":"appends a particle to the bottom of the event record and returns the index of this position; see here for the meaning of the various particle properties."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; Settings::wvecDefault(string key)","link":"SettingsScheme.html#anchor48","text":"return the default value(s) of the respective setting. If the name does not exist in the database, a value false , 0 , 0. , &quot; &quot; , or a vector of length 1 and value false , 0 , 0. or &quot; &quot; , respectively, is returned."},{"name":"bool Pythia::readFile(string fileName, bool warn = true,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor8","text":""},{"name":"PartonLevel:earlyResDec","link":"MasterSwitches.html#anchor9","text":"If on then do resonance decays early, before beam handling including colour reconnection. If off then decays are done afterwards, and so are unaffected by colour reconnection. The early-decay option is still primitive, for some first studies. Eventually the choice should be made individually for each resonance based on lifetime (and the environment)."},{"name":"int Particle::mother1()","link":"ParticleProperties.html#anchor3","text":""},{"name":"bool Info::hasHistory()","link":"EventInformation.html#anchor109","text":"set/get knowledge whether the likely shower history of an event has been traced."},{"name":"HiddenValley:ffbar2nuMUvnuMUvbar","link":"HiddenValleyProcesses.html#anchor29","text":"Pair production f fbar &rarr; nuMUv nuMUvbar via intermediate gamma*/Z^*. Code 4934."},{"name":"friend ostreamAMPERSAND operatorAMPERSANDlt;AMPERSANDlt;(ostreamAMPERSAND, const Vec4AMPERSAND v)","link":"FourVectors.html#anchor32","text":"writes out the values of the four components of a Vec4 and, within brackets, a fifth component being the invariant length of the four-vector, as provided by mCalc() above, and it all ended with a newline."},{"name":"Merging:doPTLundMerging","link":"CKKWLMerging.html#anchor8","text":"The merging scale is then defined by finding the minimal Pythia evolution pT between sets of radiator, emitted and recoiler partons. For this particular merging scale definition, u,d,c,s,b,g are considered partons. The Pythia evolution pT of a single three-parton set is defined by pT evol = z ijk (1-z ijk )   Q ij 2 for FSR, where i is the radiating   parton, j is the emitted parton and k is the recoiler,   and Q ij 2 =     (p i + p j ) 2 , and z ijk =     x i,jk / (x i,jk + x j,ik ) with x i,jk =     2 p i (p i + p j + p k )      / (p i + p j + p k ) 2 pT evol = (1-z ijk )   Q ij 2 for ISR, where i is the radiating   parton, j is the emitted parton and k is the second   initial state parton, and Q ij 2 =    -(p i - p j ) 2 , and z ijk =    (p i - p j + p k ) 2 / (p i + p k ) 2. When using this option, the merging scale is defined by the minimum pT evol for all combinations of three partons in the event, irrespective of flavour or colour-connections. The merging scale value will be read from the Merging:TMS parameter, so that this needs to be set just as in the case of the kT -merging prescription. Of course you will also need to set Merging:Process and the maximal number of additional matrix element jets Merging:nJetMax."},{"name":"bool LHAup::fileFound()","link":"LesHouchesAccord.html#anchor78","text":"always returns true in the base class, but in LHAupLHEF it returns false if the LHEF provided in the constructor is not found and opened correctly."},{"name":"HiggsBSM:allHpair","link":"HiggsProcesses.html#anchor57","text":"Common switch for the group of Higgs pair-production processes."},{"name":"virtual void MyMergingHooks::init()","link":"MatchingAndMerging.html#anchor9","text":"A method that is used to initialize your MyMergingHooks class. Pythia will call this function during its initialization and after all pointers to internal classes (e.g. to instances of the Info and ParticleData classes) have been set up."},{"name":"FourthPair:ffbar2tauPrimenuPrimebar(s:W)","link":"FourthGenerationProcesses.html#anchor15","text":"Scatterings f fbar' &rarr; tau' nu'_taubar by s -channel exchange of a W^+- boson. Code 842."},{"name":"ExtraDimensionsTEV:ffbar2nuenuebar","link":"ExtraDimensionalProcesses.html#anchor34","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; nue nuebar , Code 5072."},{"name":"string Particle::nameWithStatus()","link":"ParticleProperties.html#anchor64","text":"as above, but for negative-status particles the name is given in brackets to emphasize that they are intermediaries."},{"name":"ColourReconnection:timeDilationPar","link":"ColourReconnection.html#anchor14","text":"This is a tuneable parameter for the time dilation. The definition can be seen above under timeDilationMode."},{"name":"bool SpaceShower::getHasWeaklyRadiated()","link":"ImplementNewShowers.html#anchor39","text":"This method is not virtual. It is used to tell whether a weak gauge boson has been emitted in the shower evolution."},{"name":"double Particle::pPos()","link":"ParticleProperties.html#anchor52","text":""},{"name":"TimeShower:pTdampFudge","link":"TimelikeShowers.html#anchor5","text":"In cases 1 and 2 above, where a dampening is imposed at around the factorization or renormalization scale, respectively, this allows the pT scale of dampening of radiation by a half to be shifted by this factor relative to the default Q_fac or Q_ren. This number ought to be in the neighbourhood of unity, but variations away from this value could do better in some processes."},{"name":"MultipartonInteractions:nQuarkIn","link":"MultipartonInteractions.html#anchor23","text":"Number of allowed incoming quark flavours in the beams; a change to 4 would thus exclude b and bbar as incoming partons, etc."},{"name":"HiddenValley:ffbar2nuTAUvnuTAUvbar","link":"HiddenValleyProcesses.html#anchor31","text":"Pair production f fbar &rarr; nuTAUv nuTAUvbar via intermediate gamma*/Z^*. Code 4936."},{"name":"SLHA:NMSSM","link":"SUSYLesHouchesAccord.html#anchor9","text":"Corresponds to SLHA block MODSEL entry 3."},{"name":"ExtraDimensionsTEV:ffbar2nutaunutaubar","link":"ExtraDimensionalProcesses.html#anchor38","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; nutau nutaubar , Code 5076."},{"name":"bool SlowJet::analyze( const EventAMPERSAND event)","link":"EventAnalysis.html#anchor43","text":"performs a jet finding analysis, where is an object of the Event class, most likely the pythia.event one. If the routine returns false the analysis failed, but currently this is not foreseen ever to happen."},{"name":"bool Info::isResolved()","link":"EventInformation.html#anchor16","text":"are beam particles resolved, i.e. were PDF's used for the process?"},{"name":"Diffraction:MBRdyminCDflux","link":"Diffraction.html#anchor11","text":"the minimum width of the rapidity gap used in the calculation of Ngap(s) (flux renormalization)."},{"name":"WeakBosonAndParton:qqbar2gmZg","link":"ElectroweakProcesses.html#anchor23","text":"Scattering q qbar &rarr; gamma^*/Z^0 g. Code 241."},{"name":"LeftRightSymmmetry:vL","link":"LeftRightSymmetryProcesses.html#anchor18","text":"vacuum expectation value v_L (in GeV) for the left-triplet."},{"name":"StringFlav:popcornSmeson","link":"FlavourSelection.html#anchor37","text":"extra suppression for having a strange meson M in a B M Bbar configuration."},{"name":"void ParticleData::setAll(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.)","link":"ParticleDataScheme.html#anchor24","text":"change all the properties of the particle associated with a given identity code."},{"name":"double CoupSM::sin2thetaWbar()","link":"StandardModelParameters.html#anchor27","text":"the sine-squared of the weak mixing angle, as used to derive the vector couplings of fermions to the Z^0."},{"name":"HiddenValley:gg2DvDvbar","link":"HiddenValleyProcesses.html#anchor8","text":"Pair production g g &rarr; Dv Dvbar. Code 4901."},{"name":"int Particle::chargeType()","link":"ParticleProperties.html#anchor67","text":"charge, and three times it to make an integer."},{"name":"SpaceShower:useFixedFacScale","link":"SpacelikeShowers.html#anchor34","text":"Allow the possibility to use a fixed factorization scale, set by the parm below. This option is unphysical and only intended for toy-model and debug studies."},{"name":"double MergingHooks::tms()","link":"CKKWLMerging.html#anchor24","text":"Returns the value used as the merging scale."},{"name":"Bottomonium:qqbar2bbbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor66","text":"Colour-singlet production of 3PJ bottomonium states via q qbar &rarr; bbbar[3PJ(1)] g. Code 513."},{"name":"void ParticleData::tau0(int id, double tau0)","link":"ParticleDataScheme.html#anchor49","text":""},{"name":"double ParticleData::resOpenFrac(int id1, int id2 = 0,  int id3 = 0)","link":"ParticleDataScheme.html#anchor85","text":"calculate the fraction of the full branching ratio that is left open by the user choice of allowed decay channels. Can be applied to a final state with up to three resonances. Since the procedure is multiplicative, it would be easy to generalize also to more."},{"name":"virtual Vec4 vertexForMPI( Particle parton, double bNow)","link":"UserHooks.html#anchor51","text":"Method to assign a production vertex to a particle produced in the MPI framework. Should return the production vertex as a Vec4. is (a copy of) the particle, with momentum and id information present. is the impact parameter of the event. It is not expressed in physical units (like fm), but rescaled such that the average is unity for MPI events. See the section on Multiparton Interactions for a description of choices for the b dependence."},{"name":"TauDecays:tauMother","link":"ParticleDecays.html#anchor16","text":"Mother of the tau for forced polarization when mode 2 of TauDecays:mode is selected. You should give the positive identity code; to the extent an antiparticle exists it will automatically obtain the inverse polarization."},{"name":"JetMatching:nEta","link":"JetMatching.html#anchor6","text":"Specific to the CellJet algorithm, the number of bins in pseudorapidity."},{"name":"SigmaDiffractive:maxAX","link":"TotalCrossSections.html#anchor15","text":"The above sigma_max for A + B &rarr; A + X in mb."},{"name":"SpaceShower:samePTasMPI","link":"SpacelikeShowers.html#anchor12","text":"Regularize the pT &rarr; 0 divergence using the same sharp cutoff and smooth dampening parameters as used to describe multiparton interactions. That is, the MultipartonInteractions:pT0Ref , MultipartonInteractions:ecmRef , MultipartonInteractions:ecmPow and MultipartonInteractions:pTmin parameters are used to regularize all ISR QCD radiation, rather than the corresponding parameters below. This is a sensible physics ansatz, based on the assumption that colour screening effects influence both MPI and ISR in the same way. Photon radiation is regularized separately in either case. Warning: if a large pT0 is picked for multiparton interactions, such that the integrated interaction cross section is below the nondiffractive inelastic one, this pT0 will automatically be scaled down to cope. Information on such a rescaling does NOT propagate to SpaceShower , however."},{"name":"HardQCD:gg2ggg","link":"QCDProcesses.html#anchor23","text":"Scatterings g g &rarr; g g g. Code 131."},{"name":"ExtraDimensionsG*:qqbar2G*g","link":"ExtraDimensionalProcesses.html#anchor6","text":"Scatterings q qbar &rarr; G^* g. Code 5005."},{"name":"bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0)","link":"ProgramFlow.html#anchor19","text":"offers the possibility to link your own implementation of a process and its cross section, to make it a part of the normal process generation machinery, without having to recompile the Pythia library itself.  The rules for constructing your own class from the SigmaProcess base class are described here. You may call this routine repeatedly, to add as many new processes as you wish. pointer to a SigmaProcess -derived object. This object must be instantiated by you in your program. pointer to a PhaseSpace -derived object. When not provided the internal phase-space selection machinery wll be used. Then sigmaPtr should be an instance of a class derived from one of the Sigma1Process , Sigma2Process and Sigma3Process classes for 1-, 2- and 3- particle production, in their turn derived from SigmaProcess. When provided, this object must be instantiated by you in your program. Note: The method currently always returns true."},{"name":"virtual bool UserHooks::canVetoISREmission()","link":"UserHooks.html#anchor23","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoISREmission(...) will interrupt the initial-state shower immediately after each emission and allow that emission to be vetoed."},{"name":"mapAMPERSANDlt;string, FVecAMPERSANDgt; Settings::getFVecMap(string match)","link":"SettingsScheme.html#anchor53","text":""},{"name":"Merging:includeRedundant","link":"CKKWLMerging.html#anchor40","text":"If on, then also include PDF ratios and &alpha; s factors in the  splitting probabilities used for picking a parton shower history of the matrix  element, when picking histories by the full shower splitting probability. As argued in Lon11 , this should not be done since a reweighting with PDF ratios and &alpha; s factors will be performed. However, it can give useful insight in how sensitive the results  are to the prescription on how to choose PS histories."},{"name":"double Info::sigmaGen(int i = 0)","link":"EventInformation.html#anchor103","text":""},{"name":"JetMatching:clFact","link":"JetMatching.html#anchor24","text":"The clFact parameter determines how jet-to parton matching is done. A match is defined as a squared cluster scale that equals: |clFact| * qCut for inclusive mode, |clFact| * max(qCut,min(p T (parton))) for exclusive mode, clFact &ge; 0, or |clFact| * min(k T (parton)) for exclusive mode, clFact < 0."},{"name":"PhotonCollision:gmgm2bbbar","link":"ElectroweakProcesses.html#anchor34","text":"Scattering gamma gamma &rarr; b bbar. Code 263."},{"name":"ParticleData:alphaSvalueMRun","link":"ParticleData.html#anchor9","text":"the alpha_s(M_Z) value used to define the rate at which MSbar masses run."},{"name":"Hist::Hist(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor3","text":"creates an identical copy of the histogram in the argument, including bin contents."},{"name":"void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3)","link":"EventRecord.html#anchor7","text":"Provide a listing of the whole event, i.e. of the vector<Particle>. The basic identity code, status, mother, daughter, colour, four-momentum and mass data are always given, but the methods can also be called with a few optional arguments for further information: optionally give a second line for each particle, with the production scale (in GeV), the particle polarization (dimensionless), the production vertex (in mm or mm/c) and the invariant lifetime (also in mm/c). gives a list of all daughters and mothers of a particle, as defined by the motherList(i) and daughterList(i) methods described below. It is mainly intended for debug purposes. the number of digits to the right of the decimal point shown for momenta, energies andf masses. Can be set above 3, but reducing it below 3 will have no effect. This option is intended for expert users, e.g. for debugging purposes, and so no effort has been made to stretch header and footer to match."},{"name":"ContactInteractions:etaRR","link":"CompositenessProcesses.html#anchor40","text":"Helicity parameter."},{"name":"Parton Distributions","link":"PartonDistributions.html","text":"Parton Distributions The parton distributions file contains the PDF class. PDF is the base class, from which specific PDF classes are derived. The choice of which PDF to use is made by settings in the Pythia class, see here. These settings also allow to access all the proton PDF's available in the LHAPDF library Wha05,Buc15. Thus there is no need for a normal user to study the PDF class. The structure must only be understood when interfacing new PDF's, e.g. ones not yet found in LHAPDF. The PDF base class PDF defines the interface that all PDF classes should respect. The constructor requires the incoming beam species to be given: even if used for a proton PDF, one needs to know whether the beam is actually an antiproton. This is one of the reasons why Pythia always defines two PDF objects in an event, one for each beam. Once a PDF object has been constructed, call it pdf , the main method is pdf.xf( id, x, Q2) , which returns x*f_id(x, Q2) , properly taking into account whether the beam is an antiparticle or not. Whenever the xf member is called with a new flavour, x or Q^2 , the xfUpdate member is called to do the actual updating. This routine may either update that particular flavour or all flavours at this (x, Q^2) point. (In the latter case the saved id value idSav should be set to 9.) The choice is to be made by the producer of a given set, based on what he/she deems most effective, given that sometimes only one flavour need be evaluated, and about equally often all flavours are needed at the same x and Q^2. Anyway, the latest value is always kept in memory. This is the other reason why Pythia has one separate PDF object for each beam, so that values at different x can be kept in memory. Two further public methods are xfVal( id, x, Q2) and xfSea( id, x, Q2). These are simple variants whereby the quark distributions can be subdivided into a valence and a sea part. If these are not directly accessible in the parametrization, one can make the simplified choices u_sea = ubar_sea, u_val = u_tot - u_sea , and correspondingly for d. (Positivity will always be guaranteed at output.) The xfUpdate method should also take care of updating this information. A method setExtrapolate(bool) allows you to switch between freezing parametrizations  at the x and Q^2 boundaries ( false ) or extrapolating them outside the boundaries ( true ). This method is only implemented for the LHAPDF5 class below. If you implement a new PDF you are free to use this method, but it would be smarter to hardcode the desired limiting behaviour. With insideBounds(double x, double Q2) you can probe whether an (x, Q^2) pair falls inside the fit region or not. The alphaS(double Q2) method returns the alpha_s of the PDF at the given Q^2 scale, while mQuarkPDF(int id) returns the quark masses used to set flavour thresholds. Currently these three methods are only implemented for LHAPDF6. Derived classes There is only one pure virtual method, xfUpdate , that therefore must be implemented in any derived class. A reasonable number of such classes come with the program: For protons: LHAPDF provides a plugin interface class to the LHAPDF library Wha05,Buc15. It loads either the LHAPDF5 or LHAPDF6 class. GRV94L gives the GRV 94 L parametrization Glu95. CTEQ5L gives the CTEQ 5 L parametrization Lai00. MSTWpdf gives the four distributions of the MRST/MSTW group that have been implemented. CTEQ6pdf gives the six distributions of the CTEQ/CT group that have been implemented. NNPDF gives four distributions from the NNPDF 2.3 QCD+QED sets that have been implemented. The current default is NNPDF 2.3. For charged pions: GRVpiL gives the GRV 1992 pi+ parametrization. For Pomerons (used to describe diffraction): PomFix gives a simple but flexible Q2 -independent parametrization. PomH1FitAB gives the H1 2006 Fit A and Fit B parametrizations. PomH1Jets gives the H1 2007 Jets parametrization. For photons: CJKL gives the CJKL parametrization Cor03. For charged leptons (e, mu, tau): Lepton gives a QED parametrization Kle89. In QED there are not so many ambiguities, so here one set should be enough. On the other hand, there is the problem that the lepton-inside-lepton pdf is integrably divergent for x &rarr; 1 , which gives numerical problems. Like in PYTHIA 6, the pdf is therefore made to vanish for x > 1 - 10^{-10} , and scaled up in the range 1 - 10^{-7} < x < 1 - 10^{-10} in such a way that the total area under the pdf is preserved. LeptonPoint gives the trivial distribution of a pointlike (i.e. unresolved) charged lepton. Lepton2gamma gives the convolution between photon flux from leptons and photon PDFs. For neutrinos: NeutrinoPoint is the only method, so there is no choice. Analogously to LeptonPoint it gives the distribution of a pointlike (i.e. unresolved) neutrino. A difference, however, is that neutrinos always are lefthanded, so there is no need to average over incoming spin states. Since the PYTHIA formalism assumes unpolarized beams, and thus implicitly includes a 1/2 for incoming fermions, the NeutrinoPoint PDF is normalized to 2 rather than 1 to compensate for this. There is another method, isSetup() , that returns the base-class boolean variable isSet. This variable is initially true , but could be set false if the setup procedure of a PDF failed, e.g. if the user has chosen an unknown PDF set. The MRST/MSTW, CTEQ/CT, NNPDF and H1 PDF routines are based on the interpolation in (x, Q) grids. The grid files are stored in the xmldoc subdirectory, like settings and particle data. Only PDF sets that will be used are read in during the initialization stage. Just as input streams can be used to initialize the settings and particle data, so can the individual PDFs be constructed.  See the header files for explicit constructor descriptions."},{"name":"Stat:showErrors","link":"MainProgramSettings.html#anchor18","text":"Print the available statistics on number and types of aborts, errors and warnings."},{"name":"WeakBosonAndParton:fgm2gmZf","link":"ElectroweakProcesses.html#anchor26","text":"Scattering f gamma &rarr;  gamma^*/Z^0 f. Code 244."},{"name":"ROOT usage","link":"ROOTusage.html","text":"ROOT usage Many PYTHIA users wish to use ROOT to produce histograms, or even to run PYTHIA as a plugin to ROOT. This is possible. It is not a task supported by the PYTHIA team, however. All issues involving ROOT usage should be directed to the ROOT team, or to the local support team of your collaboration. Below some helpful hints have been collected. The text is based on contributions by Rene Brun, Andreas Morsch and Axel Naumann. Another example may be found in the VINCIA add-on program for parton showers, but this should also work for a PYTHIA standalone run. Note that in all that follows, a Linux-type system with a Bash shell and GNU Make is assumed. In particular, for Mac OS X, the LD_LIBRARY_PATH should be replaced with DYLD_LIBRARY_PATH and the extension for shared libraries .so should be replaced with .dylib. Standalone usage One can perform the generation and analysis of events in a completely standalone fashion, and only use ROOT to process the completed events. Two example programs are provided in the examples directory, with details provided below.  The examples assume that ROOT is installed, that you have run ./configure --with-root=root-installation-directory where you have to specify which is the ROOT installation directory, and subsequently run make. More fine-grained options are available with configure , if need be. Histogramming with ROOT An example of histogramming with ROOT is provided in examples/main91.cc. It may be compiled and run just like the other example programs. After PYTHIA has run, a ROOT histogram of the charged multiplicity in the events will be shown. This is now stored in the hist.root file. If you can make this example work, the road should be open to do the same for all other histogramming needs. Specifically, you need to edit the examples/Makefile file to add the other programs to link as main91.cc currently does. Storing PYTHIA events in ROOT trees Instead of only generating histograms, it is possible to store entire PYTHIA events in ROOT trees. The examples/main92 code provides an example of this and is comprised of the following files: main92.cc is the main example program showing how  PYTHIA events can be stored in ROOT trees; main92LinkDef.h is used by Makefile to generate the  dictionary for all PYTHIA classes involved in the IO, as needed for  the example; and main92.h is a small include declaring the Pythia8 namespace as default. The example may be compiled and run with as usual. Afterwards, the new pytree.root file will contain the PYTHIA events. Note that files can become quite large when many events are generated. To open these files within the ROOT interpreter the PYTHIA class dictionary must be loaded, .L main92.so. In compiled code, the PYTHIA class dictionary main92.so must be linked against, to either read or write PYTHIA events to a ROOT file. Error notice It appears that ROOTCINT cannot handle the dlfcn.h header in the current ROOT version. If you run into this problem with your ROOT installation, you could try to insert the following lines in your PythiaStdlib.h file: // Stdlib header file for dynamic library loading.   #ifndef __CINT__   #define dlsym __   #include <dlfcn.h>   #undef dlsym   #endif PYTHIA as a plugin to ROOT In more ROOT-centric applications, PYTHIA can be run as a ROOT plug-in. This requires a version of ROOT that has been installed from source. The reason is that the interfaces depend on PYTHIA header files that are not distributed with ROOT. Installing ROOT is not more difficult than the PYTHIA installation, and some guidelines are provided below. Installation To be run as a plugin, PYTHIA must be compiled as a shared library. This is achieved by running the PYTHIA configure script with the --enable-shared option before make is run. Define an environment variable for the path to your PYTHIA installation directory export PYTHIA8=path_to_PYTHIA8_installation Before compiling ROOT, configure ROOT by running the configure command including the following options --enable-pythia8    --with-pythia8-incdir=$PYTHIA8/include/Pythia8    --with-pythia8-libdir=$PYTHIA8/lib In case ROOT has already been compiled before, it will only recompile the PYTHIA module and build the library libEGPythia8. Interfaces When running PYTHIA as a plugin, the exact interface structure becomes very relevant. ROOT provides two simple interfaces (wrappers) for PYTHIA 8. The code for these interfaces are located in path_to_ROOT_source/montecarlo/pythia8 The two interfaces are TPythia8 is an implementation of the TGenerator interface for PYTHIA 8. It allows you to use PYTHIA within a ROOT macro or as a plug-in  for a general-purpose particle generator based on this interface. The  main methods of the interface are GenerateEvent() which triggers the    generation of the next event, and ImportParticles(TClonesArray* particles) which copies the native PYTHIA stack into a TClonesArray of TParticles. In addition, some methods that are directly related to corresponding  PYTHIA methods are implemented ReadString(const char* string) &rarr; readString(...) ReadConfigFile(const char* string) &rarr; readFile(...) Initialize(int idAin, int idBin, double ecms) &rarr; init() Warning: this method will have to be updated for the 8.2 version! EventListing() &rarr; event.list() PrintStatistic() &rarr; stat() Warning: this method will have to be updated for    the 8.2 version! These methods provide already the basic PYTHIA functionality  interactively from the ROOT command line. However, this does not mean  that the usage of PYTHIA from within ROOT is restricted to these methods.  In compiled code, one can always obtain a pointer to the Pythia instance e.g. TPythia8      *tp = new TPythia8();    Pythia8::Pythia *p  = tp->Pythia8(); giving access to the full PYTHIA functionality. To access this  functionality in the CINT interpreter see the 'Advanced usage'  section below. TPythia8Decayer is an implementation of the TVirtualMCDecayer interface. It allows you to use PYTHIA as a plug-in decayer for simulation  frameworks based on the Virtual Monte Carlo  ( VMC ) interface  classes. The main methods of the interface are TPythia8Decayer::Init() for initialisation, TPythia8Decayer::Decay(Int_t pdg, TLorentzVector* p) to decay a particle with PDG code pdg and 4-momentum p , and ImportParticles(TClonesArray* particles) to retrieve the decay products as TParticles in the TClonesArray particles. An example A basic example for generating minimum-bias events with PYTHIA 8 inside a ROOT macro, and filling some histograms with the kinematics of the final-state particles is provided in either of the locations below /path_to_ROOT_source/tutorials/pythia/pythia8.C    /path_to_ROOT_installation/share/doc/root/tutorials/pythia/pythia8.C Note that before executing this script the environment variables PYTHIA8 and PYTHIA8DATA must be setup correctly e.g. export PYTHIA8=/path_to_PYTHIA_installation    export PYTHIA8DATA=$PYTHIA8/share/Pythia8/xmldoc your LD_LIBRARY_PATH must contain the location of the  PYTHIA 8 shared library, e.g. export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:path_to_PYTHIA8_installation/lib The script can then be run with ROOT root pythia8.C After execution, ROOT will display some histograms from the event generation. Advanced usage To access the full PYTHIA functionality from the CINT interpreter, a ROOT dictionary must be created. Currently that option has not been implemented as a standard option for PYTHIA 8.2, but it should be in the same spirit as what can be found in the 8.1 rootexamples directory. Also note that one dictionary is found in the examples/main92LinkDef.h file.  This may then be loaded in ROOT giving full access to the full PYTHIA 8 functionality, e.g. in an interactive session gSystem->Load('path_to_PYTHIA8_installation/rootexamples/pythiaDict');    Pythia8::Pythia *p = new Pythia8::Pythia();    p->readString('SoftQCD:nonDiffractive = on');"},{"name":"Bottomonium:O(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor47","text":"The colour-singlet long-distance matrix elements <O[3S1(1)]> for the 3S1 bottomonium states."},{"name":"int Info::iAMPI(int i)","link":"EventInformation.html#anchor92","text":""},{"name":"void ParticleData::listXML(string outFile)","link":"ParticleDataScheme.html#anchor10","text":"read in XML-style data from a file or write it out to a file. For the former one can also decide whether to reset all particles to scratch, or only overwrite those particles in the file. The former method is used by init and reInit above."},{"name":"HiddenValley:ffbar2Zv","link":"HiddenValleyProcesses.html#anchor32","text":"Production f fbar &rarr; Zv where Zv is a generic resonance that couples both SM fermion pairs and a qv qvbar pair. Not part of the framework of the above processes, but as an alternative. Code 4941."},{"name":"JetMatching:nJetMax","link":"JetMatching.html#anchor15","text":"When JetMatching:exclusive = 2 , nJetMax is used to indicate the maximum number of jets that will be matched."},{"name":"void ParticleData::isVisible(int id, bool isVisible)","link":"ParticleDataScheme.html#anchor57","text":""},{"name":"HiggsHchg:coup2H2W","link":"HiggsProcesses.html#anchor110","text":"The H^+- coupling to a H^0(H_2^0) W^+- pair. Is sin(beta - alpha) in the MSSM."},{"name":"ExtraDimensionsTEV:ffbar2ssbar","link":"ExtraDimensionalProcesses.html#anchor29","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; s sbar , Code 5063."},{"name":"HiddenValley:bmqv2","link":"HiddenValleyProcesses.html#anchor42","text":"The b parameter of the Lund symmetric fragmentation function, multiplied by the square of the qv mass. This scaling ensures that the fragmentation function keeps the same shape when the qv mass is changed (neglecting transverse momenta)."},{"name":"ExcitedFermion:coupFcol","link":"CompositenessProcesses.html#anchor30","text":"Strength f_c of the SU(3) coupling."},{"name":"bool ParticleDataEntry::doForceWidth()","link":"ParticleDataScheme.html#anchor131","text":"a flag applicable only for resonances (see isResonance above), whereby it is possible to force resonances to retain their assigned widths, whatever that is, see Resonance Decays for details. The normal behaviour is false , i.e. the width is based on hardcoded calculations whenever available."},{"name":"int Particle::col()","link":"ParticleProperties.html#anchor7","text":""},{"name":"int LHAup::id2pdf()","link":"LesHouchesAccord.html#anchor61","text":""},{"name":"TauDecays:mode","link":"ParticleDecays.html#anchor14","text":"Choice of tau decay model. old decay model, with isotropic decays. sophisticated decays where external and then internal determination is applied. sophisticated decays as above, but now tau s with a mother TauDecays:tauMother are forced into an uncorrelated decay with a polarization set by TauDecays:tauPolarization. sophisticated decays where all tau s, regardless of mother, are forced into an uncorrelated decay with a polarization set by TauDecays:tauPolarization. sophisticated decays where only internal determination is applied. sophisticated decays where only external (SPINUP) determination is applied. Warning 1 : options 2 and 3 , to force a specific tau polarization, only affect the decay of the tau. The angular distribution of the tau itself, given by its production, is not modified by these options. If you want, e.g., a righthanded W , or a SUSY decay chain, the kinematics should be handled by the corresponding cross section class(es), supplemented by the resonance decay one(s). The options here could then still be used to ensure the correct polarization at the tau decay stage. Warning 2 : for options 1 through 5 , if the polarization and correlation mechanism for the tau cannot be determined (internally or externally) then the default behaviour described above is applied."},{"name":"bool Settings::readingFailed()","link":"SettingsScheme.html#anchor78","text":"return true if some input could not be parsed, else false."},{"name":"friend double phi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor40","text":""},{"name":"ContactInteractions:Lambda","link":"CompositenessProcesses.html#anchor38","text":"Compositeness scale Lambda in GeV. Its overall normalization is largely a matter of convention. The choice made here for the q qbar &rarr; l- l+ processes is such that the pure contact interaction part of the left-left interactions (i.e. disregarding gamma^* , Z^0 and interference terms) has the form d(sigmaHat)/d(tHat) = pi * uHat^2 / (3 * sHat^2 * Lambda^4). The corresponding part of the q qbar &rarr; q' qbar' cross section is a factor 3 larger from colour."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Settings::mvec(string key)","link":"SettingsScheme.html#anchor38","text":""},{"name":"ExtraDimensionsLED:gg2Gg","link":"ExtraDimensionalProcesses.html#anchor43","text":"Scatterings g g &rarr; G g. Code 5021."},{"name":"string Pythia::word(string key)","link":"ProgramFlow.html#anchor34","text":"read in a string variable from the Settings database. the name of the variable to be read."},{"name":"SpaceShower:pTmaxFudge","link":"SpacelikeShowers.html#anchor2","text":"In cases where the above pTmaxMatch rules would imply that pT_max = pT_factorization , pTmaxFudge introduces a multiplicative factor f such that instead pT_max = f * pT_factorization. Only applies to the hardest interaction in an event, and a 'second hard' if there is such a one, cf. below. It is strongly suggested that f = 1 , but variations around this default can be useful to test this assumption."},{"name":"SUSY:qqbar2chi0chi0","link":"SUSYProcesses.html#anchor15","text":"Pair production of neutralinos by quark-antiquark annihilation. With four neutralino species this gives ten separate processes, codes 1201 - 1210. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated."},{"name":"Init:showMultipartonInteractions","link":"MainProgramSettings.html#anchor2","text":"Print initialization information for the multiparton interactions machinery."},{"name":"Colour reconnection","link":"ColourReconnection.html","text":"Colour Reconnection The colour flows in the separate subprocesses defined in the multiparton-interactions scenario are tied together via the assignment of colour flow in the beam remnant. This is not an unambiguous procedure, and currently two different methods are implemented. In the first model the colour flow is reconstructed by how a PS could have constructed the configuration. In the second model, the full QCD colour calculation is taken into account, however the dynamical effects are modeled loosely, only an overall saturation is taken into account. The idea is to later account for other dynamical effects through colour reconnections. A simple 'minimal' procedure of colour flow only via the beam remnants does not result in a scenario in agreement with data, however, notably not a sufficiently steep rise of <pT>(n_ch). The true origin of this behaviour and the correct mechanism to reproduce it remains one of the big unsolved issues at the borderline between perturbative and nonperturbative QCD. Since no final answer is known, several models are implemented. The different models also rely on the two different colour assignments in the beam remnant. There are two, somewhat motivated, models implemented: the original PYTHIA scheme and a new scheme that tries to incorporate more of the colour knowledge from QCD. The original PYTHIA scheme relies on the PS-like colour configuration of the beam remnant. This is combined with an additional step, wherein the gluons of a lower- pT MPI system are merged with the ones in a higher-pT MPI. A more detailed description of the merging can be found below. Relative to the other models it tests fewer reconnection possibilities, and therefore tends to be reasonably fast. The new scheme Chr14a relies on the full QCD colour configuration in the beam remnant. This is followed up by a colour reconnection, where the potential string energy is minimized (ie. the lambda measure is minimized). The QCD colour rules are also incorporated in the colour reconnection, and determine the probability that a reconnection is allowed. The model also allows the creation of junction structures. In addition to the two models described above, a simple model is implemented, wherein gluons can be moved from one location to another so as to reduce the total string length. This is one out of a range of simple models developed to study potential colour reconnection effects e.g. on top mass Arg14 , not from the point of view of having the most realistic description, but in order to probe the potential worst-case spread of predictions. All of these models are made available separately in include/Pythia8Plugins/ColourReconnectionHooks.h , with the setup illustrated in examples/main29.cc , but only the gluon-move one is sufficiently general and realistic that it has been included among the standard options here. Finally, the SK I and SK II models Sjo94 have a smaller range of applicability, originally intended for e^+ e^- &rarr; W^+ W^- , but in this context offers a more detailed approach. The MPI-based scheme In this scheme partons are classified by which MPI system they belong to. The colour flow of two such systems can be fused, and if so the partons of the lower- pT system are added to the strings defined by the higher- pT system in such a way as to give the smallest total string length. The bulk of these lower- pT partons are gluons, and this is what the scheme is optimized to handle. In more detail, an MPI system with a scale pT of the hard interaction (normally 2 &rarr; 2 ) can be merged with one of a harder scale with a probability that is pT0_Rec^2 / (pT0_Rec^2 + pT^2) , where pT0_Rec is range times pT0 , the latter being the same energy-dependent dampening parameter as used for MPIs. Thus it is easy to merge a low- pT system with any other, but difficult to merge two high- pT ones with each other. The reconnection procedure is applied iteratively. Thus first the reconnection probability P = pT0_Rec^2 / (pT0_Rec^2 + pT^2) of the lowest- pT system is found, and gives the probability for merger with the second-lowest one. If not merged, it is tested with the third-lowest one, and so on. For the m 'th higher system the reconnection probability thus becomes (1 - P)^(m-1) P. That is, there is no explicit dependence on the higher pT scale, but implicitly there is via the survival probability of not already having been merged with a lower- pT system. Also note that the total reconnection probability for the lowest- pT system in an event with n systems becomes 1 - (1 - P)^(n-1). Once the fate of the lowest- pT system has been decided, the second-lowest is considered with respect to the ones above it, then the third-lowest, and so on. Once it has been decided which systems should be joined, the actual merging is carried out in the opposite direction. That is, first the hardest system is studied, and all colour dipoles in it are found (including to the beam remnants, as defined by the holes of the incoming partons). Next each softer system to be merged is studied in turn. Its gluons are, in decreasing pT order, inserted on the colour dipole i,j that gives the smallest (p_g p_i)(p_g p_j)/(p_i p_j) , i.e. minimizes the 'disturbance' on the existing dipole, in terms of pT^2 or Lambda measure (string length). The insertion of the gluon means that the old dipole is replaced by two new ones. Also the (rather few) quark-antiquark pairs that can be traced back to a gluon splitting are treated in close analogy with the gluon case. Quark lines that attach directly to the beam remnants cannot be merged but are left behind. The joining procedure can be viewed as a more sophisticated variant of the one introduced already in Sjo87. Clearly it is ad hoc. It hopefully captures some elements of truth. The lower pT scale a system has the larger its spatial extent and therefore the larger its overlap with other systems. It could be argued that one should classify individual initial-state partons by pT rather than the system as a whole. However, for final-state radiation, a soft gluon radiated off a hard parton is actually produced at late times and therefore probably less likely to reconnect. In the balance, a classification by system pT scale appears sensible as a first try. Note that the reconnection is carried out before resonance decays are considered by default. Colour inside a resonance therefore is not reconnected. The PartonLevel:earlyResDec can be switched on to perform resonance decays before colour reconnection, and then the partons from resonance decays could be affected. Ideally the time scales of resonance decays and of colour reconnection should be picked dynamically, but this is not yet the case. Notably the W , Z and t have intermediate decay time scales, somewhat but not much shorter than typical hadronization times, whereas the H is much more long-lived. The newer scheme The newer CR scheme builds on the minimization of the string length as well as the colour rules from QCD. A main feature of the new model is the introduction of junction structures. These are possible outcomes of the reconnection in addition to the more common string-string reconnections. The model works by constructing all pair of dipoles that are allowed to reconnect by QCD colour rules and switching if the new pair has a lower string length. Junctions are also allowed to be directly produced from three, and in some special cases, four dipoles. This is done iteratively until no further allowed reconnection lowers the total string length. According to QCD colour rules, an uncorrelated triplet and anti-triplet are allowed to form a singlet state 1/9 times. This is reflected in the model by giving each dipole a colour number between 0-8 and only dipoles with the same colour number are allowed to reconnect. The junction probability is given by the product of two triplets, which provides an anti-triplet 1/3 times. This is achieved in the model by allowing reconnections between dipoles where modulo three of the color numbers agree. In addition to the colour rules, the dipoles also need to be causally connected in order to perform a reconnection. The definition of causally connected dipoles is not exact, and several different options are available. All the time dilation modes introduce a tuneable parameter, which provides a handle on the overall amount of colour reconnection. When the two strings are allowed to reconnect, they will reconnect if it lowers the total string length. The total string length is in the model defined by an approximation to the lambda -measure. Several options for different approximations are available. The lambda -measure is not well understood, especially for junction structures, and a tuneable parameter is introduced to vary the behaviour between junctions and ordinary strings. To avoid problems with very low mass string and junction structures, these are excluded from participating in the colour reconnections. This is achieved by forming the dipole or junction into a pseudo-particle if the invariant mass is too low. Especially the approximations made in the lambda -measure provides problems at low invariant masses. The new CR scheme introduce several tuneable parameters, which all are listed below. In addition to these, other parameters in PYTHIA also need to retuned to account for the new CR. The default values below, together with changing MultipartonInteractions:pT0Ref = 2.15 and ColourReconnection:allowDoubleJunRem = off , provides a good starting point. Additional fragmentation variables were also adjusted in the first tune, but these provide a smaller change (see Chr14a for a complete list). The gluon-move scheme This approach contains two steps, a first 'move' one and an optional second 'flip' one. Both are intended to reduce the total 'string length' lambda measure of an event. For multiparton topologies the correct lambda measure can become quite cumbersome, so here it is approximated by the sum of lambda contributions from each pair of partons connected by a colour string piece. For two partons i and j with invariant mass m_ij this contribution is defined as lambda_ij = ln(1 + m^2_ij / m2Lambda). The 1 is added ad hoc to avoid problems in the m_ij &rarr; 0 limit, problems which mainly comes from the approximate treatment, and m2Lambda is a parameter set below. In the move step all final gluons are identified, alternatively only a fraction fracGluon of them, and also all colour-connected parton pairs. For each gluon and each pair it is calculated how the total lambda would shift if the gluon would be removed from its current location and inserted in between the pair. The gluon move that gives the largest negative shift, if any, is then carried out. Alternatively, only shifts more negative than dLambdaCut are considered. The procedure is iterated so long as allowed moves can be found. There is some fine print. If a colour singlet subsystem consists of two gluons only then it is not allowed to move any of them, since that then would result in in a colour singlet gluon. Also, at most as many moves are made as there are gluons, which normally should be enough. A specific gluon may be moved more than once, however. Finally, a gluon directly connected to a junction cannot be moved, and also no gluon can be inserted between it and the junction. This is entirely for practical reasons, but should not be a problem, since junctions are rare in this model. The gluon-move steps will not break the connection between string endpoints, in the sense that a quark and an antiquark that are colour-connected via a number of gluons will remain so, only the number and identity of the intermediate gluons may change. Such a scenario may be too restrictive. Therefore an optional second flip step is introduced. In it all such colour chains are identified, omitting closed gluon loops. The lambda change is defined by what happens if the two colour lines are crossed somewhere, e.g. such that two systems q1 - g1 - qbar1 and q2 - g2 - qbar2 are flipped to q1 - g1 - g2 - qbar2 and q2 - qbar1. The flip that gives the largest lambda reduction is carried out, again with dLambdaCut offering a possibility to restrict the options. As with the move step, the procedure is repeated so long as it is allowed. An important restriction is imposed, however, that a given system is only allowed to flip once, and not with itself. The practical reason is that repeated flips could split off closed gluon loops quite easily, which tends to result in bad agreement with data. As an option, singlet subsystems containing a junction may or may not be allowed to take part in the flip step. Since the number of junction systems is limited in this model the differences are not so important. The e^+ e^- colour reconnection schemes The SK I and SK II models Sjo94 were specifically developed for e^+ e^- &rarr; W^+ W^- &rarr; q_1 qbar_2 q_3 qbar_4 at LEP 2, and equally well works for e^+ e^- &rarr; gamma^*/Z^0 gamma^*/Z^0. They are not intended to handle hadronic collisions, except in special contexts. The prime of these is Higgs decays of the same character as above, H^0 &rarr;  W^+ W^- / Z^0 Z^0 , since the Higgs is sufficiently long-lived that its decay products can be considered separately from the rest of the event. The administrative machinery for this possibility is not yet in place, however. The labels I and II refer to the colour-confinement strings being modelled either by analogy with type I or type II superconductors. In the former model the strings are viewed as transversely extended 'bags'. The likelihood of reconnection is then related to the integrated space-time overlap of string pieces from the W^+ with those from the W^-. In the latter model instead strings are assumed to be analogous with vortex lines, where all the topological information is stored in a thin core region. Reconnection therefore only can occur when these cores pass through each other. Both of these models are based on a detailed modelling of the space-time separation of the W^+ and W^- decay vertices, on the subsequent shower evolution, on the continued space-time evolution of all the string pieces stretched between the showered partons, and on the cutoff provided by the strings disappearing by the hadronization process. As such, they are more sophisticated than any other reconnection models. Unfortunately they would not easily carry over to hadronic collisions, where both the initial and the final states are far more complicated, and the space-time details less well controlled. The SK II model has few free parameters, giving more predictive power. Conversely, SK I has a a free overall CR strength parameter, making it more convenient for tunes to data. The LEP collaborations have used SK I as a common reference to establish the existence of CR in W^+ W^- events."},{"name":"Merging:enforceCutOnLHE","link":"CKKWLMerging.html#anchor13","text":"This will check if the events read from LHE file are in the matrix element region as defined by the merging scale definition and value(s). If on, LHE input outside the matrix element region will be rejected. If off, every event is assumed to pass the merging scale cut."},{"name":"Charmonium:qqbar2ccbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor39","text":"Colour-octet production of 3DJ charmonium states via q qbar &rarr; ccbar[3PJ(8)] g. Code 420."},{"name":"HiddenValley:Lambda","link":"HiddenValleyProcesses.html#anchor36","text":"the parameter used for the case of a running (first order) alpha_HV."},{"name":"virtual map AMPERSANDlt;string,doubleAMPERSANDgt; TimeShower::getStateVariables(  const EventAMPERSAND event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor22","text":"This function should return a map of variables related to the splitting that produced the particles event[iRad] , event[iRec] and event[iEmt]. Four entries are compulsory, - the key t gives the evolution variable associated with the splitting, - the key tRS gives the evolution variable at which the shower should be restarted after a branching, - the key scaleAS gives the argument of &alpha; s used for the branching, and - the key scalePDF gives the argument of PDF factors used for the branching. All other entries are optional and may be auxiliary variables related to the splitting (e.g. an energy sharing variable, an azimuthal angle, kinematical invariants etc.). The identifier name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"int Sphericity::nError()","link":"EventAnalysis.html#anchor8","text":"tells the number of times analyze(...) failed to analyze events, i.e. returned false."},{"name":"double Info::getWeightsCompressedValue(unsigned int n)","link":"EventInformation.html#anchor125","text":""},{"name":"virtual bool UserHooks::canVetoPT()","link":"UserHooks.html#anchor14","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoPT(...) will interrupt the downward evolution at scaleVetoPT()."},{"name":"SigmaProcess:renormScale1","link":"CouplingsAndScales.html#anchor5","text":"The Q^2 renormalization scale for 2 &rarr; 1 processes. The same options also apply for those 2 &rarr; 2 and 2 &rarr; 3 processes that have been specially marked as proceeding only through an s -channel resonance, by the isSChannel() virtual method of SigmaProcess. the squared invariant mass, i.e. sHat. fix scale set in SigmaProcess:renormFixScale below."},{"name":"SigmaProcess:renormScale2","link":"CouplingsAndScales.html#anchor6","text":"The Q^2 renormalization scale for 2 &rarr; 2 processes. the smaller of the squared transverse masses of the two outgoing particles, i.e. min(mT_3^2, mT_4^2) = pT^2 + min(m_3^2, m_4^2). the geometric mean of the squared transverse masses of the two outgoing particles, i.e. mT_3 * mT_4 = sqrt((pT^2 + m_3^2) * (pT^2 + m_4^2)). the arithmetic mean of the squared transverse masses of the two outgoing particles, i.e. (mT_3^2 + mT_4^2) / 2 = pT^2 + 0.5 * (m_3^2 + m_4^2). Useful for comparisons with PYTHIA 6, where this is the default. squared invariant mass of the system, i.e. sHat. Useful for processes dominated by s -channel exchange. fix scale set in SigmaProcess:renormFixScale below. Use squared invariant momentum transfer -tHat. This is a common choice for lepton-hadron scattering processes. In that case -tHat=Q^2."},{"name":"SigmaProcess:renormScale3","link":"CouplingsAndScales.html#anchor7","text":"The Q^2 renormalization scale for 'normal' 2 &rarr; 3 processes, i.e excepting the vector-boson-fusion processes below. Here it is assumed that particle masses in the final state either match or are heavier than that of any t -channel propagator particle. (Currently only g g / q qbar &rarr; H^0 Q Qbar processes are implemented, where the 'match' criterion holds.) the smaller of the squared transverse masses of the three outgoing particles, i.e. min(mT_3^2, mT_4^2, mT_5^2). the geometric mean of the two smallest squared transverse masses of the three outgoing particles, i.e. sqrt( mT_3^2 * mT_4^2 * mT_5^2 / max(mT_3^2, mT_4^2, mT_5^2) ). the geometric mean of the squared transverse masses of the three outgoing particles, i.e. (mT_3^2 * mT_4^2 * mT_5^2)^(1/3). the arithmetic mean of the squared transverse masses of the three outgoing particles, i.e. (mT_3^2 + mT_4^2 + mT_5^2)/3. squared invariant mass of the system, i.e. sHat. fix scale set in SigmaProcess:renormFixScale below."},{"name":"StringFragmentation:stopSmear","link":"Fragmentation.html#anchor37","text":"The W_min above is then smeared uniformly in the range W_min_smeared = W_min * [ 1 - stopSmear, 1 + stopSmear ]."},{"name":"int Info::nProcessesLHEF()","link":"EventInformation.html#anchor119","text":"return the number of processes for which the cross section is stored."},{"name":"ParticleDecays:xyMax","link":"ParticleDecays.html#anchor8","text":"The above xyMax , expressed in mm."},{"name":"void TimeShower::initPtr(Info* infoPtr, Settings* settingsPtr,  ParticleData* particleDataPtr, Rndm* rndmPtr, CoupSM* coupSMPtr,  PartonSystems* partonSystemsPtr, UserHooks* userHooksPtr)","link":"ImplementNewShowers.html#anchor3","text":"This method only imports pointers to standard facilities, and is not virtual."},{"name":"ExtraDimensionsTEV:ffbar2mu+mu-","link":"ExtraDimensionalProcesses.html#anchor35","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; mu+ mu- , Code 5073."},{"name":"Photon:sigmaNDfrac","link":"Photoproduction.html#anchor3","text":"Fraction of non-diffractive cross section of the total cross section. Default value is motivated by earlier Pythia 6 studies."},{"name":"void Vec4::py(double pyIn)","link":"FourVectors.html#anchor9","text":""},{"name":"double CoupSM::lf(int idAbs)","link":"StandardModelParameters.html#anchor33","text":""},{"name":"void Settings::resetWVec(string key)","link":"SettingsScheme.html#anchor76","text":"reset the current value to the default one."},{"name":"BoseEinstein:lambda","link":"BoseEinsteinEffects.html#anchor4","text":"The strength parameter for Bose-Einstein effects. On physical grounds it should not be above unity, but imperfections in the formalism used may require that nevertheless."},{"name":"HiddenValley:gg2BvBvbar","link":"HiddenValleyProcesses.html#anchor12","text":"Pair production g g &rarr; Bv Bvbar. Code 4905."},{"name":"bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr)","link":"ProgramFlow.html#anchor16","text":"offers the possibility to interact with the generation process at a few different specified points, e.g. to reject undesirable events at an early stage to save computer time. The rules for constructing your own class from the UserHooks base class are described here. You can only hand in one such pointer, but this may be to a class that implements several of the different allowed possibilities. pointer to a userHooks -derived object. This object must be instantiated by you in your program. Note: The method currently always returns true."},{"name":"void Hist::title(string title)","link":"Histograms.html#anchor7","text":"change the title of a histogram, but keep other properties unchanged."},{"name":"int Info::idA()","link":"EventInformation.html#anchor2","text":""},{"name":"double Info::Q2GammaB()","link":"EventInformation.html#anchor69","text":"Virtualities of the photons emitted by the leptons."},{"name":"double Rndm::gauss()","link":"RandomNumbers.html#anchor8","text":"generate random numbers according to exp(-x^2/2)."},{"name":"void Hist::fill(double xValue, double weight)","link":"Histograms.html#anchor9","text":"fill the histogram, where is the x position where the filling should occur, and is the amount of weight to be added at this x value."},{"name":"int SlowJet::sizeAll()","link":"EventAnalysis.html#anchor61","text":"gives the total current number of jets and clusters. The jets are numbered 0 through sizeJet() - 1 , while the clusters are numbered sizeJet() through sizeAll() - 1. (Internally jets and clusters are represented by two separate arrays, but are here presented in one flat range.) Note that the jets are ordered in decreasing pT , while the clusters are not ordered. When useFJcore = true there are no intermediate steps, and thus the number of clusters is zero (after jet finding)."},{"name":"bool Info::isDiffractiveA()","link":"EventInformation.html#anchor17","text":""},{"name":"bool Info::isValence1()","link":"EventInformation.html#anchor36","text":""},{"name":"PhaseSpace:pTHat3Min","link":"PhaseSpaceCuts.html#anchor9","text":"The minimum invariant pT of the highest- pT parton in QCD 2 &rarr; 3 processes."},{"name":"virtual bool LHAup::skipEvent(int nSkip)","link":"LesHouchesAccord.html#anchor68","text":"skip ahead nSkip events in the Les Houches generation sequence, without doing anything further with them. Mainly intended for debug purposes, e.g. when an event at a known location in a Les Houches Event File is causing problems. Will return false if operation fails, specifically if the end of an LHEF has been reached. The implementation in the base class simply executes setEvent() the requested number of times. The derived LHAupLHEF class (see below) only uses the setNewEventLHEF(...) part of its setEvent() method, and other derived classes could choose other shortcuts."},{"name":"LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = AMPERSANDquot;madgraphrunAMPERSANDquot;,  string exe = AMPERSANDquot;mg5_aMCAMPERSANDquot;)","link":"MadGraph5Processes.html#anchor1","text":"creates an instance of the LHAupMadgraph class. pointer to the Pythia instance, such that some of its facilities can be used inside the interface. should be true if jet matching is requested. For tree-level generation MLM matching is used, while FxFx matching is used for aMC\@NLO generation. This is set up in LHAupMadgraph::setInit() , which could be modified to represent other matching strategies or parameter values. the name of the run directory, into which MadGraph puts its (intermediate) results. the name of the MadGraph5_aMC\@NLO executable that LHAupMadgraph is meant to wrap. In additon it may be necessary to prepend the full pathname of the executable: '(something)/MG5_aMC_v2_3_3/bin/mg5_aMC'."},{"name":"ParticleDecays:zMax","link":"ParticleDecays.html#anchor9","text":"The above zMax , expressed in mm."},{"name":"double Vec4::pT2()","link":"FourVectors.html#anchor20","text":"the (squared) transverse momentum."},{"name":"Beams:LHEFheader","link":"BeamParameters.html#anchor14","text":"As some information in a Les Houches Event File init block is only known at the end of generation, some programs choose to output this as a separate file. If Beams:LHEFheader is given, information up till the end of the init block is read from this file, with the events themselves read as usual from the file given in Beams:LHEF."},{"name":"vectorAMPERSANDlt;doubleAMPERSANDgt; Settings::pvec(string key)","link":"SettingsScheme.html#anchor39","text":""},{"name":"ExtraDimensionsLED:qqbar2DJqqbarNew","link":"ExtraDimensionalProcesses.html#anchor58","text":"Scatterings q qbar &rarr; (LED G*) &rarr; q' qbar'. Number of outgoing flavours specified by nQuarkNew parameter below. Code 5035."},{"name":"Advanced Usage","link":"AdvancedUsage.html","text":"Advanced Usage On this page we collect information on a number of classes that the normal user would not encounter. There are cases where the information is essential, however, for instance to implement your own showers. The subsystems One aspect that complicates administration is that an event can contain several subsystems, each consisting of one MPI and its associated ISR and FSR. To first approximation these systems are assumed to evolve independently, but to second they are connected by the interleaved evolution, and potentially by rescattering effects. The partons of a given subsystem therefore do not have to be stored consecutively. The PartonSystems class is primarily used to keep track of the current positions of all partons belonging to each system, represented by the index iPos for a parton stored in the event-record slot event[iPos]. With 'all' we mean the currently defined two incoming partons, or none for a resonance decay, and the current set of outgoing partons, but with all ISR and FSR intermediate-state partons omitted. That is, it stores all partons that could be subject to some action in the next step of the combined MPI/ISR/FSR/BR description. As a special case, an outgoing parton is stored even if it undergoes a rescattering, and thus no longer belongs to the final state proper. The partonSystems instance of PartonSystems class is a public member of the Pythia top-level class, but is also available as a pointer partonSystemsPtr in various PartonLevel classes, e.g. inside the current instances of the TimeShower and SpaceShower classes. A number of PartonSystems methods can be used to set or get information on the subsystems: clear() resets all the contents in preparation for the next event. addSys() add a new (initially empty) subsystem to the current list and return its index iSys in the list, where index 0 is the hardest subcollision and so on. sizeSys() the number of separate subsystems. setInA(iSys, iPos), setInB(iSys, iPos) store position iPos of the incoming parton from beam A or beam B to the iSys 'th subcollision. These values are 0 initially, and should so remain if there are no beams, such as in resonance decays. addOut(iSys, iPos) store position iPos of a new outgoing parton in the iSys 'th subcollision, by appending it at the end of the current vector, with beginning in slot 0. setOut(iSys, iMem, iPos) store position iPos in the iMem 'th slot in the vector of outgoing partons in the iSys 'th subcollision. Here iMem must be in the range already constructed by addOut calls. replace(iSys, iPosOld, iPosNew) replace the existing incoming or outgoing parton position iPosOld by iPosNew in the iSys 'th subcollision. setSHat(iSys, sHat) set the invariant squared mass sHat of the iSys 'th subcollision. hasInAB(iSys) true if an incoming parton has been set for beam A or beam B (and hence should have been set for both) in the iSys 'th subcollision, else false. getInA(iSys), getInB(iSys) the position iPos of the incoming parton from beam A or beam B to the iSys 'th subcollision. sizeOut(iSys) the number of outgoing partons in the iSys 'th subcollision. getOut(iSys, iMem) the position iPos of an outgoing parton in the iSys 'th subcollision, with the iMem range limited by sizeOut(iSys). These partons are not guaranteed to appear in any particular order. sizeAll(iSys) the total number of incoming and outgoing partons in the iSys 'th subcollision. getAll(iSys, iMem) the position iPos of an incoming or outgoing parton in the iSys 'th subcollision. In case there are beams it gives same as getInA(iSys) and getInB(iSys) for indices 0 and 1, and thereafter agrees with getOut(iSys, iMem) offset two positions. If there are no beams it is identical with getOut(iSys, iMem). getSHat(iSys) the invariant squared mass sHat of the iSys 'th subcollision. list() print a listing of all the system information, except for the sHat values. New systems are created from the hard process and by the MPI, not from any of the other components. Both FSR and ISR modify the position of partons, however. Since an FSR or ISR branching typically implies a new state with one more parton than before, an outgoing parton must be added to the system. Furthermore, in a branching, several existing partons may also be moved to new slots, including the incoming beam ones. In a FSR 1 &rarr; 2 branching it is irrelevant which parton position you let overwrite the existing slot and which is added to the end of the system. The system information must be kept up-to-date. Both the MPI, ISR, FSR and BR descriptions make extensive use of the existing information. As an example, the introduction of primordial kT in the beam remnants will fail if the information on which final-state partons belong to which system is out-of-date. The introduction of rescattering as part of the MPI framework adds further complications, where an outgoing parton of one subsystem may be the incoming one of another system. This part of the code is still under development. Currently the system information is kept throughout the continued history of the event. Specifically, resonance decays create new systems, appended to the existing ones. This could be useful during the hadronization stage, to collect the partons that belong to a resonance with preserved mass when a small string collapses to one particle, but is not yet used for that. The beams The different subsystems are tied together by them sharing the same initial beam particles, and thereby being restricted by energy-momentum and flavour conservation issues. The information stored in the two beam particles, here called beamA and beamB , is therefore as crucial to keep correct as the above subsystem list. Both beam objects are of the BeamParticle class. Each such object contains a vector with the partons extracted from it. The number of such partons, beamX.size() (X = A or B), of course is the same as the above number of subsystems in the event record. (The two diverge at the BR step, where further beam remnants are added to the beams without corresponding to new subsystems.) The individual partons are accessed by an overloaded indexing operator to a vector of ResolvedParton objects. The iPos() property corresponds to the iPos one above, i.e. providing the position in the main event record of a parton. In particular, beamA[iSys].iPos() = partonSystemsPtr->getInA(iSys) and beamB[iSys].iPos() = partonSystemsPtr->getInB(iSys). Whereas thus the indices of the two incoming partons to a subsystem are stored in two places, the ones of the outgoing partons only appear in the system part of the PartonSystems class. Just as the subsystems in PartonSystems must be updated, so must the information in the two BeamParticle 's, e.g. with methods beamX[iSys].iPos( iPosIn) when an incoming parton is replaced by a new one in line iPosIn. Furthermore the new parton identity should be set by beamX[iSys].id( idIn) and the new x energy-momentum fraction by beamX[iSys].x( xIn). The three can be combined in one go by beamX[iSys].update( iPosIn, idIn, xIn). To be specific, it is assumed that, at each step, the two incoming partons are moving along the +-z axis and are massless. Since the event is constructed in the c.m. frame of the incoming beams this implies that x = 2 E / E_cm. If the x values are not defined accordingly or not kept up-to-date the BR treatment will not conserve energy-momentum. In return, the BeamParticle objects give access to some useful methods. The beamX.xf( id, x, Q2) returns the standard PDF weight x f_id(x, Q^2). More interestingly, beamX.xfISR( iSys, id, x, Q2) returns the modified weight required when several subsystems have to share the energy and flavours. Thus iSys is added as an extra argument, and the momentum already assigned to the other subsystems is not available for evolution, i.e. the maximal x is correspondingly smaller than unity. Also flavour issues are handled in a similar spirit. An additional complication is that a parton can be either valence or sea, and in the latter case the BR treatment also distinguishes companion quarks, i.e. quark-antiquark pairs that are assumed to come from the same original g &rarr; q qbar branching, whether perturbative or not. This can be queried either with the beamX[iSys].companion() method, for detailed information, or with the beamX[iSys].isValence() , beamX[iSys].isUnmatched() and beamX[iSys].isCompanion() methods for yes/no answers whether a parton is valence, unmatched sea or matched sea. This choice should affect the ISR evolution; e.g., a valence quark cannot be constructed back to come from a gluon. To keep this info up-to-date, the beamX.pickValSeaComp() method should be called whenever a parton of a new flavour has been picked in the ISR backwards evolution, but not if the flavour has not been changed, since then one should not be allowed to switch back and forth between the same quark being considered as valence or as sea. Since the pickValSeaComp() method makes use of the current parton-density values, it should be preceded by a call to beamX.xfISR( iSys, id, x, Q2) , where the values in the call are the now finally accepted ones for the newly-found mother. (Such a call is likely to have been made before, during the evolution, but is not likely to be the most recent one, i.e. still in memory, and therefore had better be redone.)"},{"name":"int SigmaProcess::code()","link":"SemiInternalProcesses.html#anchor13","text":"returns an integer identifier of the process. This has no internal function, but is only intended as a service for the user to rapidly (and hopefully uniquely) identify which process occurred in a given event. Numbers below 10000 are reserved for internal PYTHIA use."},{"name":"double Info::tPomeronA()","link":"EventInformation.html#anchor63","text":""},{"name":"Merging:kFactor0j","link":"NLOMerging.html#anchor6","text":"The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of zero-jet tree-level events."},{"name":"double ParticleDataEntry::mMin()","link":"ParticleDataScheme.html#anchor115","text":"the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there."},{"name":"bool Pythia8ToHepMC::store_proc()","link":"HepMCInterface.html#anchor14","text":"for each event store information on the Pythia process code, the renormalization scale, and alpha_em and alpha_s values used for the hard process."},{"name":"FourthGeneration:VtPrimebPrime","link":"FourthGenerationProcesses.html#anchor22","text":"The V_t'b' matrix element in the 4 * 4 CKM matrix."},{"name":"double ParticleDataEntry::resOpenFrac(int idSgn)","link":"ParticleDataScheme.html#anchor165","text":"calculate the fraction of the full branching ratio that is left open by the user choice of allowed decay channels."},{"name":"RHadrons:mOffsetCloud","link":"RHadrons.html#anchor9","text":"Extra mass (in GeV) added to each of the one or two extra constituent masses in an R-hadron, to calculate the mass of a R-hadron. The same offset is also used when the R-hadron momentum and mass is split between the squark or gluino and the one or two light (di)quarks, one for a squark and two for a gluino. Thus once or twice this amount represents a part of the nominal squark or gluino mass that will not decay weakly, since it is taken to correspond to the cloud of gluons that surround the squark or gluino."},{"name":"ColourReconnection:singleReconnection","link":"ColourReconnection.html#anchor20","text":"Limit the number of reconnections to a single reconnection."},{"name":"double SlowJet::dNext()","link":"EventAnalysis.html#anchor65","text":"if the next step is to join two clusters, then the methods give the (i,j, d_ij) values, if instead to promote a cluster to a jet then (i, -1, d_iB). If no clusters remain then (-1, -1, 0.). Note that the cluster numbers are offset as described above, i.e. they begin at sizeJet() , which of course easily could be subtracted off. Also note that the jet and cluster lists are (moderately) reshuffled in each new step. When useFJcore = true there are no intermediate steps, and thus these methods do not return meaningul information."},{"name":"TimeShower:factorMultFac","link":"TimelikeShowers.html#anchor11","text":"The default pT^2 factorization scale is multiplied by this prefactor."},{"name":"SUSY:idVecA","link":"SUSYProcesses.html#anchor4","text":"As for SUSY:idA , but as a vector of PDG codes. Thus, it selects only processes that have a final-state particle corresponding to one of the identity codes in this vector. Note that, to activate this, SUSY:idA must be equal to zero; if not then the match to SUSY:idA takes precedence. Character-string input of this vector should be as a comma-separated list, without any blanks."},{"name":"LeftRightSymmmetry:ff2HRff","link":"LeftRightSymmetryProcesses.html#anchor14","text":"Scatterings f_1 f_2 &rarr; H_R^-- f_3 f_4 via WW fusion. Code 3145."},{"name":"SUSY:qqbar2chi0gluino","link":"SUSYProcesses.html#anchor20","text":"Associated neutralino-gluino production by quark-antiquark annihilation. The cross section expressions follow Fuk11. Only the MFV case has been explicitly validated."},{"name":"Hadron Scattering","link":"HadronScattering.html","text":"Hadron Scattering This page describes a few simple hadron (re)scattering models. They are intended to take into account that the overlap of multiple strings at low transverse dimensions is likely to lead to some collective effects, not unlike those observed in heavy-ion collisions, even if not quite as pronounced. Specifically, it is assumed that the hadrons produced can scatter against each other on the way out, before the fragmenting system has had time to expand enough that the hadrons get free. Thereby heavier particles are shifted to higher transverse momenta, at the expense of the lighter ones. The main switch on/off switch for rescattering is HadronLevel:HadronScatter , which by the default is off, since all models are rather simplistic and have to be used with some caution. Currently there are three different options available: The New Model for Hadron Scattering Within the new modle, there are two options available for how hadron pairs are found: Rapidity based This corresponds to HadronScatter:mode = 0. Probe all hadron pairs with an invariant mass m inv < (m 2 1 +p 2 Max ) 1/2 + (m 2 2 +p 2 Max ) 1/2 with the parameter p Max If a hadron pair passes this cut, the scattering probability for hadrons of different strings is P DS (&#x394y) = P max DS (1 - &#x394y/&#x394y max ) with rapidity difference &#x394y of the hadron pair and the parameters &#x394y max and P max DS , see below. If the hadrons are produced within the same string the probability is P DS (&#x394y) P max SS if the hadrons are further apart from each other as HadronScatter:neighbourFar , 0 if they are closer together as HadronScatter:neighbourNear , and linear between the maximum HadronScatter:maxProbSS and minimum probability HadronScatter:minProbSS inbetween. Rapidity and Azimuth based This corresponds to HadronScatter:mode = 1. All hadron pairs are considered. The scattering probability for hadrons of different strings is P DS (&#x394y,&#x394&#x3C6) = P max DS (1 - ((&#x394y) 2 +(&#x394&#x3C6) 2 ) 1/2 /R max ) with rapidity difference &#x394y and difference in azimuth &#x394&#x3C6 of the hadron pair and the parameters R max and P max DS , see below. The probability for hadron pairs from the same string is similar to the one before. Common Parameters The following paramters are used for both the above cases: The Old Model for Hadron Scattering Warning: This is still at an experimental level, and should not be used unless you know what you are doing. Hadron selection Scattering probability"},{"name":"ResonanceWidths:minWidth","link":"ResonanceDecays.html#anchor1","text":"Minimal allowed width of a resonance, in GeV. If the width falls below this number the resonance is considered stable and will not be allowed to decay. This is mainly intended as a technical parameter, to avoid disasters in cases where no open decay channels exists at all. It could be used for real-life decisions as well, however, but then typically would have to be much bigger than the default value. Special caution would be needed if coloured resonance particles were made stable, since the program would not necessarily know how to hadronize them, and therefore fail at that stage."},{"name":"Merging:dRijMS","link":"CKKWLMerging.html#anchor12","text":"The value of the minimal &Delta;R ij separation between pairs of final state partons used in the matrix element generation, where &Delta;R ij 2 = (&Delta;y ij ) 2 + (&Delta;&phi; ij ) 2."},{"name":"MultipartonInteractions:coreRadius","link":"MultipartonInteractions.html#anchor13","text":"When assuming a double Gaussian matter profile, bProfile = 2 , the inner core is assumed to have a radius that is a factor coreRadius smaller than the rest."},{"name":"HiggsBSM:allA3","link":"HiggsProcesses.html#anchor44","text":"Common switch for the group of A^0(H_3^0) production processes."},{"name":"virtual double SpaceShower::enhancePTmax()","link":"ImplementNewShowers.html#anchor32","text":"When the above method limits pT_max to the scale of the process, it may still be convenient to vary the matching slightly for the hardest interaction in an event, to probe the sensitivity to such details. The base-class implementation returns the value of the SpaceShower:pTmaxFudge parameter."},{"name":"PhotonCollision:all","link":"ElectroweakProcesses.html#anchor31","text":"Common switch for the group of six processes presented below."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Particle::daughterList()","link":"ParticleProperties.html#anchor96","text":"returns a vector of all the daughter indices of the particle. This is derived from the daughter1 , daughter2 and status information as explained above. This list is empty for a particle that did not decay (or, if the evolution is stopped early enough, a parton that did not branch), while otherwise it can contain a list of varying length, from one to many. For the two incoming beam particles, all shower initiators and beam remnants are counted as daughters, with the one in slot 0 being the one leading up to the hardest interaction. The 'system' in line 0 does not have any daughters, i.e. is not counted as part of the history. Many partons may have the same daughterList. Daughters are listed in ascending order."},{"name":"bool Particle::isFinalPartonLevel()","link":"ParticleProperties.html#anchor100","text":"is true if the particle belonged to the final state (i.e. with positive status code) right before hadronization is invoked. This is intended to further simple comparisons between parton-level and hadron-level properties, say the number of jets. This method makes use of the event record size set when HadronLevel::next() is invoked, so would not work otherwise (unless Event::savePartonLevelSize() is called by hand). Note that what should be counted as parton level is not always unique. For instance, R-hadron formation is part of the hadron level machinery, even though a subsequent R-hadron decay could well give rise to new activity on the parton level, which thereby is missed."},{"name":"double Vec4::pT()","link":"FourVectors.html#anchor19","text":""},{"name":"PDF Selection","link":"PDFSelection.html","text":"PDF Selection This page contains six subsections. The first deals with how to pick the parton distribution set for protons, including from LHAPDF, to be used for all proton and antiproton beams. The second is a special option that allows a separate PDF set to be used for the hard process only, while the first choice would still apply to everything else. The third, fourth and fifth give access to pion, Pomeron and photon PDF's, respectively, the second being used to describe diffractive systems. The sixth gives the possibility to switch off the lepton 'parton density'. More information on PDF classes is found here. Parton densities for protons PYTHIA comes with a reasonably complete list of recent LO fits built-in, both ones within the normal LO context and ones with modifications for better matching to event generators. In addition two older sets are included for backwards reference (most studies to date are based on CTEQ 5L). Therefore there is no real need to link any external PDF sets. If the internal PDF sets are not sufficient, the LHAPDF library Wha05,Buc15 gives you access to a much wider selection. Warning 1: owing to previous problems with the behaviour of PDF's beyond the x and Q^2 boundaries of a set, you should only use LHAPDF version 5.3.0 or later. Warning 2: the behaviour of the LHAPDF sets need not be identical with the implementation found in PYTHIA. Specifically we are aware of the following points that may influence a comparison. (a) CTEQ 5L in PYTHIA is the parametrization, in LHAPDF the grid interpolation. (b) MRST LO* and LO** in PYTHIA is based on an updated edition, where one makes use of the expanded MSTW grid format, while LHAPDF is based on the original smaller grid. (c) The CTEQ 6 and CT09MC sets in PYTHIA are frozen at the boundaries of the grid, by recommendation of the authors, while LHAPDF also offers an option with a smooth extrapolation outside the grid boundaries. If you do not want to install LHAPDF, it is possible to use LHAPDF6 data grids natively in PYTHIA. This is based on a simplified implementation of interpolation in a .dat 'lhagrid1' file, and so does not give fully identical results, and also is not foolproof. The selection of parton densities is made once and then is propagated through the program. It is essential to make an informed choice, for several reasons Kas10 : Warning 1: the choice of PDF set affects a number of properties of events. A change of PDF therefore requires a complete retuning e.g.  of the multiparton-interactions model for minimum-bias and underlying events. Conversely, the pp physics tunes are all made for a specific PDF tune, and the chosen (or default) tune will therefore overwrite the PDF:pSet default value described below. If you want to set PDF:pSet differently it should be done after the Tune:pp value, if any, has been set. Warning 2: People often underestimate the differences between different sets on the market. The sets for the same order are constructed to behave more or less similarly at large x and Q^2 , while the multiparton interactions are dominated by the behaviour in the region of small x and Q^2. A good PDF parametrization ought to be sensible down to x = 10^-6 ( x = 10^-7 ) and Q^2 = 1 GeV^2 for Tevatron (LHC) applications. Unfortunately there are distributions on the market that completely derail in that region. The main51.cc and main52.cc programs in the examples subdirectory provide some examples of absolutely minimal sanity checks before a new PDF set is put in production. Warning 3: NLO and LO sets tend to have quite different behaviours, e.g. NLO ones have less gluons at small x, which then is compensated by positive corrections in the NLO matrix elements. Therefore do not blindly assume that an NLO tune has to be better than an LO one when combined with the LO matrix elements in PYTHIA. There are explicit examples where such thinking can lead you down the wrong alley, especially if you study low- pT physics. A longer discussion on this point can be found in this note. In the list below you should therefore be extra cautious when using set 6 or set 9. If you want to use PDF's not found in LHAPDF, or you want to interface LHAPDF another way, you have full freedom to use the more generic interface options. Parton densities for protons in the hard process The above options provides a PDF set that will be used everywhere: for the hard process, the parton showers and the multiparton interactions alike. As already mentioned, therefore a change of PDF should be accompanied by a complete retuning of the whole MPI framework, and maybe more. There are cases where one may want to explore different PDF options for the hard process, but would not want to touch the rest. If several different sets are to be compared, a simple reweighting based on the originally used flavour, x , Q^2 and PDF values may offer the best route. The options in this section allow a choice of the PDF set for the hard process alone, while the choice made in the previous section would still be used for everything else. The hardest interaction of the minimum-bias process is part of the multiparton-interactions framework and so does not count as a hard process here. Of course it is inconsistent to use different PDF's in different parts of an event, but if the x and Q^2 ranges mainly accessed by the components are rather different then the contradiction would not be too glaring. Furthermore, since standard PDF's are one-particle-inclusive we anyway have to 'invent' our own PDF modifications to handle configurations where more than one parton is kicked out of the proton Sjo04. The PDF choices that can be made are the same as above, so we do not repeat the detailed discussion. Parton densities for pions The parton densities of the pion are considerably less well known than those of the proton. There are only rather few sets on the market, and none particularly recent. Only one comes built-in, but others can be accessed from LHAPDF. Input parametrizations are for the pi+. From this the pi- is obtained by charge conjugation and the pi0 from averaging (half the pions have d dbar valence quark content, half u ubar. Much of the switches are taken over from the proton case, with obvious modifications; therefore the description is briefer. Currently we have not seen the need to allow separate parton densities for hard processes. When using LHAPDF the PDF:extrapolateLHAPDF switch of the proton also applies to pions. Parton densities for Pomerons The Pomeron is introduced in the description of diffractive events, i.e. a diffractive system is viewed as a Pomeron-proton collision at a reduced CM energy. Here the PDF's are even less well known. Most experimental parametrizations are NLO, which makes them less well suited for Monte Carlo applications. Furthermore note that the momentum sum is arbitrarily normalized to a non-unity value. Parton densities for photons Photon PDFs describe the partonic content of the resolved photons and can be used to generate any process initiated by quarks and gluons. There are several PDF sets available for photons, although there have not been much activity recently. Currently one internal set is included, but more sets are available from LHAPDF5. The sets from LHAPDF5 can only be used as PDFs in the hard process (see PDF:GammaHardSet below). In case of photons the parton shower and beam remnant generation require additional methods that are provided only for internal sets. Currently no photon PDFs have been included in LHAPDF6. Parton densities for leptons For electrons/muons/taus there is no need to choose between different parametrizations, since only one implementation is available, and should be rather uncontroversial (apart from some technical details). However, insofar as e.g. e^+ e^- data often are corrected back to a world without any initial-state photon radiation, it is useful to have a corresponding option available here. Neutrinos are always taken pointlike. Do note that the phase space selection machinery currently does not allow one resolved and one unresolved lepton beam. For lepton-neutrino collisions to work you must therefore set PDF:lepton = off. Photons from lepton beams Lepton beams can emit photons and therefore may have partonic content. The PDFs describing these can be obtained by convoluting the photon flux with the selected photon PDFs. The photon flux is modelled according to equivalent photon approximation (EPA) which gives the flux of bremsstrahlung photons. Incoming parton selection There is one useful degree of freedom to restrict the set of incoming quark flavours for hard processes. It does not change the PDF's as such, only which quarks are allowed to contribute to the hard-process cross sections. Note that separate but similarly named modes are available for multiparton interactions and spacelike showers."},{"name":"bool Particle::undoDecay()","link":"ParticleProperties.html#anchor102","text":"removes the decay chain of the particle and thus restores it to its undecayed state. It is only intended for 'normal' particle decay chains, and will return false in other cases, notably if the particle is coloured. The procedure would not work if non-local momentum shifts have been performed, such as with a Bose-Einstein shift procedure (or for a dipole shower recoiler). As the decay products are erased from the event record, mother and daughter indices are updated to retain a correct history for the remaining particles."},{"name":"bool ParticleDataEntry::isDiquark()","link":"ParticleDataScheme.html#anchor143","text":"true for a diquark or antidiquark."},{"name":"HiddenValley:all","link":"HiddenValleyProcesses.html#anchor7","text":"Common switch for the group of all hard Hidden Valley processes, as listed separately in the following."},{"name":"Timelike Showers","link":"TimelikeShowers.html","text":"Timelike Showers The PYTHIA algorithm for timelike final-state showers is based on the article Sjo05 , where a transverse-momentum-ordered evolution scheme is introduced, with the extension to fully interleaved evolution covered in Cor10a. This algorithm is influenced by the previous mass-ordered algorithm in PYTHIA Ben87 and by the dipole-emission formulation in Ariadne Gus86. From the mass-ordered algorithm it inherits a merging procedure for first-order gluon-emission matrix elements in essentially all two-body decays in the standard model and its minimal supersymmetric extension Nor01. The normal user is not expected to call TimeShower directly, but only have it called from Pythia. Nonetheless, some of the parameters below, in particular TimeShower:alphaSvalue , would be of interest for uncertainty estimates and tuning exercises. Note that PYTHIA also incorporates an automated framework for shower uncertainty variations. Main variables Often the maximum scale of the FSR shower evolution is understood from the context. For instance, in a resonance decay half the resonance mass sets an absolute upper limit. For a hard process in a hadronic collision the choice is not as unique. Here the factorization scale has been chosen as the maximum evolution scale. This would be the pT for a 2 &rarr; 2 process, supplemented by mass terms for massive outgoing particles. For some special applications we do allow an alternative. The amount of QCD radiation in the shower is determined by The actual value is then regulated by the running to the scale pT^2 , at which the shower evaluates alpha_strong. The CMW rescaling of Lambda_QCD (see the section on StandardModelParameters ) can be applied to the alpha_strong values used for timelike showers. Note that tunes using this option need lower values of alpha_strong(m_Z^2) than tunes that do not. QED radiation is regulated by the alpha_electromagnetic value at the pT^2 scale of a branching. The natural scale for couplings, and PDFs for dipoles stretching out to the beam remnants, is pT^2. To explore uncertainties it is possibly to vary around this value, however, in analogy with what can be done for hard processes. (Note that there is also an automated framework for shower uncertainties.) The rate of radiation if divergent in the pT &rarr; 0 limit. Here, however, perturbation theory is expected to break down. Therefore an effective pT_min cutoff parameter is introduced, below which no emissions are allowed. The cutoff may be different for QCD and QED radiation off quarks, and is mainly a technical parameter for QED radiation off leptons. Shower branchings gamma &rarr; f fbar , where f is a quark or lepton, in part compete with the hard processes involving gamma^*/Z^0 production. In order to avoid overlap it makes sense to correlate the maximum gamma mass allowed in showers with the minimum gamma^*/Z^0 mass allowed in hard processes. In addition, the shower contribution only contains the pure gamma^* contribution, i.e. not the Z^0 part, so the mass spectrum above 50 GeV or so would not be well described. Interleaved evolution Multiparton interactions (MPI) and initial-state showers (ISR) are always interleaved, as follows. Starting from the hard interaction, the complete event is constructed by a set of steps. In each step the pT scale of the previous step is used as starting scale for a downwards evolution. The MPI and ISR components each make their respective Monte Carlo choices for the next lower pT value. The one with larger pT is allowed to carry out its proposed action, thereby modifying the conditions for the next steps. This is relevant since the two components compete for the energy contained in the beam remnants: both an interaction and an emission take away some of the energy, leaving less for the future. The end result is a combined chain of decreasing pT values, where ones associated with new interactions and ones with new emissions are interleaved. There is no corresponding requirement for final-state radiation (FSR) to be interleaved. Such an FSR emission does not compete directly for beam energy (but see below), and also can be viewed as occurring after the other two components in some kind of time sense. Interleaving is allowed, however, since it can be argued that a high- pT FSR occurs on shorter time scales than a low- pT MPI, say. Backwards evolution of ISR is also an example that physical time is not the only possible ordering principle, but that one can work with conditional probabilities: given the partonic picture at a specific pT resolution scale, what possibilities are open for a modified picture at a slightly lower pT scale, either by MPI, ISR or FSR? Complete interleaving of the three components also offers advantages if one aims at matching to higher-order matrix elements above some given scale. As an aside, it should be noted that such interleaving does not affect showering in resonance decays, such as a Z^0. These decays are only introduced after the production process has been considered in full, and the subsequent FSR is carried out inside the resonance, with preserved resonance mass. One aspect of FSR for a hard process in hadron collisions is that often colour dipoles are formed between a scattered parton and a beam remnant, or rather the hole left behind by an incoming partons. If such holes are allowed as dipole ends and take the recoil when the scattered parton undergoes a branching then this translates into the need to take some amount of remnant energy also in the case of FSR, i.e. the roles of ISR and FSR are not completely decoupled. The energy taken away is bookkept by increasing the x value assigned to the incoming scattering parton, and a reweighting factor x_new f(x_new, pT^2) / x_old f(x_old, pT^2) in the emission probability ensures that not unphysically large x_new values are reached. Usually such x changes are small, and they can be viewed as a higher-order effect beyond the accuracy of the leading-log initial-state showers. This choice is not unique, however. As an alternative, if nothing else useful for cross-checks, one could imagine that the FSR is completely decoupled from the ISR and beam remnants. When there is no interleaving, a number of MPIs may have been generated before FSR is considered. In principle there could be colour correlations between the MPIs, such that a final-state colour of one MPI could be matched by the corresponding final-state anticolour of another MPI. These thereby would form a colour dipole, but one that does not come out from a common vertex, and therefore presumably could not radiate in full. Currently the standard procedure is to match colours between MPIs only after FSR, so MPI systems would radiate independently, with recoils taken by the beam remnant, where necessary. This could change, however, and the following switch would then regulate the choice of behaviour. Global recoil The final-state algorithm is based on dipole-style recoils, where one single parton takes the full recoil of a branching. This is unlike the initial-state algorithm, where the complete already-existing final state shares the recoil of each new emission. As an alternative, also the final-state algorithm contains an option where the recoil is shared between all partons in the final state. Thus the radiation pattern is unrelated to colour correlations. This is especially convenient for some matching algorithms, like MC\@NLO, where a full analytic knowledge of the shower radiation pattern is needed to avoid double-counting. (The pT -ordered shower is described in Sjo05 , and the corrections for massive radiator and recoiler in Nor01 .) Technically, the radiation pattern is most conveniently represented in the rest frame of the final state of the hard subprocess. Then, for each parton at a time, the rest of the final state can be viewed as a single effective parton. This 'parton' has a fixed invariant mass during the emission process, and takes the recoil without any changed direction of motion. The momenta of the individual new recoilers are then obtained by a simple common boost of the original ones. This alternative approach will miss out on the colour coherence phenomena. Specifically, with the whole subcollision mass as 'dipole' mass, the phase space for subsequent emissions is larger than for the normal dipole algorithm. The phase space difference grows as more and more gluons are created, and thus leads to a way too steep multiplication of soft gluons. Therefore the main application is for the first one or few emissions of the shower, where a potential overestimate of the emission rate is to be corrected for anyway, by matching to the relevant matrix elements. Thereafter, subsequent emissions should be handled as before, i.e. with dipoles spanned between nearby partons. Furthermore, only the first (hardest) subcollision is handled with global recoils, since subsequent MPI's would not be subject to matrix element corrections anyway. In order for the mid-shower switch from global to local recoils to work, colours are traced and bookkept just as for normal showers; it is only that this information is not used in those steps where a global recoil is requested. (Thus, e.g., a gluon is still bookkept as one colour and one anticolour dipole end, with half the charge each, but with global recoil those two ends radiate identically.) Two variations of the scheme outlined above are also available, (motivated by comparative studies within aMC\@NLO). These studies indicate that global recoils should be used as sparsely as possible, in order to retain desirable features of the radiation pattern produced with the local recoil prescription. The global-recoil machinery does not work well with rescattering in the MPI machinery, since then the recoiling system is not uniquely defined. MultipartonInteractions:allowRescatter = off by default, so this is not a main issue. If both options are switched on, rescattering will only be allowed to kick in after the global recoil has ceased to be active, i.e. once the nMaxGlobalRecoil limit has been exceeded. This should not be a major conflict, since rescattering is mainly of interest at later stages of the downwards pT evolution. Further, it is strongly recommended to set TimeShower:MEcorrections = off (not default!), i.e. not to correct the emission probability to the internal matrix elements. The internal ME options do not cover any cases relevant for a multibody recoiler anyway, so no guarantees are given what prescription would come to be used. Instead, without ME corrections,  a process-independent emission rate is obtained, and user hooks can provide the desired process-specific rejection factors. Radiation off octet onium states In the current implementation, charmonium and bottomonium production can proceed either through colour singlet or colour octet mechanisms, both of them implemented in terms of 2 &rarr; 2 hard processes such as g g &rarr; (onium) g. In the former case the state does not radiate and the onium therefore is produced in isolation, up to normal underlying-event activity. In the latter case the situation is not so clear, but it is sensible to assume that a shower can evolve. (Assuming, of course, that the transverse momentum of the onium state is sufficiently high that radiation is of relevance.) There could be two parts to such a shower. Firstly a gluon (or even a quark, though less likely) produced in a hard 2 &rarr; 2 process can undergo showering into many gluons, whereof one branches into the heavy-quark pair. Secondly, once the pair has been produced, each quark can radiate further gluons. This latter kind of emission could easily break up a semibound quark pair, but might also create a new semibound state where before an unbound pair existed, and to some approximation these two effects should balance in the onium production rate. The showering 'off an onium state' as implemented here therefore should not be viewed as an accurate description of the emission history step by step, but rather as an effective approach to ensure that the octet onium produced 'in the hard process' is embedded in a realistic amount of jet activity. Of course both the isolated singlet and embedded octet are likely to be extremes, but hopefully the mix of the two will strike a reasonable balance. However, it is possible that some part of the octet production occurs in channels where it should not be accompanied by (hard) radiation. Therefore reducing the fraction of octet onium states allowed to radiate is a valid variation to explore uncertainties. If an octet onium state is chosen to radiate, the simulation of branchings is based on the assumption that the full radiation is provided by an incoherent sum of radiation off the quark and off the antiquark of the onium state. Thus the splitting kernel is taken to be the normal q &rarr; q g one, multiplied by a factor of two. Obviously this is a simplification of a more complex picture, averaging over factors pulling in different directions. Firstly, radiation off a gluon ought to be enhanced by a factor 9/4 relative to a quark rather than the 2 now used, but this is a minor difference. Secondly, our use of the q &rarr; q g branching kernel is roughly equivalent to always following the harder gluon in a g &rarr; g g branching. This could give us a bias towards producing too hard onia. A soft gluon would have little phase space to branch into a heavy-quark pair however, so the bias may not be as big as it would seem at first glance. Thirdly, once the gluon has branched into a quark pair, each quark carries roughly only half of the onium energy. The maximum energy per emitted gluon should then be roughly half the onium energy rather than the full, as it is now. Thereby the energy of radiated gluons is exaggerated, i.e. onia become too soft. So the second and the third points tend to cancel each other. Finally, note that the lower cutoff scale of the shower evolution depends on the onium mass rather than on the quark mass, as it should be. Gluons below the octet-onium scale should only be part of the octet-to-singlet transition. Weak showers The emission of weak gauge bosons is an integrated part of the initial- and final-state radiation, see Weak Showers. The following settings are those specifically related to the final-state weak radiation, while common settings are found in the Weak Showers description. Further variables There are several possibilities you can use to switch on or off selected branching types in the shower, or in other respects simplify the shower. These should normally not be touched. Their main function is for cross-checks."},{"name":"Main:spareParm1","link":"MainProgramSettings.html#anchor34","text":""},{"name":"Main:spareParm3","link":"MainProgramSettings.html#anchor36","text":""},{"name":"Main:spareParm2","link":"MainProgramSettings.html#anchor35","text":""},{"name":"HiggsBSM:ff2A3ff(t:ZZ)","link":"HiggsProcesses.html#anchor50","text":"Scattering f f' &rarr; A^0(A_3^0) f f' via Z^0 Z^0 fusion. Code 1046."},{"name":"HiggsBSM:gg2H1g(l:t)","link":"HiggsProcesses.html#anchor66","text":"Scattering g g &rarr; h^0 g via loop contributions primarily from top. Code 1014."},{"name":"string Info::name()","link":"EventInformation.html#anchor13","text":""},{"name":"bool Settings::isFlag(string key)","link":"SettingsScheme.html#anchor17","text":""},{"name":"void Particle::bstback(const Vec4AMPERSAND pBst)","link":"ParticleProperties.html#anchor111","text":""},{"name":"void Settings::fvec(string key, vectorAMPERSANDlt;boolAMPERSANDgt; now,  bool force = false)","link":"SettingsScheme.html#anchor61","text":""},{"name":"LesHouches:idRenameBeams","link":"LesHouchesAccord.html#anchor69","text":"PYTHIA only implements a certain number of incoming beam particles. Specifically it needs to have PDFs for every composite particle to be used. Sometimes exotic beam particles are used, e.g. when a neutralino is supposed to be the Dark Matter particle and therefore neutralino pairs can collide and annihilate. Such a particle identity code, picked by this mode, is mapped onto an incoming tau neutrino beam (or antineutrino for the second beam), to bring it to a familiar situation. The trick cannot be used for composite particles, nor for a pair of different particles."},{"name":"StringFlav:mesonBL1S1J0","link":"FlavourSelection.html#anchor27","text":"the relative scalar production ratio (L=1,S=1,J=0) /pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonBL1S1J1","link":"FlavourSelection.html#anchor28","text":"the relative pseudovector production ratio (L=1,S=1,J=1) /pseudoscalar for bottom mesons."},{"name":"int ParticleData::chargeType(int id)","link":"ParticleDataScheme.html#anchor35","text":"three times the charge (to make it an integer), taking into account the sign of id."},{"name":"Bottomonium:gg2doublebbbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor81","text":"Colour-singlet production of 3S1 bottomonium state pairs via g g &rarr; bbbar[3S1(1)] bbbar[3S1(1)]. Code 521."},{"name":"friend Hist operator+(const HistAMPERSANDamp; h1, double f)","link":"Histograms.html#anchor32","text":""},{"name":"HardQCD:gg2bbbar","link":"QCDProcesses.html#anchor19","text":"Scatterings g g &rarr; b bbar. Code 123."},{"name":"ExcitedFermion:cg2cStar","link":"CompositenessProcesses.html#anchor5","text":"Scatterings c g &rarr; c^*. Code 4004."},{"name":"double DecayChannel::openSec(nt idSgn)","link":"ParticleDataScheme.html#anchor192","text":"set or get the fraction of secondary open widths, separately for positive and negative particles. For internal use."},{"name":"Event Analysis","link":"EventAnalysis.html","text":"Event Analysis Introduction The routines in this section are intended to be used to analyze event properties. As such they are not part of the main event generation chain, but can be used in comparisons between Monte Carlo events and real data. They are rather free-standing, but assume that input is provided in the PYTHIA 8 Event format, and use a few basic facilities such as four-vectors. Their ordering is mainly by history; for current LHC applications the final one, SlowJet , is of special interest. In addition to the methods presented here, there is also the possibility to make use of external jet finders. Sphericity The standard sphericity tensor is S^{ab} = (sum_i p_i^a p_i^b) / (sum_i p_i^2) where the sum i runs over the particles in the event, a, b = x, y, z, and p without such an index is the absolute size of the three-momentum. This tensor can be diagonalized to find eigenvalues and eigenvectors. The above tensor can be generalized by introducing a power r , such that S^{ab} = (sum_i p_i^a p_i^b p_i^{r-2}) / (sum_i p_i^r) In particular, r = 1 gives a linear dependence on momenta and thus a collinear safe definition, unlike sphericity. To do sphericity analyses you have to set up a Sphericity instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. After the analysis has been performed, a few methods are available to return the result of the analysis of the latest event: There is also one method that returns information accumulated for all the events analyzed so far. Thrust Thrust is obtained by varying the thrust axis so that the longitudinal momentum component projected onto it is maximized, and thrust itself is then defined as the sum of absolute longitudinal momenta divided by the sum of absolute momenta. The major axis is found correspondingly in the plane transverse to thrust, and the minor one is then defined to be transverse to both. Oblateness is the difference between the major and the minor values. The calculation of thrust is more computer-time-intensive than e.g. linear sphericity, introduced above, and has no specific advantages except historical precedent. In the PYTHIA 6 implementation the search was sped up at the price of then not being guaranteed to hit the absolute maximum. The current implementation studies all possibilities, but at the price of being slower, with time consumption for an event with n particles growing like n^3. To do thrust analyses you have to set up a Thrust instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. After the analysis has been performed, a few methods are available to return the result of the analysis of the latest event: There is also one method that returns information accumulated for all the events analyzed so far. ClusterJet ClusterJet (a.k.a. LUCLUS and PYCLUS ) is a clustering algorithm of the type used for analyses of e^+e^- events, see the PYTHIA 6 manual. All visible particles in the events are clustered into jets. A few options are available for some well-known distance measures. Cutoff distances can either be given in terms of a scaled quadratic quantity like y = pT^2/E^2 or an unscaled linear one like pT. Note that we have deliberately chosen not to include the e^+e^- equivalents of the Cambridge/Aachen and anti- kRT algorithms. These tend to be good at clustering the densely populated (in angle) cores of jets, but less successful for the sparsely populated transverse regions, where many jets may come to consist of a single low-momentum particle. In hadron collisions such jets could easily be disregarded, while in e^+e^- annihilation all particles derive back from the hard process. To do jet finding analyses you have to set up a ClusterJet instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. After the analysis has been performed, a few ClusterJet class methods are available to return the result of the analysis: There is also one method that returns information accumulated for all the events analyzed so far. CellJet CellJet (a.k.a. PYCELL ) is a simple cone jet finder in the UA1 spirit, see the PYTHIA 6 manual. It works in an (eta, phi, eT) space, where eta is pseudorapidity, phi azimuthal angle and eT transverse energy. It will draw cones in R = sqrt(Delta-eta^2 + Delta-phi^2) around seed cells. If the total eT inside the cone exceeds the threshold, a jet is formed, and the cells are removed from further analysis. There are no split or merge procedures, so later-found jets may be missing some of the edge regions already used up by previous ones. Not all particles in the event are assigned to jets; leftovers may be viewed as belonging to beam remnants or the underlying event. It is not used by any experimental collaboration, but is closely related to the more recent and better theoretically motivated anti- kT algorithm Cac08. To do jet finding analyses you have to set up a CellJet instance, and then feed in events to it, one at a time. Especially note that, if you want to use the options where energies are smeared in order so emulate detector imperfections, you must hand in an external random number generator, preferably the one residing in the Pythia class. The results for the latest event are available as output from a few methods. After the analysis has been performed, a few CellJet class methods are available to return the result of the analysis: There is also one method that returns information accumulated for all the events analyzed so far. SlowJet SlowJet is a simple program for doing jet finding according to either of the kT , anti- kT , and Cambridge/Aachen algorithms, in a cylindrical coordinate frame. The name is obviously an homage to the FastJet program Cac06, Cac12. That package contains many more algorithms, with many more options, and, above all, is much faster. Therefore SlowJet is not so much intended for massive processing of data or Monte Carlo files as for simple first tests. Nevertheless, within the advertised capabilities of SlowJet , it has been checked to find identically the same jets as FastJet. The time consumption typically is around or below that to generate an LHC pp event in the first place, so is not prohibitive. But the time rises rapidly for large multiplicities, so obviously SlowJet can not be used for tricks like distributing a dense grid of pseudoparticles to be able to define jet areas, like FastJet can, and also not for events with much pileup or other noise. The recent introduction of fjcore , containing the core functionality of FastJet in a very much smaller package, has changed the conditions. It now is possible (even encouraged by the authors) to distribute the two fjcore files as part of the PYTHIA package. Therefore the SlowJet class doubles as a convenient front end to fjcore , managing the conversion back and forth between PYTHIA and FastJet variables. Some applications may still benefit from using the native codes, but the default now is to let SlowJet call on fjcore for the jet finding. The first step is to decide which particles should be included in the analysis, and with what four-momenta. The SlowJet constructor allows to pick a maximum pseudorapidity defined by the extent of the assumed detector, to pick among some standard options of which particles to analyze, and to allow for some standard mass assumptions, like that all charged particles have the pion mass. Obviously this is only a restricted set of possibilities. Full flexibility can be obtained by deriving from the base class SlowJetHook to write your own include method. This will be presented with one final-state particle at a time, and should return true for those particles that should be analyzed. It is also possible to return modified four-momenta and masses, to take into account detector smearing effects or particle identity misassignments, but you must respect E^2 - p^2 = m^2. Alternatively you can modify the event record itself, or a copy of it (if you want to keep the original intact). For instance, only final particles are considered in the analysis, i.e. particles with positive status code, so negative status code should then be assigned to those particles that you do not want to see analyzed. Again four-momenta and masses can be modified, subject to E^2 - p^2 = m^2. The jet reconstructions is then based on sequential recombination with progressive removal, using the E recombination scheme. To be more specific, the algorithm works as follows. Each particle to be analyzed defines an original cluster. It has a well-defined four-momentum and mass at input. From this information the triplet (pT, y, phi) is calculated, i.e. the transverse momentum, rapidity and azimuthal angle of the cluster. Define distance measures of all clusters i to the beam d_iB = pT_i^2p and of all pairs (i,j) relative to each other d_ij = min( pT_i^2p, pT_j^2p) DeltaR_ij^2 / R^2 where DeltaR_ij^2 = (y_i - y_j)^2 + (phi_i - phi_j)^2. The jet algorithm is determined by the user-selected p value, where p = -1 corresponds to the anti- kT one, p = 0 to the Cambridge/Aachen one and p = 1 to the kT one. Also R is chosen by the user, to give an approximate measure of the size of jets. However, note that jets need not have a circular shape in (y, phi) space, so R can not straight off be interpreted as a jet radius. Find the smallest of all d_iB and d_ij. If this is a d_iB then cluster i is removed from the clusters list and instead added to the jets list. Optionally, a pTjetMin requirement is imposed, where only clusters with pT > pTjetMin are added to the jets list. If so, some of the analyzed particles will not be part of any final jet. If instead the smallest measure is a d_ij then the four-momenta of the i and j clusters are added to define a single new cluster. Convert this four-momentum to a new (pT, y, phi) triplet and update the list of d_iB and d_ij. Return to step 3 until no clusters remain. To do jet finding analyses you first have to set up a SlowJet instance, where the arguments of the constructor specifies the details of the subsequent analyses. Thereafter you can feed in events to it, one at a time, and have them analyzed by the analyze method. Information on the resulting jets can be extracted by a few different methods. The minimal procedure only requires one call per event to do the analysis. We will begin by presenting it, and only afterwards some extensions. After the analysis has been performed, a few SlowJet class methods are available to return the result of the analysis: These are the basic methods. For more sophisticated usage it is possible to trace the clustering, one step at a time. It requires the native jet finding code, useFJcore = false in the constructor. If so, the setup method should be used to read in the event and find the initial smallest distance. Each subsequent doStep will then do one cluster joining and find the new smallest distance. You can therefore interrogate which clusters will be joined next before the joining actually is performed. Alternatively you can take several steps in one go, or take steps down to a predetermined number of jets plus remaining clusters. With this extension, the methods double pT(int i) , double y(int i) , double phi(int i) , Vec4 p(int i) , double m(int i) and int multiplicity(int i) can be used as before. Furthermore, list() generalizes Three further methods can be used to check what will happen next. Finally, and separately, the SlowJetHook class can be used for a more smart selection of which particles to include in the analysis. For instance, isolated and/or high- pT muons, electrons and photons should presumably be identified separately at an early stage, and then not clustered to jets. Technically, it works like with User Hooks. That is, PYTHIA contains the base class. You write a derived class. In the main program you create an instance of this class, and hand it in to SlowJet ; in this case already as part of the constructor. The following methods should be defined in your derived class. It is also possible to define further methods of your own. One such could e.g. be called directly in the main program before the analyze method is called, to identify and bookkeep some event properties you may not want to reanalyze for each individual particle."},{"name":"void Settings::addWVec(string key,  vectorAMPERSANDlt;stringAMPERSANDgt; default)","link":"SettingsScheme.html#anchor32","text":"add an entry of the respective kind to the database. The name and default value(s) always has to be supplied, for Mode , Parm , MVec and PVec additionally if lower and/or upper limits are to be imposed and, if so, what those limit are."},{"name":"RHadrons:idGluino","link":"RHadrons.html#anchor3","text":"The gluino identity code. For other scenarios than SUSY this code could be changed to represent another long-lived uncharged colour octet particle, that then would be treated in the same spirit. Could be set to 0 to forbid any gluino R-hadron formation even when the above two criteria, RHadrons:allow and RHadrons:maxWidth , are met."},{"name":"Stat:reset","link":"MainProgramSettings.html#anchor19","text":"Reset the statistics of the above three kinds. The default is that all stored statistics information is unaffected by the pythia.stat() call. Counters are automatically reset in each new pythia.init() call, however, so the only time the reset option makes a difference is if stat() is called several times in a (sub)run."},{"name":"ColourReconnection:lambdaForm","link":"ColourReconnection.html#anchor11","text":"This allows to switch between different options for what lambda -measure to use. The formula shown are how much each end of a dipole or junction contribute to the total lambda -measure. The energies are defined in respectively the dipole or junction rest frame. lambda = ln (1 + sqrt(2) E/m0) lambda = ln (1 + 2 E/m0) lambda = ln (2 E/m0)"},{"name":"int Settings::modeDefault(string key)","link":"SettingsScheme.html#anchor42","text":""},{"name":"double Particle::mMax()","link":"ParticleProperties.html#anchor74","text":"the width of the particle, and the minimum and maximum allowed mass value for particles with a width, according to the data tables."},{"name":"SigmaDiffractive:maxXB","link":"TotalCrossSections.html#anchor14","text":"The above sigma_max for A + B &rarr; X + B in mb."},{"name":"HadScatNewCom","link":"HadronScattering.html#anchor7","text":""},{"name":"bool Pythia8ToHepMC::store_pdf()","link":"HepMCInterface.html#anchor12","text":"for each event store information on the two incoming flavours, their x values and common factorization scale, and the values of the two parton distributions, xf(x,Q)."},{"name":"double Info::sigmaLHEF(int iProcess)","link":"EventInformation.html#anchor120","text":"return the cross section of the iProcess 'th process."},{"name":"NewGaugeBoson:ffbar2R0","link":"NewGaugeBosonProcesses.html#anchor46","text":"Scattering f_1 fbar_2 &rarr; R^0 &rarr; f_3 fbar_4 , where f_1 and fbar_2 are separated by +- one generation and similarly for f_3 and fbar_4. Thus possible final states are e.g. d sbar , u cbar s bbar , c tbar , e- mu+ and mu- tau+. Code 3041."},{"name":"int LHAup::idBeamB()","link":"LesHouchesAccord.html#anchor14","text":""},{"name":"virtual LHAup::~LHAup()","link":"LesHouchesAccord.html#anchor2","text":"the destructor does not need to do anything."},{"name":"ExcitedFermion:qq2dStarq","link":"CompositenessProcesses.html#anchor10","text":"Scatterings q q(bar) &rarr; d^* q(bar). Code 4021."},{"name":"bool ParticleDataEntry::isMeson()","link":"ParticleDataScheme.html#anchor146","text":"true for a meson."},{"name":"void Pythia8ToHepMC::set_free_parton_exception(bool b = true)","link":"HepMCInterface.html#anchor7","text":""},{"name":"Bottomonium:qqbar2bbbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor54","text":"Colour-octet production of 3S1 bottomonium states via q qbar &rarr; bbbar[3S1(8)] g. Code 504."},{"name":"ExtraDimensionsUnpart:ffbar2UZ","link":"ExtraDimensionalProcesses.html#anchor74","text":"Scatterings f fbar &rarr; U Z. Code 5041."},{"name":"bool ParticleData::isHadron(int id)","link":"ParticleDataScheme.html#anchor73","text":"true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"friend double cross3(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor36","text":"the cross-product."},{"name":"Alpgen:file","link":"AlpgenEventInterface.html#anchor1","text":"This option is used to read in ALPGEN format event files. Using this option overrides any previously set beam options inside PYTHIA. The path to the files, not including any file extension, should be provided e.g. for input files input_unw.par and input.unw , the value input should be used."},{"name":"ExtraDimensionsTEV:ffbar2ccbar","link":"ExtraDimensionalProcesses.html#anchor30","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; c cbar , Code 5064."},{"name":"FourthGeneration:VcbPrime","link":"FourthGenerationProcesses.html#anchor17","text":"The V_cb' matrix element in the 4 * 4 CKM matrix."},{"name":"virtual int MyMerging::mergeProcess( EventAMPERSAND process)","link":"MatchingAndMerging.html#anchor7","text":"This function should be the main interface of Pythia to the MM plugin. Pythia will execute this function once the partonic (fixed-order) scattering has been constructed (or read from LHEF). The partonic scattering is transferred via the process argument. The external MM plugin should then, based on the process , implement the matching/merging strategy. It is permissible that this function changes process. In this case, Pythia will continue the event generation with the changed process as starting point. The return value of the function steers how Pythia should proceed after the function execution. The following return values are supported: -1 : Reject the event and exit the generation/processing of the current event 0: Reject the event but continue with the generation/processing of the current event. 1: Keep the event but continue with the generation/processing of the current event. 2: Reject the event but continue with the generation/processing of the   current event. However, re-evaluate resonance decays before any other   event generation step. This option can be necessary if the merging code   removes or changes resonant particles from process. Note that because this function is the main interface between the MM plugin and Pythia, it is necessary to use this function to set up all the information that you might later need (merging weights, particle counters, etc) in this call already."},{"name":"LesHouches:mRecalculate","link":"LesHouchesAccord.html#anchor73","text":"Does not have any effect by default, or more generally when it is negative. If it is positive then all particles with an input mass above this value will have the mass recalculated and reset from the four-momentum, m^2 = E^2 - p^2. This step is prompted by an unforeseen choice made in some programs (like CalcHEP) of storing the nominal mass of a particle species rather than the mass of the current member of that species, a choice that is likely to induce energy-momentum nonconservation when the event is further processed. Obviously such a recalculation is problematic numerically for light particles, so it should only be used for the programs and particles where it is needed. Thus the value ought to be at least 10 GeV, so that only massive particles like W^+- , Z^0 and t are affected. If a particle does not have its mass recalculated, currently instead the energy is recalculated from its three-momntum and mass. This is to avoid spurious mismatches from limited numerical precision in an LHEF."},{"name":"virtual bool MergingHooks::canCutOnRecState()","link":"CKKWLMerging.html#anchor26","text":"In the base class this method returns false. If you redefine it to return true then the method doCutOnRecState(...) will be called for each reclustered state encountered in the generation of all possible histories of the matrix element state."},{"name":"double LHAup::x2()","link":"LesHouchesAccord.html#anchor57","text":"the flavour and x values of the two initiators."},{"name":"ParticleDecays:limitTau0","link":"ParticleDecays.html#anchor1","text":"When on, only particles with tau0 < tau0Max are decayed."},{"name":"virtual int UserHooks::numberVetoMPIStep()","link":"UserHooks.html#anchor21","text":"Returns the number of steps in the MPI evolution that you want to be able to study, right after each new step has been taken and the subcollision has been added to the event record. The number of steps defaults to the first one only, but you are free to pick another value. Note that the hardest interaction of an events counts as the first multiparton interaction. For most hard processes it thus at the first step offers nothing not available with the VetoProcessLevel functionality above. For the minimum-bias and diffractive systems the hardest interaction is not selected at the process level, however, so there a check after the first multiparton interaction offers new functionality. Note that double diffraction is handled as two separate Pomeron-proton collisions, and thus has two sequences of interactions. Also, if you have set up a second hard process then a check is made after these first two, and the first interaction coming from the MPI machinery would have sequence number 3."},{"name":"The Settings Scheme","link":"SettingsScheme.html","text":"The Settings Scheme The Settings class keeps track of all the flags, modes, parameters and words used during the event generation. As such, it serves all the Pythia program elements from one central repository. Accessing it allows the user to modify the generator behaviour. Each Pythia object has a public member settings of the Settings class. Therefore you access the settings methods as pythia.settings.command(argument) , assuming that pythia is an instance of the Pythia class. Further, for the most frequent user tasks, Pythia methods have been defined, so that pythia.command(argument) would work, see further below. The central section on this page is the Operation one. The preceding concepts section is there mainly to introduce the basic structure and the set of properties that can be accessed. The subsequent sections provide a complete listing of the existing public methods, which most users probably will have little interaction with. Concepts We distinguish eight kinds of user-modifiable variables, by the way they have to be stored: Flags are on/off switches, and are stored as bool. Modes corresponds to a finite enumeration of separate options, and are stored as int. Parameters take a continuum of values, and are stored as double. The shorthand notation parm is used in the C++ code and XML tags. Words are simple character strings and are stored as string. No double quotation marks &quot; or braces { } may appear inside a word, and commas , will take a spcial role next so should also be avoided. Normally the input string is expected not to contain any blanks or equal signs, but if it does it must be enclosed in braces { }. Vectors of flags take a variable length, and are stored as vector<bool>. The shorthand notation fvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. Vectors of modes take a variable length, and are stored as vector<int>. The shorthand notation mvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. Vectors of parameters take a variable length and for each element a continuum of values, and are stored as vector<double>. The shorthand notation pvec is used in the C++ code and XML tag. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. Vectors of words take a variable length, and are stored as vector<string>. The shorthand notation wvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. Note the special role played by the braces { } to enclose words or lists that are allowed to contain blanks and equal signs, and of commas , to separate the fields of the list, in analogy with how C++ arrays can be initialized. You should not be using these three characters for any other purposes. Input of a vector can be split across several lines, until a close brace } is found that matches the open brace {. If no such is found the program will abort, so beware. The double quotation mark &quot; is avoided since it is already used for other purposes. Also note that all shorthands have been chosen four letters long. In general, each variable stored in Settings is associated with four kinds of information: The variable name, of the form class:name (or file:name , usually these agree), e.g. TimeShower:pTmin. The class/file part usually identifies the .xml file where the variable is defined, and the part of the program where it is used, but such a connection cannot be strictly upheld, since e.g. the same variable may be used in a few different cases (even if most of them are not). The default value, set in the original declaration, and intended to represent a reasonable choice. The current value, which differs from the default when the user so requests. An allowed range of values, represented by meaningful minimum and maximum values. This has no sense for a flag , an fvec a word or a wvec (and is not used there), is usually rather well-defined for a mode or mvec , but less so for a parm or pvec. Often the allowed range exaggerates the degree of our current knowledge, so as not to restrict too much what the user can do. One may choose not to set the lower or upper limit, in which case the range is open-ended. Normally input values outside the allowed range are changed to the be at nearest limit. For mode s only, a further boolean is stored to tell whether this should be allowed, or whether out-of-range inputs should be forbidden, to the extent that the whole PYTHIA initialization would abort. The latter applies to those modes that have been defined with the modepick label in the xmldoc/*.xml files, and where maximal and minimal values have been specified. Such labels are used to represent a discrete set of options, and so any value outside the allowed range is just plain wrong. Also attempts to change modefix fixed-value mode s lead to aborts. By contrast those defined with mode or modeopen follow the normal rules of being reset to fall into the allowed range, without any warnings. Technically, the Settings class is implemented with the help of eight separate maps, one for each kind of variable, with the variable name used as key. Operation The normal flow of setting values is: When a Pythia object pythia is created, the member pythia.settings is asked to scan the files listed in the Index.xml file in the xmldoc subdirectory. In all of the files scanned, lines beginning with <flag , <mode , <parm , <word , <fvec , <mvec , <pvec or <wvec are identified, and the information on such a line is used to define a new flag, mode, parameter, word, or vector of flags, modes or parameters. To exemplify, consider a line <parm name='TimeShower:pTmin' default='0.5' min='0.1' max='2.0'> which appears in the TimeShower.xml file, and there defines a parameter TimeShower:pTmin with default value 0.5 GeV and allowed variation in the range 0.1 - 2.0 GeV. The min and max values are optional. Important: the values in the .xml files should not be changed, except by the PYTHIA authors. Any changes should be done with the help of the methods described below. Between the creation of the Pythia object and the init call for it, you may use several alternative methods to modify some of the default values. The same variable can be changed several times. If so, it is the last read value that counts. The two special Tune:ee and Tune:pp modes and the Print:quiet flag are expanded to change several settings in one go, but these obey the same ordering rules. a) Inside your main program you can directly set values with pythia.readString(string) where both the variable name and the value are contained inside the character string, separated by blanks and/or a =, e.g. pythia.readString('TimeShower:pTmin = 1.0'); The match of the name to the database is case-insensitive. Names that do not match an existing variable are ignored. A warning is printed, however. Strings beginning with a non-alphanumeric character, like # or !, are assumed to be comments and are not processed at all. Values below the minimum or above the maximum are set at the respective border. In extreme cases, where it is necessary to go outside the allowed range, ' FORCE= ' can replace the normal ' = ' separator to force the requested value, at own responsibility. For bool values, the following notation may be used interchangeably: true = on = yes = ok = 1 , while everything else gives false (including but not limited to false , off , no and 0). b) The Pythia readString(string) method actually does not do changes itself, but sends on the string either to the Settings class or to ParticleData. The former holds if the string begins with a letter, the latter if it begins with a digit. (The exception is if an input list has been begun by an open brace { but no matching close brace } was present; then all subsequent non-empty input is directed to Settings until the close brace is found.) If desired, it is possible to communicate directly with the corresponding Settings method: pythia.settings.readString('TimeShower:pTmin = 1.0'); In this case, changes intended for ParticleData would not be understood. c) Underlying the settings.readString(string) method are the settings-type-sensitive commands in the Settings , that are split by names containing flag , mode , parm or word. Thus, the example now reads pythia.settings.parm('TimeShower:pTmin', 1.0); Such a form could be convenient e.g. if a parameter is calculated at the beginning of the main program, and thus is available as a variable rather than as a character string. Note that Boolean values must here be given as true or false i.e. there is less flexibility than with the previous methods. At the same level, there are several different methods available. These are included in the full description below, but normally the user should have no need for them. d) A simpler and more useful way is to collect all your changes in a separate file, with one line per change, e.g. TimeShower:pTmin = 1.0 Each line is read in as a string and processed with the methods already introduced.  The file can be read by the pythia.readFile(fileName); method (or an istream instead of a fileName ). The file can freely mix commands to the Settings and ParticleData classes, and so is preferable. Lines with settings are handled by calls to the pythia.settings.readString(string) method. A file can make use of two extra features that are not available with the readString(...) method. One is the possibility to provide information for several distinct subruns. The other is the possibility to comment out a section of lines in the file. The first line of the commented section should then begin by /* and the last begin by */. This is reminiscent of the convention used in C++ and other languages, but is not as powerful, in that it is not possible to comment in or out parts of lines. It is only the first two non-blank characters of a line that are checked for a match, and a line beginning with */ is counted as part of the commented section. To avoid mistakes it is best to keep /* and */ on lines of their own, optionally followed by comments, but not by commands. In the pythia.init() call, many of the various other program elements are initialized, making use of the current values in the database. Once initialized, the common Settings database is likely not consulted again by these routines. It is therefore not productive to do further changes in mid-run: at best nothing changes, at worst you may set up inconsistencies. A routine reInit(fileName) is provided, and can be used to zero all the maps and reinitialize them from scratch. Such a call might be useful if several subruns are to be made with widely different parameter sets - normally the maps are only built from scratch once, namely when the Pythia() object is created. A more economical alternative is offered by resetAll() , however, which sets all variables back to their default values. You may at any time obtain a listing of all variables in the database by calling pythia.settings.listAll(); The listing is strictly alphabetical, which at least means that names from the same file are kept together, but otherwise may not be so well-structured: important and unimportant ones will appear mixed. A more relevant alternative is pythia.settings.listChanged(); where you will only get those variables that differ from their defaults. Or you can use pythia.settings.list('string'); where only those variables with names that contain the string (case-insensitive match) are listed. Thus, with a string shower , the shower-related variables would be shown. The method pythia.settings.output(key) can return the value of a variable as a string, convenient for output. In a readString or readFile command, the construction key =? will echo back the variable and its value, using this method. The above listings are in a tabular form that cannot be read back in. Assuming you want to save all changed settings (maybe because you read in changes from several files), you can do that by calling pythia.settings.writeFile(fileName); This file could then directly be read in by readFile(fileName) in a subsequent (identical) run. Some variants of this command are listed below. Methods The complete list of methods and arguments is as follows. Most of the ones of interest to the user have already been mentioned above. Others can be used, but the same functionality is better achieved by higher-level routines. Some are part of the internal machinery, and should not be touched by user. Note that there is no Settings::readFile(...) method. The intention is that you should use Pythia::readFile(...). It parses and decides which individual lines should be sent on to Settings::readString(...)."},{"name":"TimeShower:alphaSvalue","link":"TimelikeShowers.html#anchor6","text":"The alpha_strong value at scale M_Z^2. The default value corresponds to a crude tuning to LEP data, to be improved."},{"name":"string Info::header(string key)","link":"EventInformation.html#anchor130","text":"return the header named key"},{"name":"HardQCD:qg2qqqbarDiff","link":"QCDProcesses.html#anchor31","text":"Scatterings q g &rarr; q q' qbar' and qbar g &rarr; qbar qbar' q' , where q' by default is a light quark ( u, d, s ) (see HardQCD:nQuarkNew above). Code 139."},{"name":"PDF* getPDFPtr(int id, int sequence = 1)","link":"ProgramFlow.html#anchor35","text":"get a pointer to a PDF object. Which PDF is returned depends on the PDF Selection settings. the identity code of the incoming particle. should normally be 1, but 2 can be used for protons to let the PDF selection be determined by the special settings for hard processes ( PDF:useHard etc.)."},{"name":"double Info::pTmaxMPI()","link":"EventInformation.html#anchor79","text":""},{"name":"bool ParticleDataEntry::isLepton()","link":"ParticleDataScheme.html#anchor140","text":"true for a lepton or an antilepton (including neutrinos)."},{"name":"void Particle::bst(double betaX, double betaY, double betaZ)","link":"ParticleProperties.html#anchor107","text":"boost four-momentum and production vertex by this three-vector."},{"name":"PDF:pSetB","link":"PDFSelection.html#anchor3","text":"Parton densities to be used by proton beam B , with the same options available as for PDF:pSet. If this option is set to void then the same PDF set as PDF:pSet is used."},{"name":"TimeShower:QEDshowerByOther","link":"TimelikeShowers.html#anchor38","text":"Allow charged resonances to radiate photons, i.e. branchings q&sim; &rarr; q&sim; gamma ; on/off = true/false. This will also allow the W boson to radiate."},{"name":"SLHA:useDecayTable","link":"SUSYLesHouchesAccord.html#anchor6","text":"Switch to choose whether to read in SLHA DECAY tables or not. If this switch is set to off, PYTHIA will ignore any decay tables found in the SLHA file, and all decay widths will be calculated internally by PYTHIA. If switched on, SLHA decay tables will be read in, and will then supersede PYTHIA's internal calculations, with PYTHIA only computing the decays for particles for which no SLHA decay table is found. (To set a particle stable, you may either omit an SLHA DECAY table for it and then use PYTHIA's internal id:MayDecay switch for that particle, or you may include an SLHA DECAY table for it, with the width set explicitly to zero.)"},{"name":"virtual Vec4 vertexForFSR( ParticleAMPERSAND rad)","link":"UserHooks.html#anchor52","text":"Method to assign production vertex to a particle produced in FSR ( TimeShower ). Should return the production vertex as a Vec4. is (the address of) the radiating particle, i.e. the mother particle. It can be accessed for information going into the calculation of the vertex, and one can even set vertex information of the mother, if it has not been set previously."},{"name":"Bottomonium:O(3S1)[3P0(8)]","link":"OniaProcesses.html#anchor50","text":"The colour-octet long-distance matrix elements <O[3P0(8)]>/m_Q^2 for the 3S1 bottomonium states. The remaining <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Photon:thetaBMax","link":"Photoproduction.html#anchor8","text":"As above but for lepton B."},{"name":"double ParticleData::resWidthRescaleFactor(int id)","link":"ParticleDataScheme.html#anchor86","text":"the factor used to rescale all partial widths in case the total width is being forced to a specific value by the user."},{"name":"HiggsSM:qqbar2Hbbbar","link":"HiggsProcesses.html#anchor18","text":"Scattering q qbar &rarr; H^0 b bbar via an s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 913."},{"name":"POWHEG:QEDveto","link":"POWHEGMerging.html#anchor9","text":"Treatment of non-QCD radiation. Colorless partons are not included in pT calculated from the shower for pTemt>0. Colorless partons ARE included for pTemt>0. Colorless partons ARE included for pTemt>0.   Additionally, if a colorless parton is emitted with pT > pThard in Born-level events, then the entire event is accepted.  This is relevant for all values of pTemt."},{"name":"void ParticleData::list(vectorAMPERSANDlt;intAMPERSANDgt; idList)","link":"ParticleDataScheme.html#anchor18","text":"list particle data for one single particle, with the identity code as input, or for a set of particles, with an input vector of identity codes."},{"name":"SpaceShower:fixedFacScale","link":"SpacelikeShowers.html#anchor35","text":"The fixed factorization scale, in GeV, that would be used in the evaluation of parton densities if the flag above is on."},{"name":"TimeShower:MEcorrections","link":"TimelikeShowers.html#anchor42","text":"Use of matrix element corrections where available; on/off = true/false."},{"name":"void LHAup::setXSec( int i, double xSec)","link":"LesHouchesAccord.html#anchor9","text":"update the xSec value of the i 'th process added with addProcess method (i.e. i runs from 0 through sizeProc() - 1 , see below)."},{"name":"SigmaDiffractive:maxXX","link":"TotalCrossSections.html#anchor16","text":"The above sigma_max for A + B &rarr; X_1 + X_2 in mb."},{"name":"ExtraDimensionsUnpart:LambdaU","link":"ExtraDimensionalProcesses.html#anchor82","text":"Unparticle renormalization scale."},{"name":"int Rndm::pick(const vectorAMPERSANDlt;doubleAMPERSANDgt;AMPERSANDamp; prob)","link":"RandomNumbers.html#anchor10","text":"pick one option among vector of (positive) probabilities."},{"name":"void ParticleData::listChanged(bool changedRes = false)","link":"ParticleDataScheme.html#anchor15","text":""},{"name":"void DecayChannel::onShellWidth(double onShellWidth)","link":"ParticleDataScheme.html#anchor188","text":""},{"name":"void DecayChannel::meMode(int meMode)","link":"ParticleDataScheme.html#anchor175","text":""},{"name":"RHadrons:idSbottom","link":"RHadrons.html#anchor5","text":"The lightest sbottom identity code. For other scenarios than SUSY this code could be changed to represent another long-lived charge -1/3 colour triplet particle, that then would be treated in the same spirit. As above it could be set to 0 to forbid any sbottom R-hadron formation."},{"name":"HadronScatter:afterDecay","link":"HadronScattering.html#anchor16","text":"Perform hadron scattering before or after first round of decays, involving very short-lived particles like the rho. The default is to perform scattering directly after the string fragmentation, before any decays."},{"name":"double ParticleData::m0(int id)","link":"ParticleDataScheme.html#anchor40","text":"the nominal mass m_0 (in GeV)."},{"name":"SUSY:all","link":"SUSYProcesses.html#anchor1","text":"Common switch for production of supersymmetric particles, i.e. particles with R-parity -1."},{"name":"int Particle::iBotCopy()","link":"ParticleProperties.html#anchor92","text":"are used to trace carbon copies of the particle up to its top mother or down to its bottom daughter. If there are no such carbon copies, the index of the particle itself will be returned. A carbon copy is when the 'same' particle appears several times in the event record, but with changed momentum owing to recoil effects."},{"name":"double CoupSM::t3f(int idAbs)","link":"StandardModelParameters.html#anchor32","text":""},{"name":"int Info::codeMPI(int i)","link":"EventInformation.html#anchor90","text":""},{"name":"ExtraDimensionsLED:gg2llbar","link":"ExtraDimensionalProcesses.html#anchor51","text":"Scatterings g g &rarr; (LED G*) &rarr; l l. Code 5029."},{"name":"PhaseSpace:mHatMin","link":"PhaseSpaceCuts.html#anchor1","text":"The minimum invariant mass."},{"name":"bool Pythia::next()","link":"ProgramFlow.html#anchor23","text":"generate the next event. No input parameters are required; all instructions have already been set up in the initialization stage. Note: The method returns false if the event generation fails. The event record is then not consistent and should not be studied. When reading in hard collisions from a Les Houches Event File the problem may be that the end of the file has been reached. This can be checked with the Info::atEndOfFile() method."},{"name":"ExtraDimensionsG*:KKgqL","link":"ExtraDimensionalProcesses.html#anchor21","text":"Coupling between KK-gluon and a left-handed light quark."},{"name":"bool ParticleData::useBreitWigner(int id)","link":"ParticleDataScheme.html#anchor63","text":"tells whether a particle will have a Breit-Wigner mass distribution or not. Is determined by an internal logic based on the particle width and on the value of the ParticleData:modeBreitWigner switch."},{"name":"bool ParticleData::isMeson(int id)","link":"ParticleDataScheme.html#anchor74","text":"true for a meson."},{"name":"void Pythia8ToHepMC::set_store_xsec(bool b = true)","link":"HepMCInterface.html#anchor15","text":""},{"name":"Beams:allowVertexSpread","link":"BeamParameters.html#anchor29","text":"Allow the interaction vertex of the two colliding beams to be smeared. If off, then the vertex is set to be the origin."},{"name":"vector AMPERSANDlt;doubleAMPERSANDgt; JetMatchingMadgraph::getDJR()","link":"JetMatching.html#anchor33","text":"Return a vector of jet clustering scales produced by running the jet algorithm used for jet matching on the event record without resonance decay products and particles that should not be included in the matching. In this vector, clustering scales for combining few jets appear before scales from combining many jets. This function is useful for the kT-MLM scheme, or to have quick access to this information for histogramming and sanity checks."},{"name":"Random:seed","link":"RandomNumberSeed.html#anchor2","text":"The seed to be used, if setSeed is on. A negative value gives the default seed, a value 0 gives a random seed based on the time, and a value between 1 and 900,000,000 a unique different random number sequence."},{"name":"ExtraDimensionsUnpart:qg2Uq","link":"ExtraDimensionalProcesses.html#anchor72","text":"Scatterings q g &rarr; U q. Code 5046."},{"name":"virtual bool UserHooks::doVetoPartonLevelEarly(const  EventAMPERSAND event)","link":"UserHooks.html#anchor13","text":"is very similar to doVetoPartonLevel(...) above, but the veto can be done earlier, as described for canVetoPartonLevelEarly()."},{"name":"void Particle::index()","link":"ParticleProperties.html#anchor90","text":"the index of the particle itself in the event record."},{"name":"ExtraDimensionsG*:KKgqR","link":"ExtraDimensionalProcesses.html#anchor20","text":"Coupling between KK-gluon and a right-handed light quark."},{"name":"void ParticleData::spinType(int id, int spinType)","link":"ParticleDataScheme.html#anchor32","text":""},{"name":"  virtual bool canCutOnRecState()","link":"MatchingAndMerging.html#anchor16","text":""},{"name":"double LHAup::pdf2()","link":"LesHouchesAccord.html#anchor66","text":"where the first one tells whether this optional information has been set for the current event. ( setPdf(...) must be called after the setProcess(...) call of the event for this to work.) Note that the flavour and x values usually but not always agree with those obtained by the same methods without pdf in their names, see explanation in the Event Information description."},{"name":"LeftRightSymmmetry:coupHmumu","link":"LeftRightSymmetryProcesses.html#anchor21","text":"Yukawa coupling for H^-- &rarr; mu- mu-."},{"name":"bool Info::isValence2()","link":"EventInformation.html#anchor37","text":"true if the two hard incoming partons have been picked to belong to the valence piece of the parton-density distribution, else false. Should be interpreted with caution. Information is not set if you switch off parton-level processing."},{"name":"bool SlowJet::doNSteps(int nStep)","link":"EventAnalysis.html#anchor59","text":"calls the doStep() method nStep times, if possible. Will return false if the list of clusters is emptied before then. The stored jet information is still perfectly fine; it is only the number of steps that is wrong. Will also return false if useFJcore = true."},{"name":"LeptoQuark:qg2LQl","link":"LeptoquarkProcesses.html#anchor3","text":"Scatterings q g &rarr; LQ l. Code 3202."},{"name":"ALPGEN Event Interface","link":"AlpgenEventInterface.html","text":"ALPGEN Event Interface This manual page describes the ALPGEN Man03 event interface for PYTHIA8.  While future versions of ALPGEN will be able to write out events in LHEF format, previous versions always output events in an ALPGEN native format (a combination of a '.unw' and a '_unw.par' file). The ALPGEN component of this code contains a reader for this native format (for unweighted events), as well as parameter reading for both ALPGEN native and LHE file formats. The reader was designed to work together with an implementation of the ALPGEN-style parton-jet matching JetMatchingAlpgen described on the Jet Matching page. However, it will also work with a implementation of the Madgraph-style Alw11 parton-jet matching JetMatchingMadgraph also described on the Jet Matching page. A sensible choice of JetMatching parameters is needed when using ALPGEN files with Madgraph-style matching and vice versa. It should be noted that all the functionality described here is provided through external routines, and therefore the presence of these features is dependent on the main program being used. This structure allows for the easy extensibility of the merging scheme. The files of interest are located in the include/Pythia8Plugins/ subdirectory: GeneratorInput.h : provides three classes for the reading of ALPGEN event and parameter files. LHAupAlpgen is an LHAup derived class for reading in ALPGEN native format event files. AlpgenPar is a class for the parsing of ALPGEN parameter files, making the information available through a simple interface. AlpgenHooks is a UserHooks derived class that provides the Alpgen:* options, described below. Further technical details of these classes are given at the end of this manual page. main32.cc, main32.cmnd : a sample main program and card file showing the usage of previous file and an MLM UserHooks class. In combination, it reads in a sample ALPGEN (or Madgraph) event file while performing the MLM merging procedure as implemented in ALPGEN (or as in Madgraph). Some commented-out sets of options are provided in the card file, which can be activated to try different merging setups. main32.unw, main32_unw.par : an ALPGEN format event and parameter file containing 100 W + 3 jet events. It is not feasible to package large event files with the PYTHIA distribution, but this sample is enough to show the different components in action. ALPGEN main options These following options are provided by the AlpgenHooks class, which must be loaded for this functionality to be present ALPGEN event files that have been written out in LHEF format should be read in through the normal LHEF machinery (see Beam Parameters ). Files in ALPGEN's native format, instead, may be processed using the Alpgen:file option below. When using this option, the ALPGEN parameter file is stored in the PYTHIA Info object under the key AlpgenPar , see the 'Header information' section of the Event Information manual page for more details. Processes not implemented by the PYTHIA 6 interface supplied with ALPGEN are also not implemented here. When reading in ALPGEN native event files, some momenta are shifted by the file reader to ensure energy-momentum conservation. The magnitude of these shifts should be small (around the MeV level in the worst case) and warnings will be produced if they are above a set threshold. A large number of warnings may signify unexpected behaviour and should potentially be investigated. It is also known that certain event classes, for example an event with both light and heavy b quarks may give rise to these warnings. The ALPGEN file reader supports the reading of the event and parameter files in gzip format with file extensions '.unw.gz' and '_unw.par.gz' respectively. This requires the use of external libraries, however, and the README file in the main directory contains instructions on how to enable this. All other Alpgen:* options apply to both LHE and native file formats, and include options to guide the MLM merging procedure based on the parameters that are read in with the events file. Class information Some more technical information about the different classes is given below. For clarity, some limited information on certain private methods is provided. LHAupAlpgen This class is derived from the LHAup base class, and uses the standard machinery to pass initialisation and event data to PYTHIA. These standard functions are not documented here. The complete parameter file is stored in the PYTHIA Info object, if given, under the key AlpgenPar. AlpgenPar This class parses an ALPGEN parameter file and makes the information available through a simple interface. The information is stored internally in key/value (string/double) format. All lines prior to: ************** run parameters are ignored, and in the general case, a line e.g. 10  3.00000000000000     ! njets would be stored with key 'njets' and value '3.0'. The following lines are special cases where the line may be split or the key translated: 3! hard process code  0.000  4.700 174.300  80.419  91.188 120.000! mc,mb,mt,mw,mz,mh  912.905 0.0914176  ! Crosssection +- error (pb)  100 29787.4 ! unwtd events, lum (pb-1) Njob= 2 In the first line, the key 'hard process code' is translated to 'hpc'. In the second, the mass values are split and each given an entry in the internal store. In the third, the cross section and cross section error are stored under the keys 'xsecup' and 'xerrup' respectively. Finally, the number of events and luminosity are stored under the keys 'nevent' and 'lum' respectively. In the event that a duplicate key is present, with differing values, the stored value is overwritten and a warning given. AlpgenHooks This UserHooks derived class provides all the Alpgen:* options. It is provided as a UserHooks class such that the code works regardless of whether ALPGEN native or LHE file formats are used. It is declared with virtual inheritance so that it may be combine with other UserHooks classes, see the 'Combining UserHooks' section below."},{"name":"bool Pythia8ToHepMC::convert_gluon_to_0()","link":"HepMCInterface.html#anchor10","text":"the normal gluon identity code 21 is used also when parton density information is stored, unless this optional argument is set true to have gluons represented by a 0. This choice does not affect the normal event record, where a gluon is always 21."},{"name":"int SpaceShower::system()","link":"ImplementNewShowers.html#anchor37","text":"This method is not virtual. If a branching is constructed by the previous routine this tiny method should be able to return the number of the selected subsystem iSysSel where it occurred, so that the spacelike shower can be told which system to update, if necessary. Therefore iSysSel must be set in branch (or already in pTnext )."},{"name":"HadronLevel:Hadronize","link":"MasterSwitches.html#anchor12","text":"Master switch for hadronization; on/off = true/false. Further options are found here."},{"name":"MultipartonInteractions:allowDoubleRescatter","link":"MultipartonInteractions.html#anchor19","text":"Switch to allow rescattering of partons, where both incoming partons have already rescattered; on/off = true/false. Is only used if MultipartonInteractions:allowRescatter is switched on. Warning: currently there is no complete implementation that combines it with shower evolution, so you must use PartonLevel:ISR = off and PartonLevel:FSR = off. If not, a warning will be issued and double rescattering will not be simulated. The rate also comes out to be much lower than for single rescattering, so to first approximation it can be neglected."},{"name":"void RotBstMatrix::toCMframe(const Vec4AMPERSAND p1, const Vec4AMPERSAND p2)","link":"FourVectors.html#anchor82","text":"boost and rotate to the rest frame of p_1 and p_2 , with p_1 along the +z axis."},{"name":"bool Sphericity::analyze( const EventAMPERSAND event)","link":"EventAnalysis.html#anchor2","text":"perform a sphericity analysis, where is an object of the Event class, most likely the pythia.event one. If the routine returns false the analysis failed, e.g. if too few particles are present to analyze."},{"name":"SigmaProcess:factorScale1","link":"CouplingsAndScales.html#anchor11","text":"The Q^2 factorization scale for 2 &rarr; 1 processes. The same options also apply for those 2 &rarr; 2 and 2 &rarr; 3 processes that have been specially marked as proceeding only through an s -channel resonance. the squared invariant mass, i.e. sHat. fix scale set in SigmaProcess:factorFixScale below."},{"name":"SigmaProcess:factorScale2","link":"CouplingsAndScales.html#anchor12","text":"The Q^2 factorization scale for 2 &rarr; 2 processes. the smaller of the squared transverse masses of the two outgoing particles. the geometric mean of the squared transverse masses of the two outgoing particles. the arithmetic mean of the squared transverse masses of the two outgoing particles. Useful for comparisons with PYTHIA 6, where this is the default. squared invariant mass of the system, i.e. sHat. Useful for processes dominated by s -channel exchange. fix scale set in SigmaProcess:factorFixScale below. Use squared invariant momentum transfer -tHat. This is a common choice for lepton-hadron scattering processes. In that case -tHat=Q^2."},{"name":"SigmaProcess:factorScale3","link":"CouplingsAndScales.html#anchor13","text":"The Q^2 factorization scale for 'normal' 2 &rarr; 3 processes, i.e excepting the vector-boson-fusion processes below. the smaller of the squared transverse masses of the three outgoing particles. the geometric mean of the two smallest squared transverse masses of the three outgoing particles. the geometric mean of the squared transverse masses of the three outgoing particles. the arithmetic mean of the squared transverse masses of the three outgoing particles. squared invariant mass of the system, i.e. sHat. fix scale set in SigmaProcess:factorFixScale below."},{"name":"double CoupSM::alphaS2OrdCorr(double scale2)","link":"StandardModelParameters.html#anchor20","text":"a multiplicative correction factor, below unity, that brings the first-order overestimate above into agreement with the full second-order alpha_strong value at the quadratic scale scale2."},{"name":"RHadrons:allow","link":"RHadrons.html#anchor1","text":"Allows the gluino, stop and sbottom to hadronize if their respective widths are below the limit RHadrons:maxWidth."},{"name":"  virtual bool useShowerPlugin()","link":"MatchingAndMerging.html#anchor23","text":""},{"name":"ExtraDimensionsUnpart:gXY","link":"ExtraDimensionalProcesses.html#anchor87","text":"Chiral unparticle couplings, gXY = gLR = gRL. Only relevant for lepton production from spin-1 unparticle exchange. 1 -1 0"},{"name":"ExtraDimensionsUnpart:gXX","link":"ExtraDimensionalProcesses.html#anchor86","text":"Chiral unparticle couplings, gXX = gLL = gRR. Only relevant for lepton production from spin-1 unparticle exchange. 1 -1 0"},{"name":"BeamRemnants:unresolvedHadron","link":"BeamRemnants.html#anchor22","text":"Switch to to force either or both of the beam remnants to collapse to a single hadron, namely the original incoming one. Must only be used when this is physically meaningful, e.g. when a photon can be viewed as emitted from a proton that does not break up in the process. Both hadronic beams are resolved. Beam A is unresolved, beam B resolved. Beam A is resolved, beam B unresolved. Both hadronic beams are unresolved."},{"name":"void LHAup::listEvent()","link":"LesHouchesAccord.html#anchor67","text":"prints the above information for the current event.  In cases where the LHAup object is not available to the user, the Pythia::LHAeventList() method can be used, which is a wrapper for the above."},{"name":"PDF:pHardSet","link":"PDFSelection.html#anchor5","text":"Parton densities to be used by the proton beams of the hard process, with the same options available as for PDF:pSet. If this option is set to void then the same PDF set as PDF:pSet is used."},{"name":"int Event::nextColTag()","link":"EventRecord.html#anchor15","text":"increases the current maximum colour tag by one and returns this new value. This method is used whenever a new colour tag is needed."},{"name":"Zprime:vnumu","link":"NewGaugeBosonProcesses.html#anchor18","text":"vector coupling of nu_mu neutrinos."},{"name":"Vec4AMPERSAND Vec4::operator=(const Vec4AMPERSAND v)","link":"FourVectors.html#anchor3","text":"copies the input four-vector."},{"name":"HiggsBSM:gg2H2ttbar","link":"HiggsProcesses.html#anchor42","text":"Scattering g g &rarr; H^0(H_2^0) t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1028."},{"name":"JetMatching:doFxFx","link":"JetMatching.html#anchor26","text":"If turned on, then FxFx merging with aMC\@NLO inputs is performed. Note that this requires event samples that are specifically generated for this task."},{"name":"ProMC files","link":"ProMCFiles.html","text":"ProMC Files ProMC Che14 is a library for the storage of Monte Carlo event records, or other data, in a very compact binary form. It provides routines for fast input to and output from these compact data files. It uses 'varints' as a way to store and compress an integer using a variable number of bytes, based on Google's platform- and language-neutral Protocol Buffers. Real numbers are converted to integers, e.g. by specifying a smallest unit of energy, momentum and length. Thereby a low-energy particle can be represented by a smaller number of bytes. The current PYTHIA linking and interface is based on ProMC version 1.5; earlier version will not do. Once you have to installed the ProMC library, you should configure PYTHIA with ./configure --with-promc=/path/to/ProMC and recompile the PYTHIA library. As usual more fine-grained options are available to set paths to binaries, libraries and headers separately, if need be. The examples/main46.cc sample program illustrates how to write PYTHIA events onto a ProMC file."},{"name":"HiggsSM:gg2H","link":"HiggsProcesses.html#anchor8","text":"Scattering g g &rarr; H^0 via loop contributions primarily from top. Code 902."},{"name":"int Particle::iTopCopyId(bool simplify = false)","link":"ParticleProperties.html#anchor93","text":""},{"name":"void Hist::null()","link":"Histograms.html#anchor8","text":"reset bin contents, but keep other histogram properties unchanged."},{"name":"JetMatching:coneMatchLight","link":"JetMatching.html#anchor18","text":"The coneMatchLight parameter used when JetMatching:jetMatch = 1."},{"name":"Main:spareFlag3","link":"MainProgramSettings.html#anchor30","text":""},{"name":"string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor123","text":"Return the value of the wgt attribute named key for the n'th wgt in the vector. Setting doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named key does not exist."},{"name":"int ClusterJet::jetAssignment(int i)","link":"EventAnalysis.html#anchor23","text":"gives the index of the jet that the particle i of the event record belongs to,"},{"name":"JetMatching:nPartonsNow","link":"JetMatching.html#anchor27","text":"The number of partons in Born-like events for the current input LHEF. If the current sample e.g. contains pp &rarr; e+e- + 2 partons Born-like configurations, and pp &rarr; e+e- + 3 partons Real-emission-type events, then JetMatching:nPartonsNow = 2 applies."},{"name":"void Settings::resetMVec(string key)","link":"SettingsScheme.html#anchor74","text":""},{"name":"HiggsBSM:ff2H2ff(t:WW)","link":"HiggsProcesses.html#anchor41","text":"Scattering f_1 f_2 &rarr; H^0(H_2^0) f_3 f_4 via W^+ W^- fusion. Code 1027."},{"name":"JetMatching:slowJetPower","link":"JetMatching.html#anchor5","text":"The power to use in the SlowJet algorithm. The anti-k T algorithm. The Cambridge/Aachen algorithm. The k T algorithm."},{"name":"void DecayChannel::product(int i, int product)","link":"ParticleDataScheme.html#anchor179","text":""},{"name":"double Vec4::rap()","link":"FourVectors.html#anchor30","text":""},{"name":"AlpgenPar::AlpgenPar(Info *infoPtrIn = NULL)","link":"AlpgenEventInterface.html#anchor9","text":"The constructor does nothing except for store the PYTHIA Info pointer, if given. This is used for warning/error message printing."},{"name":"double ParticleDataEntry::constituentMass()","link":"ParticleDataScheme.html#anchor135","text":"is the constituent mass for a quark, hardcoded as m_u = m_d = 0.325 , m_s = 0.50 , m_c = 1.60 and m_b = 5.0 GeV, for a diquark the sum of quark constituent masses, and for everything else the same as the ordinary mass."},{"name":"friend Hist operator*(const HistAMPERSANDamp; h1, const Hist h2)","link":"Histograms.html#anchor39","text":"multiply a constant by a histogram or two histograms by each other, bin by bin."},{"name":"SUSY:qq2squarksquark:onlyQCD","link":"SUSYProcesses.html#anchor14","text":"When switched on this flag causes the t - or u -channel neutralino and chargino contributions to be ignored in the calculation of squark pair production cross sections. Intended for reference only. For the most accurate physics simulation, leave this flag in the off position."},{"name":"ExtraDimensionsG*:Ggg","link":"ExtraDimensionalProcesses.html#anchor15","text":"Coupling between graviton and gluon."},{"name":"Top:ffbar2ttbar(s:gmZ)","link":"TopProcesses.html#anchor5","text":"Scatterings f fbar &rarr; t tbar by s -channel exchange of a gamma^*/Z^0 boson. Code 604."},{"name":"Charmonium:states(3S1)1","link":"OniaProcesses.html#anchor40","text":"The first 3S1 charmonium states of the charmonium pairs that can be produced from the following processes. Note that all vectors within this section, either of modes, flags, or parameters, must be the same length as this vector."},{"name":"ParticleData:mcRun","link":"ParticleData.html#anchor6","text":"the c quark MSbar mass at the mass scale itself."},{"name":"SpaceShower:pTmin","link":"SpacelikeShowers.html#anchor16","text":"Lower cutoff in pT , below which no further ISR branchings are allowed. Normally the pT0 above would be used to provide the main regularization of the branching rate for pT &rarr; 0 , in which case pTmin is used  mainly for technical reasons. It is possible, however, to set pT0Ref = 0 and use pTmin to provide a step-function regularization, or to combine them in intermediate approaches. Currently pTmin is taken to be energy-independent."},{"name":"double Particle::pAbs()","link":"ParticleProperties.html#anchor45","text":""},{"name":"double Thrust::tMinor()","link":"EventAnalysis.html#anchor13","text":""},{"name":"double Info::pT2Hat()","link":"EventInformation.html#anchor56","text":"transverse momentum and its square in the rest frame of a 2 &rarr; 2 processes."},{"name":"Vec4 Vec4::operator-()","link":"FourVectors.html#anchor48","text":"return a vector with flipped sign for all components, while leaving the original vector unchanged."},{"name":"double Info::pzB()","link":"EventInformation.html#anchor5","text":"the longitudinal momenta of the two beam particles."},{"name":"double SigmaProcess::tChanFracPow1()","link":"SemiInternalProcesses.html#anchor27","text":""},{"name":"Event:startColTag","link":"EventRecord.html#anchor12","text":"This sets the initial colour tag value used, so that the first one assigned is startColTag + 1 , etc. The Les Houches accord Boo01 suggests this number to be 500, but 100 works equally well."},{"name":"FourthTop:all","link":"FourthGenerationProcesses.html#anchor8","text":"Common switch for the group of t' production. Also includes the process f fbar' &rarr; t' b'bar in section 3 below."},{"name":"TimeShower:nGammaToQuark","link":"TimelikeShowers.html#anchor40","text":"Number of allowed quark flavours in gamma &rarr; q qbar branchings (phase space permitting). A change to 4 would exclude g &rarr; b bbar , etc."},{"name":"HistAMPERSANDamp; Hist::operator/=(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor26","text":"multiplies or divides the current histogram by the contents of the histogram in the argument if sameSize(...) is true, else does nothing."},{"name":"BeamRemnants:primordialKTsoft","link":"BeamRemnants.html#anchor2","text":"The width sigma_soft in the above equation, assigned as a primordial kT to initiators in the soft-interaction limit."},{"name":"MultipartonInteractions:expPow","link":"MultipartonInteractions.html#anchor15","text":"When bProfile = 3 it gives the power of the assumed overlap shape exp(- b^expPow). Default corresponds to a simple exponential drop, which is not too dissimilar from the overlap obtained with the standard double Gaussian parameters. For expPow = 2 we reduce to the simple Gaussian, bProfile = 1 , and for expPow &rarr; infinity to no impact parameter dependence at all, bProfile = 0. For small expPow the program becomes slow and unstable, so the min limit must be respected."},{"name":"PhotonCollision:gmgm2ee","link":"ElectroweakProcesses.html#anchor35","text":"Scattering gamma gamma &rarr; e+ e-. Code 264."},{"name":"ParticleData:mtRun","link":"ParticleData.html#anchor8","text":"the t quark MSbar mass at the mass scale itself."},{"name":"SigmaProcess:factorMultFac","link":"CouplingsAndScales.html#anchor15","text":"The Q^2 factorization scale for 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes is multiplied by this factor relative to the scale described above (except for the options with a fix scale). Should be use sparingly for 2 &rarr; 1 processes."},{"name":"void Vec4::rotbst(const RotBstMatrixAMPERSAND M)","link":"FourVectors.html#anchor72","text":"perform a combined rotation and boost; see below for a description of the RotBstMatrix."},{"name":"Bottomonium:O(3S1)[3S1(8)]","link":"OniaProcesses.html#anchor48","text":"The colour-octet long-distance matrix elements <O[3S1(8)]> for the 3S1 bottomonium states."},{"name":"Check:abortIfVeto","link":"ErrorChecks.html#anchor1","text":"There are a few ways in which an event can be vetoed, the most common being a User Hooks test. Normally this will simply mean that the next parton-level configuration is selected inside the Pythia::next() routine, without any need for a user intervention. With this option switched on, however, Pythia::next() will return false. It is then up to the user to decide what to do next."},{"name":"double Vec4::eT2()","link":"FourVectors.html#anchor24","text":"the (squared) transverse energy, eT = e * sin(theta) = e * pT / pAbs."},{"name":"double Vec4::pPos()","link":"FourVectors.html#anchor28","text":""},{"name":"Bottomonium:qg2bbbar(3PJ)[3PJ(1)]q","link":"OniaProcesses.html#anchor65","text":"Colour-singlet production of 3PJ bottomonium states via q g &rarr; bbbar[3PJ(1)] q. Code 512."},{"name":"double Info::tau()","link":"EventInformation.html#anchor35","text":"rapidity and scaled mass-squared of the hard-process subsystem, as defined by the above x values."},{"name":"HiddenValley:ffbar2nuEvnuEvbar","link":"HiddenValleyProcesses.html#anchor27","text":"Pair production f fbar &rarr; nuEv nuEvbar via intermediate gamma*/Z^*. Code 4932."},{"name":"PartonLevel:FSR","link":"MasterSwitches.html#anchor6","text":"Master switch for final-state radiation; on/off = true/false. Further options are found here. If you leave this switch on, the following two switches allow more detailed control to switch off only parts of the showers."},{"name":"virtual void MyHardProcess::initOnProcess( string process,  ParticleData* particleData)","link":"MatchingAndMerging.html#anchor25","text":"This function can be used to initialize the instance of your HardProcess class. In the internal Pythia implementation, this acts as a wrapper around the next function."},{"name":"void UserHooks::omitResonanceDecays(const EventAMPERSAND process,  bool finalOnly = false)","link":"UserHooks.html#anchor4","text":"is a protected method that you can make use of in your own methods to extract a simplified list of the hard process, where all resonance decay chains are omitted. Intended for the can/doVetoProcessLevel routines. Note that the normal process-level generation does include resonance decays. That is, if a top quark is produced in the hard process, then also decays such as t &rarr; b W+, W+ &rarr; u dbar will be generated and stored in process. The omitResonanceDecays routine will take the input process and copy it to workEvent (see below), minus the resonance decay chains. All particles produced in the hard process, such as the top, will be considered final-state ones, with positive status and no daughters, just as it is before resonances are allowed to decay. (In the PartonLevel routines, these decay chains will initially not be copied from process to event. Instead the combined MPI, ISR and FSR evolution is done with the top above as final particle. Only afterwards will the resonance decay chains be copied over, with kinematics changes reflecting those of the top, and showers in the decays carried out.) For the default finalOnly = false the beam particles and incoming partons are retained, so the event looks like a normal event record up to the point of resonance decays, with a normal history setup. With finalOnly = true only the final-state partons are retained in the list. It therefore becomes similar in functionality to the subEvent method below, with the difference that subEvent counts the decay products of the resonances as the final state, whereas here the resonances themselves are the final state. Since the history has been removed in this option, mother1() and mother2() return 0, while daughter1() and daughter2() both return the index of the same parton in the original event record."},{"name":"Vec4 Particle::p()","link":"ParticleProperties.html#anchor13","text":"the particle four-momentum vector, with components as above."},{"name":"ExtraDimensionsTEV:ffbar2bbbar","link":"ExtraDimensionalProcesses.html#anchor31","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; b bbar , Code 5065."},{"name":"bool SigmaProcess::convertM2()","link":"SemiInternalProcesses.html#anchor16","text":"it is assumed that 2 &rarr; 1 cross sections are encoded as sigmaHat(sHat) , and 2 &rarr; 2 ones as d(sigmaHat)/d(tHat) in the SigmaProcess::sigmaHat() methods. If convertM2() is overloaded to instead return true then the return value is instead assumed to be the squared matrix element |M|^2 , and SigmaProcess::sigmaHatWrap(...) converts to sigmaHat(sHat) or d(sigmaHat)/d(tHat) , respectively. This switch has no effect on 2 &rarr; 3 processes, where |M|^2 is the only allowed input anyway."},{"name":"TimeShower:recoilDeadCone","link":"TimelikeShowers.html#anchor35","text":"For topologies where a gluon recoils against a massive quark (or another massive coloured particle) there are no suitable ME corrections implemented into PYTHIA. When the dipole radiation pattern is split into two ends, with a smooth transition between the two, this means that the  gluon end can radiate into the quark hemisphere as if the quark were massless. The 'dead cone' effect, that radiation collinear with a massive quark is strongly suppressed, thereby is not fully respected. (Unlike  radiation from the quark end itself, where mass effects are included.) With this switch on, a further suppression is therefore introduced for g &rarr; g g branchings, derived as the massive/massless ratio of the eikonal expression for dipole radiation, which kills radiation collinear with the quark. The g &rarr; q qbar branchings currently are not affected; the absence of a soft singularity implies that there is hardly any radiation into the recoiler hemisphere anyway."},{"name":"bool ParticleData::reInit(string startFile,  bool xmlFormat = true)","link":"ParticleDataScheme.html#anchor7","text":"overwrite the existing database by reading from the specified file. Unlike init above this method is not called by the Pythia constructor, but is entirely intended for users who want to replace the existing particle data with their own. the path and name of file to be read. if true read the same kind of XML-style file as used by init , if not use an alternative 'free format' file (i.e. without any XML tags, but with well-defined rules specifying in which order properties are stored)."},{"name":"SpaceShower:phiIntAsym","link":"SpacelikeShowers.html#anchor31","text":"Azimuthal asymmetry induced by interference; on/off = true/false."},{"name":"StringFlav:mesonCL1S1J2","link":"FlavourSelection.html#anchor25","text":"the relative tensor production ratio (L=1,S=1,J=2) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCL1S1J1","link":"FlavourSelection.html#anchor24","text":"the relative pseudovector production ratio (L=1,S=1,J=1) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCL1S1J0","link":"FlavourSelection.html#anchor23","text":"the relative scalar production ratio (L=1,S=1,J=0) /pseudoscalar for charm mesons."},{"name":"TimeShower:QCDshower","link":"TimelikeShowers.html#anchor31","text":"Allow a QCD shower, i.e. branchings q &rarr; q g , g &rarr; g g and g &rarr; q qbar ; on/off = true/false."},{"name":"double LHAup::x1pdf()","link":"LesHouchesAccord.html#anchor62","text":""},{"name":"Higgs:wingsFac","link":"HiggsProcesses.html#anchor4","text":"With Higgs:clipWings on, all Higgs masses which deviate from the nominal one by more than Higgs:wingsFac times the nominal width are forbidden. This is achieved by setting the mMin and mMax values of the Higgs states at initialization. These changes never  allow a wider range than already set by the user, alternatively by the current default values, see warning above."},{"name":"Random:setSeed","link":"RandomNumberSeed.html#anchor1","text":"Indicates whether a user-set seed should be used every time the Pythia::init routine is called. If off, the random number generator is initialized with its default seed at the beginning of the run, and never again. If on, each new Pythia::init call (should several be made in the same run) results in the random number being re-initialized, thereby possibly starting over with the same sequence, if you do not watch out."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Particle::daughterListRecursive()","link":"ParticleProperties.html#anchor97","text":"returns a vector of all the daughter indices of the particle, recursively including all subsequent decay generations. It is based on the daughterList() method, so obeys the rules given there, except that the listing does not necessarily have to be in ascending order. Its primary application is for the decay of a hadron, or of a resonance in the process record. It is less convenient e.g. for the full parton-shower evolution, and should there only be used with caution."},{"name":"virtual bool canSetProductionVertex()","link":"UserHooks.html#anchor50","text":"In the base class this method returns false. If you redefine it to return true, it will enable the methods vertexForMPI(...) , vertexForFSR(...) and vertexForISR(...)."},{"name":"double Info::m4Hat()","link":"EventInformation.html#anchor58","text":"the masses of the two outgoing particles in a 2 &rarr; 2 processes."},{"name":"StringZ:usePetersonB","link":"Fragmentation.html#anchor18","text":"use Peterson for b quarks."},{"name":"StringZ:usePetersonC","link":"Fragmentation.html#anchor17","text":"use Peterson for c quarks."},{"name":"int LHAup::idProcess()","link":"LesHouchesAccord.html#anchor33","text":"process number."},{"name":"virtual bool SpaceShower::isSpacelike( const EventAMPERSAND event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor41","text":"This function should return true if the splitting that produced the particles event[iRad] , event[iRec] and event[iEmt] should be classified as spacelike splittings (i.e. is handled by initial state showers). The identifier name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"SpaceShower:pTmaxFudgeMPI","link":"SpacelikeShowers.html#anchor3","text":"A multiplicative factor f such that pT_max = f * pT_factorization , as above, but here for the non-hardest interactions (when multiparton interactions are allowed)."},{"name":"SigmaTotal:sigmaXX","link":"TotalCrossSections.html#anchor8","text":"Double Diffractive cross section A + B &rarr; X_1 + X_2 in mb."},{"name":"StringZ:usePetersonH","link":"Fragmentation.html#anchor19","text":"use Peterson for hypothetical heavier quarks."},{"name":"bool ParticleData::isResonance(int id)","link":"ParticleDataScheme.html#anchor52","text":"a flag telling whether a particle species are considered as a resonance or not. Here 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the b bbar bound systems in mass, i.e. for W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with m0 above 20 GeV are by default initialized to be considered as resonances."},{"name":"double CoupSM::ef2(int idAbs)","link":"StandardModelParameters.html#anchor35","text":""},{"name":"POWHEG:pThard","link":"POWHEGMerging.html#anchor4","text":"Selection of the pThard scale. For events where there is no radiation, pThard is always set to be the SCALUP value of the LHA/LHEF standard. Set pThard equal to SCALUP. The pT of the POWHEG emission is tested against all other incoming and outgoing partons, with the minimal value chosen. The pT of all final-state partons is tested against all other incoming and outgoing partons, with the minimal value chosen."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; Settings::mvecDefault(string key)","link":"SettingsScheme.html#anchor46","text":""},{"name":"double Vec4::e()","link":"FourVectors.html#anchor15","text":"gets the respective component."},{"name":"void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0)","link":"ParticleProperties.html#anchor122","text":"sets the pointer to the ParticleDataEntry object of the particle, based on its current id code. If the particle belongs to an event there is no need to provide the input argument. As explained above, a valid ParticleDataEntry pointer is needed for the methods that provide information generic to the particle species."},{"name":"void Settings::forceParm(string key, double now)","link":"SettingsScheme.html#anchor66","text":""},{"name":"void ParticleData::mayDecay(int id, bool mayDecay)","link":"ParticleDataScheme.html#anchor53","text":""},{"name":"int ClusterJet::distanceSize()","link":"EventAnalysis.html#anchor25","text":"the number of most recent clustering scales that have been stored for readout with the next method. Normally this would be five, but less if fewer clustering steps occurred."},{"name":"Beams:offsetVertexX","link":"BeamParameters.html#anchor36","text":"The x location of the interaction vertex is centered at this value."},{"name":"Beams:offsetVertexY","link":"BeamParameters.html#anchor37","text":"The y location of the interaction vertex is centered at this value."},{"name":"HadronScatter:scatterMultipleTimes","link":"HadronScattering.html#anchor9","text":"If switched off, each hadron is only allowed to scatter at most once.  By the way that possible scattering pairs are considered in order of  increasing rapidity separation, this introduces a bias towards pairs  with small y separation."},{"name":"virtual void MyMerging::init()","link":"MatchingAndMerging.html#anchor5","text":"A method that is used to initialize your merging class. Pythia will call this function during its initialization and after all pointers to internal classes (e.g. to instances of the Info and ParticleData classes) have been set up."},{"name":"HiggsBSM:ff2H1ff(t:ZZ)","link":"HiggsProcesses.html#anchor30","text":"Scattering f f' &rarr; h^0(H_1^0) f f' via Z^0 Z^0 fusion. Code 1006."},{"name":"bool Particle::isGluon()","link":"ParticleProperties.html#anchor85","text":"true for a gluon."},{"name":"HiggsBSM:qqbar2A3bbbar","link":"HiggsProcesses.html#anchor77","text":"Scattering q qbar &rarr; A^0 b bbar via an s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1053."},{"name":"Merging:doUNLOPSTree","link":"NLOMerging.html#anchor12","text":"This switch will allow the generation of the weight that should be applied to tree-level events in the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSLoop , Merging:doUNLOPSSubt and Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested."},{"name":"bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr)","link":"ProgramFlow.html#anchor18","text":"offers the possibility to provide your own shape of the momentum and space-time spread of the incoming beams. The rules for constructing your own class from the BeamShape base class are described here. pointer to a BeamShape -derived object. This object must be instantiated by you in your program. Note: The method currently always returns true."},{"name":"ExtraDimensionsLED:ffbar2GZ","link":"ExtraDimensionalProcesses.html#anchor46","text":"Scatterings f fbar &rarr; G Z. Code 5024."},{"name":"Diffraction:bProfile","link":"Diffraction.html#anchor28","text":"Choice of impact parameter profile for the incoming hadron beams. no impact parameter dependence at all. a simple Gaussian matter distribution; no free parameters. a double Gaussian matter distribution, with the two free parameters coreRadius and coreFraction. an overlap function, i.e. the convolution of the matter distributions of the two incoming hadrons, of the form exp(- b^expPow) , where expPow is a free parameter."},{"name":"int MergingHooks::nHardOutLeptons()","link":"CKKWLMerging.html#anchor20","text":"Returns the number of outgoing leptons in the hard core process."},{"name":"Bottomonium:qg2bbbar(3S1)[3PJ(8)]q","link":"OniaProcesses.html#anchor59","text":"Colour-octet production of 3S1 bottomonium states via q g &rarr; bbbar[3PJ(8)] q. Code 509."},{"name":"ExcitedFermion:qq2bStarq","link":"CompositenessProcesses.html#anchor14","text":"Scatterings q q(bar) &rarr; b^* q(bar). Code 4025."},{"name":"Alpgen:setNjet","link":"AlpgenEventInterface.html#anchor5","text":"When switched on, the JetMatching:nJet parameter (see below) is set to the incoming njet ALPGEN parameter. Note that any existing value of this parameter is overwritten."},{"name":"void Sphericity::list()","link":"EventAnalysis.html#anchor7","text":"provides a listing of the above information."},{"name":"SecondHard:Charmonium","link":"ASecondHardProcess.html#anchor5","text":"Production of charmonium via colour singlet and colour octet channels."},{"name":"HistAMPERSANDamp; Hist::operator-=(double f)","link":"Histograms.html#anchor28","text":"adds or subtracts each bin content by the common offset f."},{"name":"StringFragmentation:eMaxLeftJunction","link":"Fragmentation.html#anchor44","text":"Retry (up to 10 times) when the first two considered strings in to a junction has a highest remaining energy (in the junction rest frame) above a random energy evenly distributed between eBothLeftJunction and eBothLeftJunction + eMaxLeftJunction (drawn anew for each test)."},{"name":"int Info::photonMode()","link":"EventInformation.html#anchor72","text":"Type of photon process, see Photoproduction for details."},{"name":"JetMatching:doShowerKt","link":"JetMatching.html#anchor21","text":"This switch changes the merging prescription to the shower-kT matching scheme outlined in Alw08. This scheme differs from 'classical' MLM jet matching with respect to when the matching veto is checked. The shower-kT scheme considers already immediately after the first shower emission if an event should be discarded. A detailed comparison of the 'classical' MLM prescription (e.g. Madgraph-style matching with JetMatching:doShowerKt = off ) and the shower-kT scheme are in preparation."},{"name":"double Info::QFac()","link":"EventInformation.html#anchor44","text":""},{"name":"Wprime:vl","link":"NewGaugeBosonProcesses.html#anchor42","text":"vector coupling of leptons."},{"name":"bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr)","link":"ProgramFlow.html#anchor20","text":"offers the possibility to link your own implementation of the calculation of partial resonance widths, to make it a part of the normal process generation machinery, without having to recompile the Pythia library itself.  This allows the decay of new resonances to be handled internally, when combined with new particle data. Note that the decay of normal hadrons cannot be modeled here; this is for New Physics resonances. The rules for constructing your own class from the ResonanceWidths base class are described here. You may call this routine repeatedly, to add as many new resonances as you wish. pointer to a ResonanceWidths -derived object. This object must be instantiated by you in your program. Note: The method currently always returns true."},{"name":"ExtraDimensionsG*:ffbar2G*","link":"ExtraDimensionalProcesses.html#anchor3","text":"Scatterings f fbar &rarr; G^*. Code 5002."},{"name":"virtual Pythia8ToHepMC::~Pythia8ToHepMC()","link":"HepMCInterface.html#anchor2","text":"the constructor and destructor take no arguments."},{"name":"bool Particle::isHadron()","link":"ParticleProperties.html#anchor88","text":"true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"void ResonanceWidths::initConstants()","link":"SemiInternalResonances.html#anchor1","text":"is called once during initialization, and can then be used to set up further parameters specific to this particle species, such as couplings, and perform calculations that need not be repeated for each new event, thereby saving time. This method needs not be implemented."},{"name":"SpaceShower:rapidityOrderMPI","link":"SpacelikeShowers.html#anchor20","text":"Same as the last switch, but this time only emissions in secondary scattering systems from MPIs are forced to be ordered in rapidity. Each MPI is ordered separately from the others."},{"name":"void DecayChannel::openSec(int idSgn, double openSecIn)","link":"ParticleDataScheme.html#anchor191","text":""},{"name":"SigmaTotal:zeroAXB","link":"TotalCrossSections.html#anchor2","text":"several existing tunes do not include CD. An inclusion of a nonvanishing CD cross section directly affects the nondiffractive phenomenology, even if not dramatically, and so this flag is used to forcibly set the CD cross section to vanish in such tunes. You can switch CD back on after the selection of a tune, if you so wish, by resetting SigmaTotal:zeroAXB = off. This option has no effect for the MBR model ( Diffraction:PomFlux = 5 ), where the CD cross section has been included from the onset."},{"name":"Zprime:atauPrime","link":"NewGaugeBosonProcesses.html#anchor36","text":"axial coupling of tau' leptons."},{"name":"HiggsBSM:ffbar2H1W","link":"HiggsProcesses.html#anchor29","text":"Scattering f fbar &rarr; h^0(H_1^0) W^+- via s -channel W^+- exchange. Code 1005."},{"name":"UserHooks::UserHooks()","link":"UserHooks.html#anchor1","text":""},{"name":"friend Vec4 operator+(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor53","text":"add two four-vectors."},{"name":"Tunes","link":"Tunes.html","text":"Tunes Since some physics aspects cannot be derived from first principles, this program contains many parameters that represent a true uncertainty in our understanding of nature. Particularly afflicted are the areas of hadronization and multiparton interactions, which both involve nonperturbative QCD physics. Technically, PYTHIA  parameters can be varied independently of each other, but the physical requirement of a sensible description of a set of data leads to correlations and anticorrelations between the parameters. Hence the need to produce tunes, not of one parameter at a time, but simultaneously for a group of them. A well-known (separate) such example is parton densities, where combined tunes to a wide range of data have been produced, that can then be obtained prepackaged. Given the many PYTHIA parameters to be tuned, it is convenient to divide the task into subtasks. Firstly, if we assume jet universality, hadronization and final-state parton showers should be tuned to e^+e^- annihilation data, notably from LEP1, since this offers the cleanest environment. Secondly, with such parameters fixed, hadron collider data should be studied to pin down multiparton interactions and other further aspects, such as initial-state radiation. Ideally this would be done separately for diffractive and non-diffractive events, although it is not possible to have a clean separation. (Thirdly would come anything else, such as physics with photon beams, which involve further parameters, but that is beyond the current scope.) The first step was taken, with a tune to LEP1 data by Hendrik Hoeth, using the Rivet + Professor framework. Starting with version 8.125 it defined the default values for hadronization parameters and timelike showers. The situation is more complicated for hadronic interactions in general and multiparton interactions in particular, where PYTHIA 8 is more different from PYTHIA 6, and therefore more work is needed. Specifically, it is not possible to 'port' a PYTHIA 6 tune to PYTHIA 8. A first simple tune, appropriately called 'Tune 1', became default starting with version 8.127. It was noted, in particular by Hendrik Hoeth, that this tune had a tension between parameters needed to describe minimum-bias and underlying-event activity. Therefore some further physics features were introduced in the code itself Cor10a , which were made default as of 8.140. This version also included two new tunes, 2C and 2M, based on the CTEQ 6L1 and the MRST LO** PDF sets, respectively. These have been made by hand, as a prequel to complete Professor-style tunings. The very first data to come out of the LHC showed a higher rapidity plateau than predicted for current PYTHIA 6 tunes, also for the lower energies. This may suggest some tension in the data. Two alternatives, 3C and 3M, were produced by a few brute-force changes of 2C and 2M. These were introduced in 8.140, but discontinued in 8.145 in favour of the newer 4C tune, that is based on a more serious study of some early LHC data, see Cor10a. Following the comparative studies in Buc11 , which independently confirmed a reasonable agreement with LHC data, tune 4C was made the default from 8.150. A variant is tune 4Cx, where the Gaussian matter profile has an x -dependent width Cor11. Tune 4C was the basis for many subsequent LHC tunes. Several ATLAS tunes have been included here, obtained with different PDFs and with different emphasis on minimum-bias and underlying-event data ATL12. These typically require LHAPDF to be linked, but this can be avoided in cases where the same PDF set is implemented internally. Also two CMS underlying-event tunes are implemented CMS14. The ATLAS AZ tune ATL14 instead puts emphasis on the pT spectrum of the Z^/gamma^*0 boson. The Monash 2013 tune Ska14 is based on a larger set of LHC distributions. It starts out from a more careful comparison with and tuning to LEP data, and so involves several parameter changes. The PDF used is the NNPDF2.3 QCD+QED LO one with alpha_s(M_Z) = 0.130 , which includes more recent data than used in the previous default, and opens up for processes with incoming photons to the hard process. It is the default starting from 8.200. Recent tunes by the LHC collaborations are based on the Monash 2013 one. This includes the CMS tune MonashStar, or formally CUETP8M1-NNPDF2.3LO (currently unpublished). More significantly, ATLAS has produced and published a whole family for underlying-event tunes based on a major effort, including simultaneous fits of ten parameters ATL14a. This includes four central tunes, with four different PDF sets, and ten variations around the NNPDF2.3 QCD+QED LO central tune, grouped in five pairs of variations up and down. The publication ATL14a should be consulted for further details, like with what additional settings various processes have been generated, which should be respected to reap full benefit of the tunes. Central diffraction is a recent addition to the 'soft QCD' process palette, and is thus not yet included in tunes; indeed its cross section is actively zeroed. You can switch it back on after you have selected your tune, with SigmaTotal:zeroAXB = off. But note that, since the total cross section is assumed unchanged, the nondiffractive cross section is reduced and thus also the MPI machinery affected, even if effects should not be big (for a small central diffractive cross section). Note that comparisons with data also require that other aspects agree, such as that decay chains are stopped at an agreed-on level. For instance, in the ATLAS tunes all particles with a lifetime above 10 mm are considered stable, ParticleDecays:limitTau0 = on , ParticleDecays:tau0Max = 10. We have chosen not to include this as part of the tune settings itself, since the tune as such could still be used with any other choice of stable and unstable particles. Further comparisons have been posted on the MCPLOTS pages. They have been produced with help of the Rivet package Buc10. To simplify comparisons for the user, we propose to collect some of the tunes here, in a prepackaged form. Of course, in all cases it is a matter of setting values for parameters already defined elsewhere, so the tunes offer no new functionality, only a more convenient setup. You should be aware that the evolution of the program will not guarantee complete backwards compatibility between versions. Most obviously this concerns bug fixes. But also for some other major changes, like the introduction of the new diffractive machinery, the default behaviour of old tunes has been changed retroactively. (Which should be fine for diffraction, since previous tunes were not based on data strongly influenced by diffraction.) The setup of the tunes is special, in that the choice of a tune forces the change of several different flags, modes and parameters. Furthermore a design principle has been that it should be possible to start out from a tune and then change a few of its settings. This gives power and flexibility at the expense of requiring a more careful ordering of commands. We therefore here sketch the order in which operations are carried out. The constructor of a Pythia instance will read in all settings, and initialize them with their default values. At the end of this operation, the Tune:ee and Tune:pp modes (see further below) are checked. If either of them are positive the methods Settings::initTuneEE(...) and Settings::initTunePP(...) , respectively, are called to overwrite the whole collection of settings in the relevant tune. Zero (or negative) means that nothing will be done. Since most pp/ppbar tunes have been made in the context of an e^+e^- one, initTunePP(...) usually calls initTuneEE(...) to provide this synchronization. After the Pythia constructor all the relevant values for the default tune(s) have thus been set up. You as a user can now start to overwrite the values at will, using Pythia::readFile(...) to read a configuration file, or a list of Pythia::readString(...) commands, or the lower-level Settings methods. All changes are made in the order in which the commands are encountered during the execution. A given variable can be changed multiple times, but it is the latest change that sets the current value. The two Tune:ee and Tune:pp modes can also be changed in exactly the same way as described for all other settings above. Unique for them, however, is that when one of them is encountered it also initiates a call to the initTuneEE(...) or initTunePP(...) method, respectively. In such cases all settings affected by the e^+e^- or pp/ppbar tune are first reset to the default values (the -1 options) and thereafter the relevant tune is set up. Recall that initTunePP(...) in its turn is allowed to call initTuneEE(...). It is possible to mix commands of type 4 and 5 in any order; it is always the last change that counts. That is, any changes you have made to variables of a tune before a Tune:ee or Tune:pp command are overwritten by it, while variables you set after will overwrite the tune values. Further, the Tune:pp command usually implies an e^+e^- tune as well. Therefore Tune:ee would rarely be used for LHC applications. As a rule, instead, you want to begin with the Tune:pp choice, and thereafter modify only a small part of its settings. Needless to say, the flexibility can lead to unwanted setups if you do not exercise some discipline. It is therefore recommended that you always check the listing obtained with Pythia::settings.listChanged() to confirm that the final set of changes is the intended one."},{"name":"ExtraDimensionsTEV:ffbar2e+e-","link":"ExtraDimensionalProcesses.html#anchor33","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; e+ e- , Code 5071."},{"name":"RotBstMatrixAMPERSAND RotBstMatrix::operator=(const RotBstMatrix4AMPERSAND Min)","link":"FourVectors.html#anchor75","text":"copies the input matrix."},{"name":"int SigmaProcess::id4Mass()","link":"SemiInternalProcesses.html#anchor18","text":""},{"name":"HiggsBSM:qg2A3q","link":"HiggsProcesses.html#anchor75","text":"Scattering q g &rarr; A^0 q. This process gives first-order corrections to the f fbar &rarr; A^0 one above, and should only be used to study  the high- pT tail, while f fbar &rarr; A^0 should be used for inclusive production. Only the dominant c and b contributions are included, and generated separately for technical reasons. Note that another first-order process would be q qbar &rarr; A^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any b at large pT , however, so is less interesting for many applications. Code 1051."},{"name":"int Info::iBMPI(int i)","link":"EventInformation.html#anchor93","text":"are normally zero. However, if the i 'th subprocess is a rescattering, i.e. either or both incoming partons come from the outgoing state of previous scatterings, they give the position in the event record of the outgoing-state parton that rescatters. iAMPI and iBMPI then denote partons coming from the first or second beam, respectively."},{"name":"void Settings::mode(string key, int now,  bool force = false)","link":"SettingsScheme.html#anchor58","text":""},{"name":"double Vec4::phi()","link":"FourVectors.html#anchor26","text":"the azimuthal angle, in the range -pi through pi."},{"name":"RotBstMatrix::RotBstMatrix()","link":"FourVectors.html#anchor73","text":"creates a diagonal unit matrix, i.e. one that leaves a four-vector unchanged."},{"name":"ParticleDataAMPERSAND operator=( const ParticleDataAMPERSAND particleDataIn)","link":"ParticleDataScheme.html#anchor2","text":"copy the database from an existing ParticleData object. Can be useful when running with multiple Pythia instances. Does not include the links to the resonance decay handling set up by initWidths(...)."},{"name":"PDF:PomStrangeSupp","link":"PDFSelection.html#anchor15","text":"the suppression of the s quark density relative to that of the d and u ones for option 1 above."},{"name":"int LHAup::id(int i)","link":"LesHouchesAccord.html#anchor39","text":""},{"name":"virtual int getNumberOfClusteringSteps(const  EventAMPERSAND event, bool resetNjetMax = false)","link":"MatchingAndMerging.html#anchor22","text":""},{"name":"ExtraDimensionsLED:opMode","link":"ExtraDimensionalProcesses.html#anchor69","text":"Options to specify S function for LED dijet amplitudes. Use detailed amplitude, as described in Fra11. Use conventional LambdaT parametrization, like the other LED processes."},{"name":"Zprime:au","link":"NewGaugeBosonProcesses.html#anchor7","text":"axial coupling of u quarks."},{"name":"JetMatching:nPhi","link":"JetMatching.html#anchor7","text":"Specific to the CellJet algorithm, the number of bins in phi."},{"name":"void Settings::forcePVec(string key,  vectorAMPERSANDlt;doubleAMPERSANDgt; now)","link":"SettingsScheme.html#anchor68","text":"as above, but do not check lower and upper limits, so that the current value(s) can be put outside the intended borders. Note: these methods have been superseded by the force = true option in the standard methods above. They are kept for backwards compatibility with version 8.223 and earlier but will be removed in a future major release."},{"name":"Sample Main Programs","link":"SampleMainPrograms.html","text":"Sample Main Programs Descriptions of available classes, methods and settings are all very good and useful. Ultimately they are necessary for you to be able to fine-tune your runs to the task at hand. To get going, however, nothing helps like having explicit examples to study. This is what is provided in the examples subdirectory, along with instructions how they should be run: main00.cc : does not exist, but it has been defined in the Makefile , so this name could be used for a simple first test run. main01.cc : a simple study of the charged multiplicity for jet events at the LHC. (Brief example fitting on one slide.) main01.py : a Python interface equivalent of main01.cc. main02.cc : a simple study of the pT spectrum of Z bosons at the Tevatron. (Brief example fitting on one slide.) main03.cc : a simple study of several different kinds of events, with the choice to be made in the main03.cmnd 'cards file'. main04.cc : tests of cross sections, multiplicities and average transverse momenta for elastic, diffractive and nondiffractive topologies, using main04.cmnd to pick processes. main05.cc : generation of QCD jet events at the LHC, with jet analysis using the SlowJet inclusive anti- kT sequential-recombination finder and the CellJet cone-jet finder. main06.cc : generation of LEP1 hadronic events, i.e. e^+e^- &rarr; gamma*/Z^0 &rarr; q qbar , with charged multiplicity, sphericity, thrust and jet analysis. main07.cc : set up a fictitious production process to a generic resonance, where you easily can compose your own list of (two-body) decay modes to a variety of final states. Also traces decay chains down to truly stable particles: gamma, e+-, p/pbar and neutrinos. Suitable for astroparticle applications, like neutralino pair annihilation, where cross sections are calculated separately in another program. main08.cc : generation of the QCD jet cross section biased towards higher pT values, by two different techniques. Firstly, by splitting the run into subruns, each in its own pT bin, and adding the results properly reweighted. Two suboptions, with limits set either in the main program or by subrun specification in the main08.cmnd file. Secondly, by a continuous reweighting with a pT^4 bias in the selection, compensated by a 1/pT^4 event weight. Also inclusion of soft processes is illustrated, with subruns and weighted events. main09.cc : generation of two predetermined hard interactions in each event. main10.cc : illustration how userHooks can be used interact directly with the event-generation process. main10.py : a Python interface equivalent of main10.cc. Provides an example of how to derive PYTHIA classes in Python. main11.cc : a study of top events, fed in from the Les Houches Event File ttbar.lhe , here generated by PYTHIA 6.4. This file currently only contains 100 events so as not to make the distributed PYTHIA package too big, and so serves mainly as a demonstration of the principles involved. main12.cc : a more sophisticated variant of main11.cc , where two Les Houches Event Files ( ttbar.lhe and ttbar2.lhe ) successively are used as input. Also illustrating some other aspects, like the capability to mix in internally generated events. main13.cc : a streamlined version of main12.cc , where two Les Houches Event Files ( ttbar.lhe and ttbar2.lhe ) successively are used as input in main13.cmnd file. main14.cc : a systematic comparison of several cross section values with their corresponding values in PYTHIA 6.4, the latter available as a table in the code. main15.cc : loop over several tries, either to redo B decays only or to redo the complete hadronization chain of an event. Since much of the generation process is only made once this is a way to increase efficiency. main16.cc : put all user analysis code into a class of its own, separate from the main program; provide the 'cards file' name as a command-line argument. Also exemplifies how Higgs mass, width and branching ratios can be set by hand. main17.cc : shows (a) how to use UserHooks to regularize onium cross section for pT &rarr; 0, and (b) how decays could be handled externally. main18.cc : shows how to write an event filter class, where you keep a vector of pointers to the subset of particles you want to study further. The event record itself remains unchanged. main19.cc : use several instances of Pythia, one for signal events and others for a variable number of pileup and 'beam-gas' events, combined into one common event record. Illustrates how new Pythia instances can copy existing settings and particle data. main20.cc : shows how PYTHIA 8 can write a Les Houches Event File, using facilities potentially useful also for other programs to write an LHEF. See also main64.cc. main21.cc : an example how a single particle or various parton-level configurations can be input directly for hadronization, without being tied to the full process-generation machinery, e.g. to study the hadronization of junction topologies. Can also be used for single-resonance decays, with showers. main22.cc : shows how an external resonance can be implemented as a new class derived from a PYTHIA base class, and be used in an external process, both of them handed in for generation as with normal internal classes. main23.cc : shows how an external beam momentum spread and vertex location generator can be implemented as a new class derived from a PYTHIA base class, and then handed in for internal use. Also how to use an external random-number generator and an external parton distribution set. main24.cc : tests of internally implemented cross sections for Supersymmetric particle production, with SUSY spectrum defined in cmssm.spc and settings in main24.cmnd. For illustration, an alternative example spectrum is also available, sps1aWithDecays.spc , which contains a decay table in SLHA format. main25.cc : input RPV-SUSY events from an LHEF file that contains an SLHA spectrum inside its header. The event file, main25.lhe , contains a sample events that illustrate how to arrange color tags in the presence of the color-space epsilon tensors that accompany baryon number violating event topologies. main26.cc : test program for processes in scenarios with large extra dimensions or unparticles. main27.cc : production of Kaluza-Klein gamma/Z states in TeV-sized extra dimensions. main28.cc : production of long-lived R-hadrons, that are forced to decay at a separate vertices and possibly with changed momenta. main29.cc : colour reconnection models studied for top production. Illustrates how to set up the user hooks in include/Pythia8Plugins/ColourReconnectionHooks.h , with several models not found in the standard PYTHIA library. main30.cc : example how to create a tailormade copy of the ordinary event record, here with hard-process history tracing closer to the PYTHIA 6 conventions. main31.cc : exemplifies an improved matching of parton showers to LHEF-style input based on the POWHEG approach. The main31.cmnd allows to switch between several different matching options. It also allows to select input process, in this case either for the POWHEG-hvq program applied to top pair production Cor10 or for QCD 2+3-jet events. The small samples of input events are stored in the powheg-hvq.lhe and powheg-dijets.lhe files, respectively. main32.cc : exemplifies MLM merging, either in the ALPGEN variant or in the Madgraph one, and with input events either from ALPGEN or from Madgraph, with relevant control cards stored in main32.cmnd. See Jet Matching for further details. Traditionally the ALPGEN output is split into one file with events and another with parameters and cross sections (unlike in LHEF). Here a sample of W + 3 jets events is stored in main32.unw and the parameters to go with it in main32_unw.par. Madgraph events are taken from the w+_production_lhc_2.lhe file in this case. main33.cc : demonstrates how to link the POWHEGBOX matrix element programs dynamically, bypassing the need for intermediate LHE files. Two special files are used in this option: include/Pythia8Plugins/LHAPowheg.h contains the LHAup class wrapper used to build the POWHEG plugin libraries, and include/Pythia8Plugins/PowhegProcs.h the simple class that facilitates loading the POWHEG plugins. In addition main33.cmnd contains the commands needed for POWHEGBOX to run the example. main34.cc : demonstrates how Madgraph5_aMC\@NLO can be run 'from within' Pythia, making use of the LHAupMadgraph wrapper/interface of Madgraph5_aMC\@NLO and the Pythia jet matching facilities. main34.py : a Python interface equivalent of main34.cc. Demonstrates usage of a PYTHIA plugin within the Python interface. main35.cc : demonstrates how to generate quarkonia events with the external HelacOnia package interfaced to Pythia, and compare results with the internal implementation. main37.cc : shows how LHEF version 3.0 files can be read and used to fill several histograms of the same property, but with different event weights. main38.cc : an extended version of main37.cc , where additionally it is shown how to extract many different kinds of LHEF version 3.0 information. main41.cc : similar to main01 , except that the event record is output in the HepMC event record format. Requires that HepMC is properly linked. Note that the hepmcout41.dat output file can become quite big; so no example is included in this distribution. main42.cc : a streamlined version for the generation of events that are then stored in HepMC format, without any event analysis. That is, all physics studies will have to be done afterwards. The name of the input 'cards file' (e.g. main42.cmnd ) and output HepMC event file (e.g. hepmcout42.dat ) are to be provided as command-line arguments. Requires that HepMC is properly linked. Note that the HepMC output file can become quite big; so no example is included in this distribution. main43.cc : a further extension of main42.cc , where subruns are used to process several consecutive LHEF, as in main13.cc , with information stored e.g in main43.cmnd. Other comments as for main42.cc. main46.cc : illustrated how the ProMC library can be used to store Pythia events in a compact format. main48.cc : demonstrates how to use the EvtGenDecays class provided by include/Pythia8Plugins/EvtGen.h to perform decays with the EvtGen package. The main48.cc header contains special instructions how to configure PYTHIA for use with EvtGen. main51.cc : a test of the shape of parton densities, as a check prior to using a given PDF set in a generator.  Requires that LHAPDF is properly linked. main52.cc : compares the charged multiplicity distribution, and a few other minimum-bias physics aspects, between default PYTHIA PDF and another one. Requires that LHAPDF is properly linked. main53.cc : tests the possibility to do backwards evolution from an incoming photon at the hard interaction. Requires that you link to a LHAPDF set that includes the photon PDF. main54.cc : compares the internal and LHAPDF implementations of the NNPDF 2.3 QCD+QED sets, for results and for timing. Requires that LHAPDF is properly linked. main55.cc : exemplifies how you can use the internal implementation of interpolation in an lhagrid1 .dat file, without linking LHAPDF6. Also illustrates the topical issue of associated event properties for an intermediate spinless resonance in &gamma; + &gamma; &rarr; &gamma; + &gamma; at 750 GeV. main61.cc : exemplifies the generation of hard diffractive processes. main62.cc : illustrates how a user hook can be made to steer the angular distribution selection in resonance decays. The prime example would be if LHEF input, e.g. from Madgraph, contains undecayed resonances with helicity information. These would then be decayed isotropically by PYTHIA, but this example shows how one could do better. Some input in main62.cmnd. main63.cc : exemplifies how a user hook can be used to enhance the rate of rare emissions in the shower. main64.cc : examplifies how LHEF version 3 events can be written on an external file. main65.cc : exemplifies how a user hook can set space-time vertex information. main69.cc : examplifies how to generate all relevant contributions for charged particle spectra in photon-photon and photon-proton collisions. main71.cc : an example how the FastJet jet finding package can be linked to allow an analysis of the final state, in this case for a study of W + jet production. main72.cc : a comparison of SlowJet and FastJet jet finding, showing that they find the same jets if run under identical conditions, in this case for QCD jets. main73.cc : a comparison of jet properties on the parton and the hadron level, illustrating possibilities for larger control of which particles are used in the jet analyses. main74.cc : exemplifies how to use one of the contributed add-ons to the FastJet package. In this case the modified Mass Drop Tagger is used to improve the mass reconstruction of a boosted hadronically decaying Z^0. main80.cc : do CKKW-L merging with a merging scale defined in kT. Input is provided by the main80.cmnd file and input LHE files. Very basic and pedagogical setup, suitable for tutorials. main81.cc : do CKKW-L merging with a merging scale defined in kT. Input is provided by the main81.cmnd file and the three data files w+_production_lhc_0.lhe , w+_production_lhc_1.lhe and w+_production_lhc_2.lhe. main82.cc : do CKKW-L merging with a user-defined merging scale function. Input is provided by the main82.cmnd file and the three data files w+_production_lhc_0.lhe , w+_production_lhc_1.lhe and w+_production_lhc_2.lhe. main83.cc : as main82.cc but with an additional cut on the lowest multiplicity allowed for the reclustered state. The same input as for main82.cc can be used. main84.cc : do CKKW-L merging with output in such a way that it can be used in subsequent RIVET analyses. Input is provided by the main84.cmnd file and the three data files w+_production_lhc_0.lhe , w+_production_lhc_1.lhe and w+_production_lhc_2.lhe. main85.cc : do CKKW-L merging, with HepMC event output. Input settings are provided by the main85.cmnd file. This example program allows the use of input Les Houches events that are regularised with only very minimal cuts, and on which Pythia itself should enforce the more restrictive merging scale cut. The example program can be used with the input files w_production_tree_0.lhe , w_production_tree_1.lhe and w_production_tree_2.lhe. main86.cc : do unitarised ME+PS (UMEPS) merging, with HepMC event output. Input settings are provided by the main86.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to main85.cc. The example program can be used with the input files w_production_tree_0.lhe , w_production_tree_1.lhe and w_production_tree_2.lhe. The program will produce positively and negatively weighted events. See UMEPS Merging for further details. main87.cc : do NL 3 NLO merging, with inclusive NLO input, and with HepMC event output. Input settings are provided by the main87.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to main85.cc. The example program can be used with the tree-level input files w_production_tree_0.lhe , w_production_tree_1.lhe , w_production_tree_2.lhe and the inclusive POWHEG input files w_production_powheg_0.lhe , w_production_powheg_1.lhe. The program will produce positively and negatively weighted events. See NLO Merging (NL 3 section) for further details. main88.cc : do unitarised NLO+PS (UNLOPS) merging, with inclusive NLO input, and with HepMC event output. Input settings are provided by the main88.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to main85.cc. The example program can be used with the tree-level input files w_production_tree_0.lhe , w_production_tree_1.lhe , w_production_tree_2.lhe and the inclusive POWHEG input files w_production_powheg_0.lhe , w_production_powheg_1.lhe. The program will produce positively and negatively weighted events. See NLO Merging (UNLOPS section) for further details. main89.cc : do matching/merging according to five alternative methods, simply by choosing which .cmnd file to read: main89ckkwl.cmnd for CKKW-L, main89fxfx.cmnd for FxFx, main89mlm.cmnd for MLM, main89umeps.cmnd for UMEPS, and main89unlops.cmnd for UNLOPS. main91.cc : shows how ROOT can be used for histogramming in a program that for the rest is structured like a normal PYTHIA run. main92.cc : shows how PYTHIA events can be stored as ROOT trees."},{"name":"Zprime:as","link":"NewGaugeBosonProcesses.html#anchor13","text":"axial coupling of s quarks."},{"name":"double Info::Q2Fac()","link":"EventInformation.html#anchor45","text":"the Q or Q^2 factorization scale at which the densities were evaluated."},{"name":"ExtraDimensionsLED:qg2DJqg","link":"ExtraDimensionalProcesses.html#anchor55","text":"Scatterings q g &rarr; (LED G*) &rarr; q g and qbar g &rarr; (LED G*) &rarr; qbar g. Code 5032."},{"name":"Zprime:ad","link":"NewGaugeBosonProcesses.html#anchor5","text":"axial coupling of d quarks."},{"name":"ExtraDimensionsTEV:ffbar2tau+tau-","link":"ExtraDimensionalProcesses.html#anchor37","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; tau+ tau- , Code 5075."},{"name":"Alpgen:setHeavyMasses","link":"AlpgenEventInterface.html#anchor3","text":"When switched on, t , Z , W and H masses provided by ALPGEN are set in the PYTHIA particle database."},{"name":"Zprime:ac","link":"NewGaugeBosonProcesses.html#anchor15","text":"axial coupling of c quarks."},{"name":"Zprime:ab","link":"NewGaugeBosonProcesses.html#anchor21","text":"axial coupling of b quarks."},{"name":"double ParticleData::mMax(int id)","link":"ParticleDataScheme.html#anchor46","text":"the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there."},{"name":"HistAMPERSANDamp; Hist::operator+=(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor23","text":""},{"name":"Photon:ProcessType","link":"Photoproduction.html#anchor1","text":"Sets desired contribution for interactions with one or two photons. Mix of relevant contributions below. Resolved-Resolved: Both colliding photons are resolved and the partonic content is given by the PDFs. Hard processes and non-diffractive events can be generated. Resolved-Direct: Photon A is resolved and photon B unresolved, i.e. act as an initiator for the hard process. Hard processes with a parton and a photon in the initial state can be generated. In case of photon-hadron collision this provides the direct contribution when hadron is beam A and photon beam B. Direct-Resolved: As above but now photon A is unresolved and photon B resolved. Direct contribution of photon-hadron when photon beam A. Direct-Direct: Both photons are unresolved. Hard processes with two photon initiators can be generated."},{"name":"void Vec4::p(Vec4 pIn)","link":"FourVectors.html#anchor7","text":"sets all components equal to those of the input four-vector."},{"name":"UncertaintyBands:muSoftCorr","link":"Variations.html#anchor7","text":"This flags tells the shower to apply an O(&alpha;S 2 ) compensation term to the renormalization-scale variations, which reduces their magnitude for soft emissions, as described in Mre16."},{"name":"HiddenValley:qqbar2UvUvbar","link":"HiddenValleyProcesses.html#anchor15","text":"Pair production q qbar &rarr; Uv Uvbar via intermediate gluon. Code 4912."},{"name":"PDF:extrapolate","link":"PDFSelection.html#anchor1","text":"Allow PDF sets to be extrapolated, notably to small x values. This is a global flag that affects all PDF sets used, whenever extrapolation has been implemented. Currently the main use is for LHAPDF5, while LHAPDF6 sets are not affected. Among internal PDFs, all Pomeron sets are affected by this flag, as are the CTEQ6/CT09 proton ones. For the rest some by default extrapolate to small x (GRV 94 L, MRST/MSTW) while others are frozen at the border (CTEQ 5 L, NNPDF). When in doubt, check whether and how the behaviour depends on the choice made for your region of interest. To put the issue in context, parton densities have a guaranteed range of validity in x and Q^2 , and what should be done beyond that range usually is not explained by the authors of PDF sets. Nevertheless these boundaries very often are exceeded, e.g. minimum-bias studies at LHC may sample x values down to 10^-8 , while many PDF sets stop already at 10^-5. The default behaviour is then that the PDF's are frozen at the boundary, i.e. xf(x,Q^2) is fixed at its value at x_min for all values x < x_min , and so on. This is a conservative approach. Alternatively, if you switch on extrapolation, then parametrizations will be extended beyond the boundaries, by some prescription. In some cases this will provide a more realistic answer, in others complete rubbish. Another problem is that some of the PDF-set codes will write a warning message anytime the limits are exceeded, thus swamping your output file. Therefore you should study a set seriously before you run it with this switch on."},{"name":"virtual vectorAMPERSANDlt;stringAMPERSANDgt; TimeShower::getSplittingName( const  EventAMPERSAND event, int iRad, int iEmt, int iRec)","link":"ImplementNewShowers.html#anchor23","text":"This function should return a vector of string identifiers of the splitting producing the particles with indices iRad , iEmt and iRec in the input event. If e.g. iRad is the index of a final state quark and iEmt the index of a final state antiquark, we could imagine returning the string 'fsr:G2QQ' (which is the name of such a branching in PYTHIA's UserHooks facilities). The return value is a vector to allow for multiple string identifiers, e.g. if multiple splittings lead to identical final states."},{"name":"TimeShower:alphaSorder","link":"TimelikeShowers.html#anchor7","text":"Order at which alpha_strong runs, zeroth order, i.e. alpha_strong is kept fixed. first order, which is the normal value. second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"HiggsA3:coup2HchgW","link":"HiggsProcesses.html#anchor107","text":"The A^0(H_3^0) coupling to a H^+- W-+ pair. Is 1 in the MSSM."},{"name":"access","link":"Variations.html#anchor6","text":""},{"name":"SpaceShower:renormMultFac","link":"SpacelikeShowers.html#anchor10","text":"The default pT^2 renormalization scale is multiplied by this prefactor. For QCD this is equivalent to a change of Lambda^2 in the opposite direction, i.e. to a change of alpha_strong(M_Z^2) (except that flavour thresholds remain at fixed scales). Below, when pT^2 + pT_0^2 is used as scale, it is this whole expression that is multiplied by the prefactor."},{"name":"HiddenValley:fragment","link":"HiddenValleyProcesses.html#anchor38","text":"switch on string fragmentation of the HV partonic system. Only relevant for SU(N) scenarios."},{"name":"StringZ:aNonstandardH","link":"Fragmentation.html#anchor13","text":"The a parameter in the nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"TimeShower:QEDshowerByGamma","link":"TimelikeShowers.html#anchor39","text":"Allow photons to branch into lepton or quark pairs, i.e. branchings gamma &rarr; l+ l- and gamma &rarr; q qbar ; on/off = true/false."},{"name":"PartonLevel:Remnants","link":"MasterSwitches.html#anchor10","text":"Master switch for addition of beam remnants; on/off = true/false. Only intended for very special applications, and cannot be used to generate complete events. Specifically, unlike the other switches above, the program will complain and possibly crash unlike you also set HadronLevel:all = off and Check:event = off."},{"name":"StringZ:aNonstandardC","link":"Fragmentation.html#anchor11","text":"The a parameter in the nonstandard Lund ansatz for c quarks."},{"name":"StringZ:aNonstandardB","link":"Fragmentation.html#anchor12","text":"The a parameter in the nonstandard Lund ansatz for b quarks."},{"name":"bool Rndm::rndmEnginePtr( RndmEngine* rndmPtr)","link":"RandomNumbers.html#anchor3","text":"pass in pointer for external random number generation."},{"name":"Onia:forceMassSplit","link":"OniaProcesses.html#anchor1","text":"Force the mass splitting between the colour-singlet states and their corresponding colour-octet state to be Onia:massSplit."},{"name":"double ParticleDataEntry::charge(int id = 1)","link":"ParticleDataScheme.html#anchor107","text":"set or get the particle charge type, i.e. three times the charge, or the charge itself. Only the sign of id is needed to distinguish particle/antiparticle."},{"name":"SusyLesHouches Pythia::slha","link":"ProgramFlow.html#anchor43","text":"parameters and particle data in the context of supersymmetric models, see here for further details."},{"name":"CoupSM Pythia::coupSM","link":"ProgramFlow.html#anchor42","text":"Standard Model couplings and mixing matrices, see here for further details."},{"name":"ExcitedFermion:taugm2tauStar","link":"CompositenessProcesses.html#anchor9","text":"Scatterings tau gamma &rarr; tau^*. Code 4015."},{"name":"int Event::append(int id, int status, int col, int acol,  double px, double py, double pz, double e, double m = 0.,  double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor27","text":""},{"name":"HardQCD:qg2qqqbarSame","link":"QCDProcesses.html#anchor32","text":"Scatterings q g &rarr; q q qbar and qbar g &rarr; qbar qbar q. Code 140."},{"name":"ClusterJet::ClusterJet(string measure = AMPERSANDquot;LundAMPERSANDquot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false)","link":"EventAnalysis.html#anchor18","text":"create a ClusterJet instance, where distance measure, to be provided as a character string (actually, only the first character is necessary) the Lund pT distance, the JADE mass distance, and the Durham kT measure. tells which particles are analyzed, all final-state particles, all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the isVisible() particle method), and only charged final-state particles. masses assumed for the particles used in the analysis all massless, photons are massless while all others are assigned the pi+- mass, and all given their correct masses. perform or not a early preclustering step, where nearby particles are lumped together so as to speed up the subsequent normal clustering. reassign all particles to the nearest jet each time after two jets have been joined."},{"name":"StringZ:bNonstandardH","link":"Fragmentation.html#anchor16","text":"The b parameter in the nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"bool ParticleDataEntry::hasAnti()","link":"ParticleDataScheme.html#anchor98","text":"tell whether a separate antiparticle exists."},{"name":"HiggsBSM:qg2A3q(l:t)","link":"HiggsProcesses.html#anchor79","text":"Scattering q g &rarr; A^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1055."},{"name":"StringZ:bNonstandardB","link":"Fragmentation.html#anchor15","text":"The b parameter in the nonstandard Lund ansatz for b quarks."},{"name":"StringZ:bNonstandardC","link":"Fragmentation.html#anchor14","text":"The b parameter in the nonstandard Lund ansatz for c quarks."},{"name":"StringFlav:decupletSup","link":"FlavourSelection.html#anchor34","text":"the suppression, relative to default SU(6) factors, of decuplet baryon production. Default corresponds to no suppression, while 0 corresponds to no decuplet production at all."},{"name":"bool DecayChannel::hasChanged()","link":"ParticleDataScheme.html#anchor182","text":"used for internal purposes, to know which decay modes have been changed."},{"name":"WeakSingleBoson:ffbar2ffbar(s:gm)","link":"ElectroweakProcesses.html#anchor15","text":"Scattering f fbar &rarr; gamma^* &rarr; f' fbar'. Subset of process 221, but written as a 2 &rarr; 2 process, so that pT can be used as ordering variable, e.g. in multiparton interactions. Hardcoded for the final state being either of the five quark flavours or three lepton ones. Not included in the WeakSingleBoson:all set, but included in the multiparton-interactions framework. Code 223."},{"name":"Beams:sigmaTime","link":"BeamParameters.html#anchor34","text":"The width of a Gaussian distribution of the collision time (in units of mm/c). Note that, if the above space parametrization is viewed as the effect of two incoming beams along the +-z axis, with each beam having a Gaussian spread, then the spread of the time would also become a Gaussian with the same width as the z one (times the velocity of the beams, which we expect is close to unity). For flexibility we have not enforced any such relation, however."},{"name":"void ClusterJet::list()","link":"EventAnalysis.html#anchor24","text":"provides a listing of the reconstructed jets."},{"name":"Zprime:vtau","link":"NewGaugeBosonProcesses.html#anchor24","text":"vector coupling of tau leptons."},{"name":"double Info::QRen()","link":"EventInformation.html#anchor48","text":""},{"name":"int SigmaProcess::id3Mass()","link":"SemiInternalProcesses.html#anchor17","text":""},{"name":"double Info::eCM()","link":"EventInformation.html#anchor10","text":""},{"name":"bool Particle::isParton()","link":"ParticleProperties.html#anchor87","text":"true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"SpaceShower:weakShowerMode","link":"SpacelikeShowers.html#anchor22","text":"Determine which branchings are allowed. both W^+- and Z^0 branchings. only W^+- branchings. only Z^0 branchings."},{"name":"SecondHard:Bottomonium","link":"ASecondHardProcess.html#anchor6","text":"Production of bottomonium via colour singlet and colour octet channels."},{"name":"void Particle::statusPos()","link":"ParticleProperties.html#anchor23","text":""},{"name":"HadScatNew2","link":"HadronScattering.html#anchor5","text":""},{"name":"HadScatNew1","link":"HadronScattering.html#anchor2","text":""},{"name":"LeftRightSymmmetry:gL","link":"LeftRightSymmetryProcesses.html#anchor16","text":"lefthanded coupling g_L = e / sin(theta)."},{"name":"void ParticleData::doForceWidth(int id, bool doForceWidth)","link":"ParticleDataScheme.html#anchor59","text":""},{"name":"Zprime:coup2WW","link":"NewGaugeBosonProcesses.html#anchor28","text":"the coupling Z'^0 &rarr; W^+ W^- is taken to be this number times m_W^2 / m_Z'^2 times the Z^0 &rarr; W^+ W^- coupling. Thus a unit value corresponds to the Z^0 &rarr; W^+ W^- coupling, scaled down by a factor m_W^2 / m_Z'^2 , and gives a Z'^0 partial width into this channel that again increases linearly. If you cancel this behaviour, by letting Zprime:coup2WW be proportional to m_Z'^2 / m_W^2 , you instead obtain a partial width that goes like the fifth power of the Z'^0 mass. These two extremes correspond to the 'extended gauge model' and the 'reference model', respectively, of Alt89. Note that this channel only includes the pure Z' part, while f fbar &rarr; gamma^*/Z^*0 &rarr; W^+ W^- is available as a separate electroweak process. Furthermore, we have left some amount of freedom in the choice of decay angular correlations in this channel, but obviously alternative shapes could be imagined."},{"name":"int Hist::getEntries()","link":"Histograms.html#anchor19","text":"return the number of entries, i.e. the number of time that fill(...) has been called."},{"name":"Main:spareFlag1","link":"MainProgramSettings.html#anchor28","text":""},{"name":"int LHAup::col2(int i)","link":"LesHouchesAccord.html#anchor44","text":""},{"name":"double LHAup::xErrSum()","link":"LesHouchesAccord.html#anchor28","text":"the sum of the cross sections and errors (the latter added quadratically). Note that cross section errors are only meaningful for strategies +-3."},{"name":"  virtual double dampenIfFailCuts( const EventAMPERSAND inEvent )","link":"MatchingAndMerging.html#anchor15","text":""},{"name":"int Event::lastColTag()","link":"EventRecord.html#anchor14","text":"returns the current maximum colour tag."},{"name":"SigmaTotal:setOwn","link":"TotalCrossSections.html#anchor3","text":"Allow a user to set own cross sections by hand; on/off = true/false."},{"name":"LeftRightSymmmetry:gR","link":"LeftRightSymmetryProcesses.html#anchor17","text":"righthanded coupling g_R , assumed the same as g_L."},{"name":"PDF:pHardSetB","link":"PDFSelection.html#anchor6","text":"Parton densities to be used by proton beam B of the hard process, with the same options available as for PDF:pSet. If this option is set to void then the same PDF set as PDF:pHardSet is used."},{"name":"int LHAup::sizeProc()","link":"LesHouchesAccord.html#anchor22","text":"for the number of subprocesses."},{"name":"bool Particle::doExternalDecay()","link":"ParticleProperties.html#anchor80","text":"particles that are decayed by an external program."},{"name":"HiggsSM:qqbar2Httbar","link":"HiggsProcesses.html#anchor15","text":"Scattering q qbar &rarr; H^0 t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 909."},{"name":"int Info::id2pdf()","link":"EventInformation.html#anchor39","text":"the identities of the two partons for which parton density values are defined."},{"name":"void ParticleDataEntry::setDefaults()","link":"ParticleDataScheme.html#anchor94","text":"initialize some particle flags with default values, e.g. whether a particle is a resonance, may decay, or is visible. Is called from the constructors and from setAll."},{"name":"LeftRightSymmmetry:ffbar2WR","link":"LeftRightSymmetryProcesses.html#anchor3","text":"Scatterings f fbar' &rarr; W_R^+. Code 3102."},{"name":"HiddenValley:pTminFSR","link":"HiddenValleyProcesses.html#anchor37","text":"lowest allowed pT of emission. Should be greater than or equal to 1.1 times Lambda , or it will be reset automatically."},{"name":"HadronScatter:hadronSelect","link":"HadronScattering.html#anchor19","text":"Probability that a hadron is soft enough to scatter. (A high- pT hadron presumably being part of a jet, and thus produced away from the high-particle-density region at small transverse dimensions.) P = N exp(-pT^2 / 2 / sigma^2) /  ( (1 - k) exp(-pT^2 / 2 / sigma^2) + k pT0^p / (pT0^2 + pT^2)^(p/2), with sigma = 2 StringPT:sigma and pT0 the same as that used in MultipartonInteractions."},{"name":"Zprime:vnutauPrime","link":"NewGaugeBosonProcesses.html#anchor37","text":"vector coupling of nu_tau' neutrinos."},{"name":"HiggsBSM:gmgm2A3","link":"HiggsProcesses.html#anchor47","text":"Scattering gamma gamma &rarr; A^0(A_3^0) via loop contributions primarily from top and W. Code 1043."},{"name":"bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0)","link":"ProgramFlow.html#anchor21","text":"offers the possibility to link your own parton shower routines as replacements for the default ones. This is much more complicated since the showers are so central and are so interlinked with other parts of the program. Therefore it is also possible to do the replacement in stages, from the more independent to the more intertwined. The rules for constructing your own classes from the TimeShower and SpaceShower base classes are described here. These objects must be instantiated by you in your program. pointer to a TimeShower -derived object for doing timelike shower evolution in resonance decays, e.g. of a Z^0. This is decoupled from beam remnants and parton distributions, and is therefore the simplest kind of shower to write. If you provide a value 0 then the internal shower routine will be used. pointer to a TimeShower -derived object for doing all other timelike shower evolution, which is normally interleaved with multiparton interactions and spacelike showers, introducing both further physics and further technical issues. If you retain the default value 0 then the internal shower routine will be used. You are allowed to use the same pointer as above for the timesDecPtr if the same shower can fulfill both tasks. pointer to a SpaceShower -derived object for doing all spacelike shower evolution, which is normally interleaved with multiparton interactions and timelike showers. If you retain the default value 0 then the internal shower routine will be used. Note: The method currently always returns true."},{"name":"Beams:nSkipLHEFatInit","link":"BeamParameters.html#anchor17","text":"Skip the first nSkip events of the input stream (cf. the LHAup::skipEvent(nSkip) method). Only used when Beams:frameType = 4 or 5."},{"name":"Merging:allowWeakClustering","link":"CKKWLMerging.html#anchor31","text":"Allow clustering of weak bosons, as necessary if a merging of matrix elements with QCD and weak showering is attempted. Currently, only emissions of W-bosons are accounted for. This switch should only be used if weak showering is turned on (see Timelike showers , Spacelike showers and Weak showers for details on weak showering)."},{"name":"POWHEG:pTemt","link":"POWHEGMerging.html#anchor5","text":"Selection of the pTemt scale. It is the pT of the emitted parton with respect to the radiating parton. The pT of the emission is checked against all incoming and outgoing partons, and then pTemt is set to the minimum of these values. The pT of all final-state partons is tested against all other incoming and outgoing partons, with the minimal value chosen. Warning: the choice here can give significant variations in the final distributions, notably in the tail to large pT values."},{"name":"ColourReconnection:m0","link":"ColourReconnection.html#anchor6","text":"This is the variable used in the lambda measure for the string length. See the different choices of lambda measure for exact formulas. This variable is in the new model also used as a cut for forming pseudo particles that are not colour reconnected."},{"name":"  virtual bool doCutOnRecState( const EventAMPERSAND event )","link":"MatchingAndMerging.html#anchor17","text":""},{"name":"HiddenValley:kinMix","link":"HiddenValleyProcesses.html#anchor6","text":"strength of kinetic mixing."},{"name":"PartonLevel:ISR","link":"MasterSwitches.html#anchor5","text":"Master switch for initial-state radiation; on/off = true/false. Further options are found here."},{"name":"ExtraDimensionsLED:ffbar2llbar","link":"ExtraDimensionalProcesses.html#anchor50","text":"Scatterings f fbar &rarr; (LED G*) &rarr; l l , where l is a charged lepton. If the graviton contribution is zero, the results corresponds to the SM contribution, i.e. similar to WeakSingleBoson:ffbar2gmZ. Does not include t-channel amplitude relevant for e^+e^- to e^+e^- and no K-factor is used. Code 5028."},{"name":"LeptoQuark:ql2LQ","link":"LeptoquarkProcesses.html#anchor2","text":"Scatterings q l &rarr; LQ. Code 3201."},{"name":"Zprime:anutauPrime","link":"NewGaugeBosonProcesses.html#anchor38","text":"axial coupling of nu_tau' neutrinos."},{"name":"double Info::getWeightsDetailedValue(string n)","link":"EventInformation.html#anchor122","text":"Return the value of the n'th <wgt> tag in the event."},{"name":"void Info::addCounter(int i, int value = 0)","link":"EventInformation.html#anchor107","text":"increase the above counters by a given amount. Only to be used by you for the unassigned counters 40 - 49. the counter number, see above. increase the counter by this amount; normally the default value is what you want."},{"name":"friend double phi(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2,  const Vec4AMPERSAND v3)","link":"FourVectors.html#anchor42","text":""},{"name":"double Info::pdf1()","link":"EventInformation.html#anchor42","text":""},{"name":"Top:qqbar2ttbar","link":"TopProcesses.html#anchor3","text":"Scatterings q qbar &rarr; t tbar by gluon exchange. Code 602."},{"name":"double ParticleData::mRun(int id, double mH)","link":"ParticleDataScheme.html#anchor66","text":"calculate the running mass of species id when probed at a hard mass scale of mH. Only applied to obtain the running quark masses; for all other particle the normal fixed mass is used."},{"name":"TimeShower:globalRecoilMode","link":"TimelikeShowers.html#anchor22","text":"Choice which splittings are produced with the global recoil approach. Global recoil mode as outlined above, i.e. using global recoils until the number of final state particles exceeds TimeShower:nMaxGlobalRecoil. Global recoil only for the first branching of final state legs that have an ancestor in the hard process, and if the maximal number of branchings generated according to the global recoil scheme (see TimeShower:nMaxGlobalBranch below) has not yet been reached. Global recoil only if the first branching in the whole evolution is a timelike splitting of a parton in an event with Born-like kinematics (i.e.\ an S-event). The impact of global recoils should be minimal in this case. This option is only sensible for interleaved evolution."},{"name":"HiddenValley:doKinMix","link":"HiddenValleyProcesses.html#anchor5","text":"allow kinematic mixing or not."},{"name":"Merging:scaleSeparationFactor","link":"CKKWLMerging.html#anchor35","text":"The factor by which scales should differ to be classified as strongly ordered."},{"name":"ExtraDimensionsG*:Ghh","link":"ExtraDimensionalProcesses.html#anchor19","text":"Coupling between graviton and Higgs bosons."},{"name":"StringPT:enhancedFraction","link":"Fragmentation.html#anchor25","text":"enhancedFraction ,the fraction of string breaks with enhanced width."},{"name":"SLHA:keepSM","link":"SUSYLesHouchesAccord.html#anchor3","text":"Some programs write SLHA output also for SM particles where normally one would not want to have masses and decay modes changed unwittingly. Therefore, by default, known SM particles are ignored in SLHA files. To be more specific, particle data for identity codes in the ranges 1 - 24 and 81 - 999,999 are ignored. Notably this includes Z^0 , W^+- and t. The SM Higgs is modified by the SLHA input, as is other codes in the range 25 - 80 and 1,000,000 -. If you switch off this flag then also SM particles are modified by SLHA input."},{"name":"HiggsA3:coup2H2Z","link":"HiggsProcesses.html#anchor102","text":"The A^0(H_3^0) coupling to a H^0(H_2^0) Z^0 pair. Is sin(beta - alpha) in the MSSM."},{"name":"double Info::mA()","link":"EventInformation.html#anchor8","text":""},{"name":"bool Thrust::analyze( const EventAMPERSAND event)","link":"EventAnalysis.html#anchor10","text":"perform a thrust analysis, where is an object of the Event class, most likely the pythia.event one. If the routine returns false the analysis failed, e.g. if too few particles are present to analyze."},{"name":"const DecayChannelAMPERSAND ParticleDataEntry::channel(int i)","link":"ParticleDataScheme.html#anchor155","text":"gain access to a specified channel in the decay table."},{"name":"Merging:aCollFSR","link":"CKKWLMerging.html#anchor43","text":"Factor with which to multiply the scalar pT of a final state splitting, when choosing the history by the smallest sum of scalar pT. Default value taken from Herwig++ Tul09."},{"name":"Zprime:vmu","link":"NewGaugeBosonProcesses.html#anchor16","text":"vector coupling of mu leptons."},{"name":"PartonLevel:FSRinResonances","link":"MasterSwitches.html#anchor8","text":"Master switch for final-state radiation in any resonance decays subsequent to the hard process itself; on/off = true/false. In addition PartonLevel:FSR must be on for these emissions to occur."},{"name":"Bottomonium:qg2bbbar(3PJ)[3S1(8)]q","link":"OniaProcesses.html#anchor68","text":"Colour-octet production of 3PJ bottomonium states via q g &rarr; bbbar[3S1(8)] q. Code 515."},{"name":"Zp:vq","link":"DarkMatterProcesses.html#anchor2","text":"vector coupling of quarks."},{"name":"MultipartonInteractions:coreFraction","link":"MultipartonInteractions.html#anchor14","text":"When assuming a double Gaussian matter profile, bProfile = 2 , the inner core is assumed to have a fraction coreFraction of the matter content of the hadron."},{"name":"TimeShower:allowBeamRecoil","link":"TimelikeShowers.html#anchor17","text":"If on, the final-state shower is allowed to borrow energy from the beam remnants as described above, thereby changing the mass of the scattering subsystem. If off, the partons in the scattering subsystem are constrained to borrow energy from each other, such that the total four-momentum of the system is preserved. This flag has no effect on resonance decays, where the shower always preserves the resonance mass, cf. the comment above about showers for resonances never being interleaved."},{"name":"Merging:fsrInRecNorm","link":"CKKWLMerging.html#anchor42","text":"Normalisation factor with which to multiply splitting probability for final state splittings with an initial state recoiler."},{"name":"void Event::restorePtrs()","link":"EventRecord.html#anchor31","text":"each particle in the event record has a pointer to the event itself and another to the particle species it belongs to. The latter pointer is automatically set/changed whenever the particle identity is set/changed by one of the normal methods. Of course the pointer values are specific to the memory locations of the current run, and so it has no sense to save them if events are written to file. Should you use some persistency scheme that bypasses the normal methods when the event is read back in, you can use restorePtrs() afterwards to set these pointers appropriately."},{"name":"TimeShower:useFixedFacScale","link":"TimelikeShowers.html#anchor48","text":"Allow the possibility to use a fixed factorization scale, set by the parm below. This option is unphysical and only intended for toy-model and debug studies."},{"name":"Charmonium:gg2ccbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor21","text":"Colour-octet production of 3S1 charmonium states via g g &rarr; ccbar[3PJ(8)] g. Code 408."},{"name":"Bottomonium:O(3DJ)[3P0(8)]","link":"OniaProcesses.html#anchor72","text":"The colour-octet long-distance matrix elements <O[3P0(8)]>/m_Q^2 for the 3DJ bottomonium states. The remaining <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"ColourReconnection:fragmentationTime","link":"ColourReconnection.html#anchor22","text":"This parameter specifies the average fragmentation time of the string, in fm. This is used as an upper limit on the invariant time where strings still exist and thus can collide. The expected fragmentation time is related to the a and b parameters of the Lund string fragmentation function as well as to the string tension. It is therefore not a quite free parameter."},{"name":"Zp:vX","link":"DarkMatterProcesses.html#anchor3","text":"vector coupling of the Dark Matter X particles."},{"name":"SpaceShower:alphaSvalue","link":"SpacelikeShowers.html#anchor6","text":"The alpha_strong value at scale M_Z^2."},{"name":"Standard-Model Parameters","link":"StandardModelParameters.html","text":"Standard-Model Parameters The strong coupling The AlphaStrong class is used to provide a first- or second-order running alpha_strong (or, trivially, a zeroth-order fixed one). Formulae are the standard ones found in Yao06. The second-order expression used, eq. (9.5), may be somewhat different in other approaches (with differences formally of higher order), so do not necessarily expect perfect agreement, especially not at small Q^2 scales. The starting alpha_strong value is defined at the M_Z mass scale. The Lambda values are matched at the c , b and t flavour thresholds, such that alpha_strong is continuous. For second-order matching an approximate iterative method is used. For backwards compatibility, the following global switch determines whether 5- or 6-flavour running will be used above the t threshold: Since we allow alpha_strong to vary separately for hard processes, timelike showers, spacelike showers and  multiparton interactions, all other relevant values are set in each of these classes. The default behaviour is everywhere first-order running. The alpha_strong calculation is initialized by init( value, order, nfmax) , where value is the alpha_strong value at M_Z , order is the order of the running, 0, 1 or 2, and nfmax is the highest number of flavours to include in the running. Thereafter the value can be calculated by alphaS(scale2) , where scale2 is the Q^2 scale in GeV^2. By default the charm, bottom and top threshold-matching mass values are chosen to be 1.5, 4.8 and 171 GeV, respectively. The setThresholds(double mc, double mb, double mt) method can be invoked to select other values. To take effect, this must be done before the AlphaStrong::init() method is called, since this is where the flavour-dependent Lambda_i values are calculated and stored. If in doubt, better call it once again. For applications inside shower programs, a second-order alpha_s value can be obtained as the product of the two functions alphaS1Ord(scale2) and alphaS2OrdCorr(scale2) , where the first gives a simple first-order running (but with the second-order Lambda ) and the second the correction factor, below unity, for the second-order terms. This allows a compact handling of evolution equations. Resummation arguments Cat91 show that a set of universal QCD corrections can be absorbed in coherent parton showers by applying the so-called CMW rescaling of the MSbar value of Lambda_QCD. This can be accomplished via a fourth (optional) boolean argument to init( value, order, nfmax, useCMW) , with default value useCMW = false. When set to true , the translation amounts to an N_F -dependent rescaling of Lambda_QCD , relative to its MSbar value, by a factor 1.661 for NF=3, 1.618 for NF=4, 1.569 for NF=5, and 1.513 for NF=6. When using this option, be aware that the original CMW arguments were derived using two-loop running and that the CMW rescaling may need be taken into account in the context of matrix-element matching. Note also that this option has only been made available for timelike and spacelike showers, not for hard processes. The electromagnetic coupling The AlphaEM class is used to generate a running alpha_em. The input StandardModel:alphaEMmZ value at the M_Z mass is matched to a low-energy behaviour with running starting at the electron mass threshold. The matching is done by fitting an effective running coefficient in the region between the light-quark threshold and the charm/tau threshold. This procedure is approximate, but good enough for our purposes. Since we allow alpha_em to vary separately for hard processes, timelike showers, spacelike showers and  multiparton interactions, the choice between using a fixed or a running alpha_em can be made in each of these classes. The default behaviour is everywhere first-order running. The actual values assumed at zero momentum transfer and at M_Z are only set here, however. The alpha_em calculation is initialized by init(order) , where order is the order of the running, 0 or 1, with -1 a special option to use the fix value provided at M_Z.   Thereafter the value can be calculated by alphaEM(scale2) , where scale2 is the Q^2 scale in GeV^2. The electroweak couplings There are two degrees of freedom that can be set, related to the electroweak mixing angle: The Fermi constant is not much used in the currently coded matrix elements, since it is redundant, but it is available: The quark weak-mixing matrix The absolute values of the Cabibbo-Kobayashi-Maskawa matrix elements are set by the following nine real values taken from Yao06 - currently the CP-violating phase is not taken into account in this parametrization. It is up to the user to pick a consistent unitary set of new values whenever changes are made. The CoupSM class The Pythia class contains a public instance coupSM of the CoupSM class. This class contains one instance each of the AlphaStrong and AlphaEM classes, and additionally stores the weak couplings and the quark mixing matrix mentioned above. This class is used especially in the calculation of cross sections and resonance widths, but could also be used elsewhere. Specifically, as already mentioned, there are separate AlphaStrong and AlphaEM instances for timelike and spacelike showers and for multiparton interactions, while weak couplings and the quark mixing matrix are only stored here. With the exception of the first two methods below, which are for internal use, the subsequent ones could also be used externally."},{"name":"UncertaintyBands:cNSpTmin","link":"Variations.html#anchor3","text":"Variations of non-singular terms will not be performed for branchings occurring below this threshold."},{"name":"SpaceShower::SpaceShower()","link":"ImplementNewShowers.html#anchor27","text":"The constructor does not need to do anything."},{"name":"virtual void TimeShower::list()","link":"ImplementNewShowers.html#anchor19","text":"This method is not at all required. In the current implementation it outputs a list of all the dipole ends, with information on the respective dipole. The routine is not called anywhere in the public code, but has been inserted at various places during the development/debug phase."},{"name":"HiggsBSM:ffbar2H1","link":"HiggsProcesses.html#anchor25","text":"Scattering f fbar &rarr; h^0(H_1^0) , where f sums over available flavours except top. Code 1001."},{"name":"HiggsBSM:ffbar2H2","link":"HiggsProcesses.html#anchor35","text":"Scattering f fbar &rarr; H^0(H_2^0) , where f sums over available flavours except top. Code 1021."},{"name":"double Info::xPomeronB()","link":"EventInformation.html#anchor62","text":"x fractions of momenta carried by the Pomeron in the hard diffractive process."},{"name":"HiddenValley:qqbar2CvCvbar","link":"HiddenValleyProcesses.html#anchor17","text":"Pair production q qbar &rarr; Cv Cvbar via intermediate gluon. Code 4914."},{"name":"ColourReconnection:sameNeighbourColours","link":"ColourReconnection.html#anchor9","text":"In the normal colour reconnection two neighbouring strings are not allowed to have the same colour. Similar two strings originating from a gluon split is not allowed to reconnect. The physics motivation for this is that it would require colour singlet gluons, and therefore for ordinary physics studies this should be turned off. But for testing of extreme scenarios (i.e. 1 colour), this variable needs to be turned on, since it is not possible to have different neighbouring colours."},{"name":"PromptPhoton:all","link":"ElectroweakProcesses.html#anchor1","text":"Common switch for the group of all prompt photon processes, as listed separately in the following."},{"name":"ExtraDimensionsG*:qqbar2KKgluon*","link":"ExtraDimensionalProcesses.html#anchor7","text":"Scatterings q qbar &rarr; g^*/KKgluon^*. Code 5006."},{"name":"MultipartonInteractions:pT0Ref","link":"MultipartonInteractions.html#anchor7","text":"The pT0Ref scale in the above formula. Note: pT0Ref is one of the key parameters in a complete PYTHIA tune. Its value is intimately tied to a number of other choices, such as that of colour flow description, so unfortunately it is difficult to give an independent meaning to pT0Ref."},{"name":"StringFlav:etaPrimeSup","link":"FlavourSelection.html#anchor13","text":"the additional suppression of eta' production, multiplying the normal production probability. Thus 0 means no eta' at all are produced, while 1 means full rate."},{"name":"double Info::phiHat()","link":"EventInformation.html#anchor60","text":"the polar and azimuthal scattering angles in the rest frame of a 2 &rarr; 2 process."},{"name":"bool Particle::isAncestor(int iAncestor)","link":"ParticleProperties.html#anchor99","text":"traces the particle upwards through mother, grandmother, and so on, until either iAncestor is found or the top of the record is reached. Normally one unique mother is required, as is the case e.g. in decay chains or in parton showers, so that e.g. the tracing through a hard scattering would not work. For hadronization, first-rank hadrons are identified with the respective string endpoint quark, which may be useful e.g. for b physics, while higher-rank hadrons give false. Currently also ministrings that collapsed to one single hadron and junction topologies give false."},{"name":"Phase Space Cuts","link":"PhaseSpaceCuts.html","text":"Phase Space Cuts PhaseSpace is base class for all hard-process phase-space generators, either generic 2 &rarr; 1 or 2 &rarr; 2 ones, or specialized ones like for elastic and diffractive scattering. In it, it is possible to constrain the kinematics of most processes. (Exceptions are 'soft physics', i.e. minimum bias, elastic and diffractive processes. The Coulomb singularity for elastic scatterings, if simulated, is handled separately .) These constraints apply in the rest frame of the hard subprocess, and topologies normally would be changed e.g. by subsequent showering activity. The cross section of a process is adjusted to only correspond to the allowed phase space. The more particles in the final state, the more cuts could be applied. Here we have tried to remain with the useful minimum, however. More generic possibilities could be handled by the user hooks facility. Cuts in all processes Cuts in 2 &rarr; 1 processes When a resonance id is produced, the mMin(id) and mMax(id) methods restrict the allowed mass range of this resonance. Therefore the allowed range is chosen to be the overlap of this range and the mHatMin to mHatMax range above. Most resonances by default have no upper mass limit, so effects mainly concern the lower limit. Should there be no overlap between the two ranges then the process will be switched off. Cuts in 2 &rarr; 2 processes For a particle with a Breit-Wigner shape selected, according to the rules above and to the rules of the particle species itself, the mMin(id) and mMax(id) methods restrict the allowed mass range of the particle, just like for the 2 &rarr; 1 processes. Cuts in 2 &rarr; 3 processes There are two main classes of 2 &rarr; 3 processes. One is the processes such as WW/ZZ -fusion Higgs production, i.e. q q &rarr; q q H , where there are no special singularities associated with two partons in the final state being collinear, or even for pT &rarr; 0. For this class, no further cuts have been introduced than those already available for 2 &rarr; 2 processes. Specifically, for now all three are restricted exactly the same way by pTHatMin and pTHatMax. As above, Breit-Wigner mass ranges can be restricted. The other 2 &rarr; 3 event class is QCD processes, such as g g &rarr; g g g. Here the soft and collinear singularities play a major role, and the phase space generation and cuts have been adapted to this. For this class, an alternative set of cuts is used, as outlined in the following. First of all the three outgoing partons are ordered in falling pT , i.e. pT_3 > pT_4 > pT_5 (where the labeling 3, 4, 5 of the outgoing partons is random, i.e. unrelated to the order specified in the process name). The allowed ranges of pT_3 and pT_5 can be specified, but obviously pT_3max >= pT_5max and pT_3min >= pT_5min. The pT_4 is not constrained explicitly, but is constructed from the vector sum of pT_3 and pT_5 , subject to the constraint that it has to lie between the two in magnitude. While the pT cuts take care of singularities collinear with the incoming beams, it is also necessary to handle final-state singularities, when two outgoing partons become collinear. This is done by requiring a minimal separation in R , where R^2 = (Delta eta)^2 + (Delta phi)^2. Finally, a note about efficiency. The QCD 2 &rarr; 3 phase space is not set up to explicitly include mHat as one of the basic variables. Such a cut is only done after a phase space point is already selected, which means that a narrow mass choice will slow down the program appreciably. Also narrow pT_3 and pT_5 bins are likely to give inefficient generation, if it gives rise to significant indirect restrictions on pT_4. Cuts for a second hard process If you use the machinery that allows the generation of a specified second hard process then, by default, the same phase space cuts will be used for it as listed above. Optionally, however, you may use a second set of cuts, as described here. In this context 'first' and 'second' is merely a technical distinction; you are welcome e.g. to pick pT ranges such that the second interaction always has a larger pT than the first. Generation strategy and documentation During the initialization stage a simplified function is found, that is intended to be above the true cross-section behaviour over the whole of phase space. It is chosen to be easily integrable and invertible. That way a trial phase space point can be selected according this simple function, and then be accepted by the ratio of true to the simple function. For a good efficiency the ratio should be close to unity,  yet never above it. This constrains the absolute normalization of the simple function. The initial search may fail to find the phase space point where the true-to-simple ratio is maximal, however. This then can lead to subsequent maximum violations, where the ratio is above unity. Two alternative strategies are implemented to handle such situations, see below. Reweighting of 2 &rarr; 2 processes Events normally come with unit weight, i.e. are distributed across the allowed phase space region according to the appropriate differential cross sections. Sometimes it may be convenient to have an uneven distribution of events. The classical example here is that many cross sections drop off with transverse momentum pT , such that few events are generated at large pT scales. If one wants to plot the pT cross section, and all that comes with it, the statistical error will then degrade with increasing pT where fewer events end up. One solution is to split the full pT range into several separate subranges, where the events of each subsample obtains a different overall normalization. Specifically, if you generate a comparable number of events in each pT bin, such that larger pT bins are oversampled, these bins come with a correspondingly reduced overall weight, that needs to be taken into account when the bins are combined. The other is to have a continuously increasing oversampling of events at larger pT scales, which is compensated by a continuously decreasing weight for the event. Both of these solutions are supported. Specifically, for 2 &rarr; 2 processes, the pTHat scale offers a convenient classification of the event. (Of course, two events starting out from the same pTHat scale will experience different parton shower evolutions, etc., and may therefore look quite different at the end.) The two cuts PhaseSpace:pTHatMin and PhaseSpace:pTHatMax therefore offers a way to slice a pT range into subranges, see e.g. main08.cc. Alternatively the User Hooks machinery offers the possibility for you to define your own reweighting of phase space sampling, with a corresponding event weight, with UserHooks::canBiasSelection and related methods. As a simplified option, we here offer the possibility to bias the 2 &rarr; 2 sampling by a power of pTHat , then with events having a weight the inverse of this. This fast track will only work under a number of strict conditions, implemented to reduce the risk of abuse. (Whereas a UserHooks setup can be more flexible.) Specifically it will work if only high- pT 2 &rarr; 2 processes already implemented in PYTHIA are requested, notably the HardQCD ones. That is, you cannot mix with 2 &rarr; 1 or 2 &rarr; 3 processes, nor with external processes (notably Les Houches input) or SoftQCD ones, and  you cannot use the option to define a second hard process in the same event. Furthermore you have to be careful about the choice of PhaseSpace:pTHatMin , since a pTHat = 0 event would come with an infinite weight."},{"name":"FourthBottom:all","link":"FourthGenerationProcesses.html#anchor1","text":"Common switch for the group of b' production. Also includes the process f fbar' &rarr; t' b'bar in section 3 below."},{"name":"int DecayChannel::onMode()","link":"ParticleDataScheme.html#anchor171","text":"set or get the onMode of a decay channel, 0 if a channel is off, 1 if on, 2 if on for a particle but off for an antiparticle, 3 if on for an antiparticle but off for a particle. If a particle is its own antiparticle then 2 is on and 3 off but, of course, for such particles it is much simpler and safer to use only 1 and 0. The 2 and 3 options can be used e.g. to encode CP violation in B decays, or to let the W 's in a q qbar &rarr; W^+ W^- process decay in different channels."},{"name":"SpaceShower:alphaEMorder","link":"SpacelikeShowers.html#anchor9","text":"The running of alpha_em. first-order running, constrained to agree with StandardModel:alphaEMmZ at the Z^0 mass. zeroth order, i.e. alpha_em is kept fixed at its value at vanishing momentum transfer. zeroth order, i.e. alpha_em is kept fixed, but at StandardModel:alphaEMmZ , i.e. its value at the Z^0 mass."},{"name":"double DecayChannel::onShellWidth()","link":"ParticleDataScheme.html#anchor189","text":"set or get the current partial width of the channel; intended for resonances where the widths are recalculated based on the current resonance mass. For internal use."},{"name":"double Particle::thetaXZ()","link":"ParticleProperties.html#anchor51","text":"angle in the (p_x, p_z) plane, between -pi and +pi , with 0 along the +z axis"},{"name":"Top:qq2tq(t:W)","link":"TopProcesses.html#anchor4","text":"Scatterings q q' &rarr; t q'' by t -channel exchange of a W^+- boson. Code 603."},{"name":"MadGraph5 Processes","link":"MadGraph5Processes.html","text":"MadGraph5 Processes Here we will describe two special ways to make use of MadGraph5 and MadGraph5_aMC\@NLO Alw11,Alw14 inside PYTHIA, either by exporting Madgraph process code or by wrapping the MadGraph5_aMC\@NLO generator as a PYTHIA Les Houches interface. Of course, MadGraph5 can also output files of parton-level events according to the LHEF standard, that can be read in and processed further by PYTHIA 8. This is the most commonly used approach, and requires no further description here. MadGraph5 code inside PYTHIA By far the easiest way to implement new processes into PYTHIA 8 is by using the matrix-element generator MadGraph5. This program has an option to output the results of a matrix-element calculation as a set of PYTHIA 8 C++ classes (plus further auxiliary code), that can then be linked and used as semi-internal processes, meaning they are handled identically with normal internal ones. This way, MadGraph5 can be used to implement processes from any model that can be written in  terms of a Lagrangian. Any 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes can be implemented, the limit being set by the absence of efficient phase space generator algorithms for higher multiplicities in PYTHIA. Features such as s -channel resonances are automatically implemented in the process classes.  Besides the process library and necessary model files, also an example main program is generated for each set of processes, which can be easily modified to perform the desired analyses. In order to create a PYTHIA 8 process library with MadGraph5, first download the MadGraph5 package from https://launchpad.net/madgraph5 , and untar the package. You can then specify the location of your pythia81xx directory in the file input/mg5_configuration.txt : pythia8_path = ./pythia81xx The location can be either relative (to the directory MadGraph5_v_x_x_x/. ) or absolute. For any model that is already implemented in the MadGraph5 package, you can directly use the model. Start the MadGraph5 interface bin/mg5 , and do: import model model_name generate your_process_in_mg5_syntax add process your_next_process_in_mg5_syntax ... output pythia8 [path_to_pythia81xx_directory] For examples of MG5 process syntax, please see http://madgraph.phys.ucl.ac.be/EXAMPLES/example_mg5.html or type help generate. If you specified the path to the pythia81xx directory in the mg5_configuration file, you do not need to enter it in the output command. If your preferred model is found on the FeynRules model wiki page, http://feynrules.irmp.ucl.ac.be/wiki/ModelDatabaseMainPage , download the UFO (Universal FeynRules Output) tar file for the model, untar in the models/ directory, and use as above. If you want to implement a new model which has not yet been implemented, you can do this either using the Mathematica package FeynRules (see http://feynrules.irmp.ucl.ac.be/ ) or directly edit the UFO model files of the most similar model in the models/ directory. The resulting output from the output pythia8 command is: A process directory Processes_modelname with the model information and the files needed for all processes defined for this model, placed in the pythia81xx main directory. The model files are Parameters_modelname.h/cc and HelAmps_modelname.h/cc , and the process files for each process class (with the same mass, spin and color of the initial/final state particles) are called Sigma_modelname_processname.h/cc. The directory also contains a makefile and a model parameter file param_card_modelname.dat. An example main program in the directory examples/ (in the pythia81xx main directory) called main_modelname_N.cc and a corresponding makefile Makefile_modelname_N. This main program links in the process classes in the process directory described above. To run the example main program, just go to the examples/ directory and run make -f Makefile_modelname_N or run launch directly inside the MadGraph5 command line interface. Note that in order for PYTHIA 8 to be able to automatically decay any new particles, it is necessary to specify the branching ratios of the particles in the param_card file, see Ska04,Alw07 for details. For further technical details, please see the MadGraph5 release paper Alw11 and the semi-internal processes page. Currently the standard way of interfacing is to use the LHEF standard with an intermediate event file. The advantage is that then the MadGraph5 phase space generator can be used, which opens up for processes with more than three particles in the final state. The disadvantages are that it is less easy to mix and match with existing PYTHIA processes, and that one needs to regenerate and store large LHEF files for different  kinematics cuts or parameter values. Please cite the MadGraph5 release paper Alw11 if you use MadGraph5 to generate process libraries for PYTHIA 8. MadGraph5_aMC\@NLO executable inside PYTHIA The Pythia::setLHAupPtr(LHAup* lhaUpPtr) method allows a Pythia generator to accept a pointer to an object derived from the LHAup base class. Such an object will be initialized from within Pythia, and be called repeatedly to generate the next parton-level event, using the LHA specification as a standard to transfer the relevant information back to Pythia. Properly constructed, the operation of an LHAup object thus is almost completely hidden from the user, and generates events almost like an ordinary internal Pythia process. The LHAupMadgraph is precisely such a class, derived from LHAup , that contains the code needed to wrap a MadGraph5_aMC\@NLO executable. Thereby the generation of Madgraph processes from within Pythia becomes straightforward. An explicit example is provided in main34.cc. We describe some of the key elements used there and in the general case. Note that GZIP support must be enabled in the Pythia executable, so use the --with-gzip option in the configure step before Pythia compilation. Events are generated with MadGraph utilizing the gridpack method for MadGraph5 and an equivalent method for aMC\@NLO. Consequently the run directory, 'madgraphrun' by default, does not need to be deleted between independent runs with the same configuration (excluding random seeds). Indeed, keeping the directory significantly speeds the generation process, particularly for NLO generation with aMC\@NLO as the grid initialization can be skipped after the initial run."},{"name":"MultipartonInteractions:alphaSorder","link":"MultipartonInteractions.html#anchor3","text":"The order at which alpha_strong runs at scales away from m_Z. zeroth order, i.e. alpha_strong is kept fixed. first order, which is the normal value. second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"double CoupSM::ef(int idAbs)","link":"StandardModelParameters.html#anchor29","text":"the electrical charge of a fermion, by the absolute sign of the PDF code, i.e. idAbs must be in the range between 1 and 18."},{"name":"int Info::getInitrwgtSize()","link":"EventInformation.html#anchor115","text":""},{"name":"HiggsH2:coup2A3A3","link":"HiggsProcesses.html#anchor94","text":"The H^0(H_2^0) coupling to an A^0(H_3^0) pair. Is cos(2 beta) cos(beta + alpha) in the MSSM."},{"name":"void Particle::rescale4(double fac)","link":"ParticleProperties.html#anchor104","text":"multiply the four-momentum components by fac."},{"name":"FourthTop:qqbar2tPrimetPrimebar","link":"FourthGenerationProcesses.html#anchor10","text":"Scatterings q qbar &rarr; t' t'bar by gluon exchange. Code 822."},{"name":"Pythia::~Pythia","link":"ProgramFlow.html#anchor4","text":"the destructor deletes the objects created by the constructor."},{"name":"SpaceShower:MEafterFirst","link":"SpacelikeShowers.html#anchor28","text":"Use of matrix element corrections also after the first emission, for dipole ends of the same system that did not yet radiate. Only has a meaning if MEcorrections above is switched on."},{"name":"FourthBottom:ffbar2bPrimetbar(s:W)","link":"FourthGenerationProcesses.html#anchor7","text":"Scatterings f fbar' &rarr; b' tbar by s -channel exchange of a W^+- boson. Code 806."},{"name":"Charmonium:O(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor10","text":"The colour-singlet long-distance matrix elements <O[3S1(1)]> for the 3S1 charmonium states."},{"name":"void Settings::resetParm(string key)","link":"SettingsScheme.html#anchor71","text":""},{"name":"SLHA:meMode","link":"SUSYLesHouchesAccord.html#anchor7","text":"This value specifies how threshold, off-shell, and phase-space weighting effects for SLHA decay channels should be treated, using the same numbering scheme as for resonances. The default (100) is to use the branching fraction given in the SLHA DECAY tables without any modifications. The corresponding partial widths remain unchanged when the resonance fluctuates in mass. Specifically there are no threshold corrections. That is, if the resonance fluctuates down in mass, to below the nominal threshold for some decay mode, it is assumed that one of the daughters could also fluctuate down to keep the channel open. (If not, there may be problems later on.) Alternative options (with values 101+) documented under resonances allow for some flexibility to apply threshold factors expressing the closing of the on-shell phase space when the daughter masses approach or exceed the parent one. Note that modes that are extremely far off shell (defined as needing a fluctuation of more than 100 times the root-sum-square of the widths of the mother and daughter particles) will always be assigned meMode = 100 and should be switched off by hand if so desired. It is up to the user to ensure that the final behaviour is consistent with what is desired (and/or to apply suitable post facto reweightings). Plotting the generator-level resonance and decay-product mass distributions (and e.g., mass differences), effective branching fractions, etc, may be of assistance to validate the behaviour of the program."},{"name":"decays","link":"SUSYProcesses.html#anchor24","text":""},{"name":"int SlowJet::multiplicity(int i)","link":"EventAnalysis.html#anchor51","text":"gives the number of particles clustered into the i 'th jet,"},{"name":"StringFlav:probQQ1toQQ0","link":"FlavourSelection.html#anchor4","text":"the suppression of spin 1 diquark production relative to spin 0 one, apart from the factor of 3 enhancement of spin 1 from counting the number of states."},{"name":"HadronScatter:allowDecayProd","link":"HadronScattering.html#anchor17","text":"Allow two hadrons with same parent hadron to scatter."},{"name":"string SigmaProcess::inFlux()","link":"SemiInternalProcesses.html#anchor14","text":"this string specifies the combinations of incoming partons that are allowed for the process under consideration, and thereby which incoming flavours id1 and id2 the sigmaHat() calls will be looped over. It is always possible to pick a wider flavour selection than strictly required and then put to zero cross sections in the superfluous channels, but of course this may cost some extra execution time. Currently allowed options are: * gg : two gluons. * qg : one (anti)quark and one gluon. * qq : any combination of two quarks, two antiquarks or a quark and an antiquark. * qqbar : any combination of a quark and an antiquark; a subset of the qq option. * qqbarSame : a quark and its antiquark; a subset of the qqbar option. * ff : any combination of two fermions, two antifermions or a fermion and an antifermion; is the same as qq for hadron beams but also allows processes to work with lepton beams. * ffbar : any combination of a fermion and an antifermion; is the same as qqbar for hadron beams but also allows processes to work with lepton beams. * ffbarSame : a fermion and its antifermion; is the same as qqbarSame for hadron beams but also allows processes to work with lepton beams. * ffbarChg : a fermion and an antifermion that combine to give charge +-1. * fgm : a fermion and a photon (gamma). * ggm : a gluon and a photon. * gmgm : two photons."},{"name":"HiggsBSM:ffbar2A3H2","link":"HiggsProcesses.html#anchor59","text":"Scattering f fbar &rarr; A^0(H_3) H^0(H_2). Code 1082."},{"name":"HiggsSM:gg2Httbar","link":"HiggsProcesses.html#anchor14","text":"Scattering g g &rarr; H^0 t tbar via t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 908."},{"name":"HiggsBSM:ffbar2A3H1","link":"HiggsProcesses.html#anchor58","text":"Scattering f fbar &rarr; A^0(H_3) h^0(H_1). Code 1081."},{"name":"Beams:maxDevVertex","link":"BeamParameters.html#anchor33","text":"The triply Gaussian distribution of interaction vertex position (x, y, z) is restricted to a maximal total deviation from the origin, like x^2/sigma_x^2 + y^2/sigma_y^2 + z^2/sigma_z^2 < maxDevVertex^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick (x, y, z) .)"},{"name":"HiggsSM:ff2Hff(t:WW)","link":"HiggsProcesses.html#anchor13","text":"Scattering f_1 f_2 &rarr; H^0 f_3 f_4 via W^+ W^- fusion. Code 907."},{"name":"SigmaDiffractive:dampen","link":"TotalCrossSections.html#anchor13","text":"Allow a user to dampen diffractive cross sections; on/off = true/false."},{"name":"Electroweak Processes","link":"ElectroweakProcesses.html","text":"Electroweak Processes This page contains processes involving Prompt-photon, gamma^*/Z^0 and W^+- production, plus a few with t -channel boson exchange. Prompt photon processes This group collects the processes where one or two photons are produced by the hard process. Additional sources of photons include parton showers and hadron decays. A pT cut is required to stay away from the unphysical low- pT region. An eikonalized description, intended to be valid at all pT , is included as part of the multiparton-interactions framework. Weak boson processes Under this heading we group processes involving the production of a single electroweak gauge boson, i.e. a gamma^*/Z^0 or a W^+- , or a pair of them, or one of them in combination with a parton. Since the three sets are partly conflicting, each is associated with its own group flag. In addition, t -channel exchange of such a boson between two fermions form a separate group. There is one flag that can be used to influence the gamma^*/Z^0 structure in all the processes below where it is produced, unless otherwise stated. Boson exchange The two processes in this subgroup is included as part of the multiparton-interactions framework. Single boson Boson pair Note that, in the decay of the two vector bosons produced by an f fbar &rarr; V V process, the full four-fermion correlations from the leading-order f fbar &rarr; V V &rarr; 4f matrix elements are included Gun86 (with some extensions by the authors). The matrix elements are provided in the double-resonant approach, i.e. excludes graph like f fbar &rarr; V &rarr; f fbar &rarr; f fbar V &rarr; 4f. Boson and parton Photon Collision Processes A few electroweak two-photon production processes are available. To use them, photon PDFs have to be defined for the incoming beam particles. This is the case for the internal NNPDF 2.3 QCD+QED sets, as well as some further ones available in the LHAPDF library, but not for all PDFs. Photon-Parton Processes Photon-parton production processes. See comment related to PDFs above. Also relevant for direct-resolved processes in photon-photon collisions. Two instances of a given process are created when mixing processes where the direct photon can come from either side. In this case the process code in the parentheses is used when the direct photon is from side A."},{"name":"virtual bool MergingHooks::doCutOnRecState(const EventAMPERSAND  event)","link":"CKKWLMerging.html#anchor27","text":"This routine will be supplied internally with every possible reclustered event that can be reached by reclustering any number of partons in the matrix element input state. The new, reclustered, states can then be analysed. If the method returns false, the history to which the state belongs will be treated as if it were unordered, i.e. this path will only be chosen if no other histories are available. In this way, the number of histories not fulfilling the user criterion will be minimised."},{"name":"void Hist::rivetTable(string fileName,  bool printError = false)","link":"Histograms.html#anchor14","text":"print a five-column table, where the first two columns give the lower and upper borders of each bin, the third one the bin contents, and the fourth and fifth the error (up and down) associated with the contents. This format matches the one that Rivet uses for its histograms. The choice between the two methods is the same as above for the table methods. The error bins are put to zero by default, since the PYTHIA histogramming is not sophisticated enough to compensate for rescalings or other operations, or for weighted events. With the optional printError = true the error will be taken as the square root of the bin content, as is relevant if this content has the same unit weight for each entry to it."},{"name":"bool Settings::isPVec(string key)","link":"SettingsScheme.html#anchor23","text":""},{"name":"Extra-Dimensional Processes","link":"ExtraDimensionalProcesses.html","text":"Extra-Dimensional Processes Scenarios with extra dimensions (ED) allow a multitude of processes. Currently three different categories of processes are implemented. The first involves the production of excited Kaluza Klein states within so-called Randall-Sundrum (RS) scenarios, the second is related to resonance production in TeV-1 sized extra dimensions and the third relates to phenomena from large extra dimensions (LED). Due to the close relation between the LED model and a so-called unparticle model, similar unparticle processes are also kept in this section. Randall-Sundrum Resonances, production processes The graviton (G*) and gluon (KKgluon*) resonance states are assigned PDG code 5100039 and 5100021 respectively. The G* processes are described in Bij01 and the KKgluon* process in Ask11. Decays into fermion and boson pairs are handled with the correct angular distributions, while subsequent decays are handled isotropically. There are two lowest-order processes that together normally should be sufficient for a simulation of G^* production. In addition there are three first-order processes included. These are of less interest, but can be used for dedicated studies of the high- pT tail of G^* production. As usual, it would be double counting to include the lowest-order and first-order processes simultaneously. Therefore the latter ones are not included with the ExtraDimensionsG*:all = on option. In this set of processes all decay angles are assumed isotropic. There is also one process for the production of a gluon resonance. Randall-Sundrum Resonances, parameters In the above scenario the main free parameters are the masses, which are set as usual. In addition there are the following coupling parameters. The coupling kappaMG follows the conventions in Bij01 , where as the flavour dependent couplings follow the conventions used in Dav01. TeV^-1 Sized Extra Dimension, production processes This section contains a processes involving the production of electroweak KK gauge bosons, i.e. gamma_{KK}/Z_{KK} , in one TeV^-1 sized extra dimension. The process is described in Bel10 and allows for individual final states to be specified. TeV^-1 Sized Extra Dimension, parameters Irrespective of the parameter options used, the particle produced, gamma_{KK}/Z_{KK} , will always be assigned code 5000023. Large Extra Dimensions, production processes The LED graviton, where the KK-modes normally are summed and do not give rise to phenomena individually, is assigned PDG code 5000039. The graviton emission and virtual graviton exchange processes use the same implementation as the corresponding unparticle processes, which are all described in Ask10. It is also possible to generate monojet events from scalar graviton emission as described in Azu05 , by turning on the option GravScalar. Note: As discussed in Ask09 , for the graviton or unparticle emission processes the underlying Breit-Wigner mass distribution should be matched to the graviton mass spectrum in order to achieve an optimal MC efficiency. The following lowest order graviton emission processes are available. The following LED processes with virtual graviton exchange are available. Dijet production including graviton exchange is also available, using the same effective theory approach as the LED G exchange processes above or including more detailed amplitudes in accordance with Fra11. In case of the latter, the value of LambdaT is used as the value of the cut-off scale Lambda. For this reason the dijet processes only relates to the LED model and no unparticle versions are available. The processes are grouped together like their HardQCD equivalents and should therefore converge to the same results in the limit of an insignificant graviton contribution. Warning: These LED dijets processes are still being validated. Large Extra Dimensions, parameters Unparticles, production processes As mentioned above, the similar unparticle and graviton processes share the same implementations. The unparticle processes, however, only use the dedicated unparticle parameters below. The unparticle is also assigned the PDG code 5000039 and is therefore called Graviton in the event record. The graviton and unparticle emission as well as virtual graviton and unparticle exchange processes are described in Ask10. Note: As discussed in Ask09 , for the graviton or unparticle emission processes the underlying Breit-Wigner mass distribution should be matched to the graviton mass spectrum in order to achieve an optimal MC efficiency. The following unparticle emission processes are available. The following processes with virtual unparticle exchange are available. Unparticles, parameters"},{"name":"double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0)","link":"ParticleDataScheme.html#anchor167","text":"special case to calculate one final-state width; currently only used for Higgs decay to q qbar , g g or gamma gamma."},{"name":"void Settings::addMVec(string key,  vectorAMPERSANDlt;intAMPERSANDgt; default, bool hasMin, bool hasMax,  int min, int max)","link":"SettingsScheme.html#anchor30","text":""},{"name":"PhaseSpace:bias2SelectionPow","link":"PhaseSpaceCuts.html#anchor23","text":"If the above flag is on, then a 2 &rarr; 2 process at a scale pTHat will be oversampled in phase space by an amount (pTHat/pTRef)^pow , where you set the power pow here. Events are assigned a compensating weight the inverse of this, i.e. Info::weight() will return (pTRef/pTHat)^pow. This weight should then be used in the histogramming of event properties. The final overall normalization also involves the Info::weightSum() value."},{"name":"void Particle::mothers(int mother1, int mother2)","link":"ParticleProperties.html#anchor26","text":"sets both mothers in one go."},{"name":"double getEnhancedEventWeight()","link":"UserHooks.html#anchor45","text":"If you use enhanced emissions, it is paramount to attribute a corrective weight to each event containing enhanced emissions. This function returns this weight. In the presence of enhancements, all histograms and output events must account for this weight."},{"name":"HardQCD:all","link":"QCDProcesses.html#anchor8","text":"Common switch for the group of all hard QCD processes, as listed separately in the following."},{"name":"virtual bool UserHooks::canSetResonanceScale()","link":"UserHooks.html#anchor38","text":"In the base class this method returns false. If you redefine it to return true then the method scaleResonance(...) will set the initial scale of downwards shower evolution."},{"name":"PhotonCollision:gmgm2ccbar","link":"ElectroweakProcesses.html#anchor33","text":"Scattering gamma gamma &rarr; c cbar. Code 262."},{"name":"ExtraDimensionsLED:CutOffMode","link":"ExtraDimensionalProcesses.html#anchor64","text":"Options for when the hard scale of the process (e.g. sHat ) approaches or exceed the scale of validity of the low energy effective theory (e.g. M_D ). Note: Option 1 only concerns the graviton emission processes and the form factor is currently not available for the scalar graviton processes. Do nothing, i.e. all values of sHat contribute. Truncate contributing sHat region ( Ask09 ). Form factor, using mu = renormScale2. Form factor, using mu = E_jet."},{"name":"HiddenValley:alphaOrder","link":"HiddenValleyProcesses.html#anchor34","text":"Order at which alpha_HV runs, zeroth order, i.e. alpha_HV is kept fixed at the value alphaFSR. first order, with the beta function based on Ngauge and Nflav."},{"name":"PhaseSpace:showViolation","link":"PhaseSpaceCuts.html#anchor20","text":"Possibility to print information whenever the assumed maximum differential cross section of a process is violated, i.e. when the initial maximization procedure did not find the true maximum. Also, should negative cross sections occur, print whenever a more negative value is encountered."},{"name":"QCD Processes","link":"QCDProcesses.html","text":"QCD Processes This section is subdivided into soft and hard QCD processes, with open charm and bottom production set aside as a special part of the latter, and three-jet topologies as a special subset. Kindly note that there is a considerable amount of overlap between the soft and hard process classes, so that you are likely to double-count if you include both in a run. Soft QCD processes As a rule, the processes in this class should not be mixed with the simulation of other processes. All by themselves, they are intended to represent the total cross section of hadron collisions, with the exception of the 'rare processes' that one wishes to study separately. In particular, jet physics at all scales occurs as part of the minimum-bias description. We here use the 'minimum bias' expression as a shorthand for inelastic, nondiffractive events. Strictly speaking, 'minimum bias' represents an experimental procedure of accepting 'everything', with some non-universal cuts to exclude elastic and diffractive topologies. In practice, the experimental minimum-bias sample may then contain some contamination of what is in PYTHIA classified as diffractive, especially (high-mass) double diffractive. Some options to modify these cross sections are found on the Total Cross Sections page. Hard QCD processes This group contains the processes for QCD jet production above some minimum pT threshold. The pT_min cut cannot be put too low, or else unreasonably large jet cross sections will be obtained. This is because the divergent perturbative QCD cross section is used in this process group, without any regularization modifications. An eikonalized description, intended to be valid at all pT , is instead included as part of the multiparton-interactions framework, specifically in SoftQCD:nonDiffractive above. Warning 1 : you must remember to set the PhaseSpace:pTHatMin value if you use any of these processes; there is no sensible default. Warning 2 : you must not mix processes from the SoftQCD and HardQCD process groups, since this is likely to lead to double-counting. Hard QCD processes: heavy-flavour subset These processes form a natural part of the above class, but can also be generated separately. Formally the heavy-quark mass makes these matrix elements finite in the pT &rarr; 0 limit, but at high energies one may still question the validity of the expressions at low pT values, like for the other hard-QCD processes. Also as above, an eikonalized description, intended to be valid at all pT , is included as part of the multiparton-interactions framework. Note that the processes below only represent the 'tip of the iceberg' of charm and bottom production at high energies, where flavour excitation and shower branchings provide major additional sources. All these sources come together in the descriptions offered by SoftQCD:nonDiffractive and HardQCD:all. Hard QCD three-parton processes Three-parton final states are generated by showers off two-parton processes. Topologies then cannot be specified beforehand, beyond what is provided by the two-parton hard process. For some checks it may be convenient to have access to the dedicated three-parton final states, which is what this set of processes allows. Cross sections have been taken from Ber81. Note that the processes in this section are not affected by the HardQCD:all switch. In fact, it would be double-counting to include both the HardQCD:all and the HardQCD:3parton processes in a run or study. Warning: this section is still incomplete, e.g. the selection of colour flow is very simple, and so it should only be used with caution."},{"name":"PDF:lepton2gamma","link":"PDFSelection.html#anchor20","text":"Gives photon beams from leptons. Both, unresolved (direct) and resolved contributions are included, see Photoproduction for details. Can be used only with charged leptons. The applied photon PDF set is selected with the PDF:GammaSet and PDF:GammaHardSet options above. Events with two unresolved photon initiators can be generated also with the PDF:lepton = on but then additional phase-space cuts (e.g. cut on the invariant mass of the photon-photon pair) are not applied."},{"name":"HiggsA3:coup2H1H1","link":"HiggsProcesses.html#anchor105","text":"The A^0(H_3^0) coupling to a h^0(H_1^0) pair. Vanishes in the MSSM."},{"name":"bool Particle::isCharged()","link":"ParticleProperties.html#anchor68","text":""},{"name":"int LHAup::status(int i)","link":"LesHouchesAccord.html#anchor40","text":""},{"name":"int Thrust::nError()","link":"EventAnalysis.html#anchor17","text":"tells the number of times analyze(...) failed to analyze events, i.e. returned false."},{"name":"TimeShower:nGammaToLepton","link":"TimelikeShowers.html#anchor41","text":"Number of allowed lepton flavours in gamma &rarr; l+ l- branchings (phase space permitting). A change to 2 would exclude gamma &rarr; tau+ tau- , and a change to 1 also gamma &rarr; mu+ mu-."},{"name":"virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vectorAMPERSANDlt;intAMPERSANDgt; iParton)","link":"UserHooks.html#anchor48","text":"This is the method for changing fragmentation parameters. If all parameters are changed as they should, the method should return true. In case of errors the method returns false and a warning is printed. The method takes as argument pointers to three objects that hold the fragmentation parameters, and three arguments that give information about the string currently being hadronized. is a pointer to a StringFlav object, which selects quark and diquark flavours and hadron species formed in the string breaks. The parameters can be changed by setting new parameters in a Settings object and reinitializing with flavPtr->init(settings,randomPtr) , where settings is the settings object and randomPtr is a pointer to the desired random number generator. Note that the UserHooks base class already holds pointers to the Settings and Random objects. is a pointer to a StringZ object, which selects the hadron momentum fraction z using the Lund fragmentation function. Parameters are changed by zPtr->init(settings,particleData,randomPtr) in the same way as above. is a pointer to a StringPT object which selects the hadron pT from a Gaussian distribution. Parameters are changed by pTPtr->init(settings,particleData,randomPtr) in the same way as above. gives the code of the parton (quark, diquark or gluon) in the string end that we are currently hadronizing from. gives the invariant mass squared of all hadrons produced from the current end of the string up to this point. Used to keep track of where we are on the string. contains the indices in the standard event record for all the partons in the string currently being hadronized."},{"name":"JetMatching:eTthreshold","link":"JetMatching.html#anchor9","text":"Specific to the CellJet algorithm, cells with eT < eTthreshold are completely neglected by the jet algorithm."},{"name":"vectorAMPERSANDlt;intAMPERSANDgt; SlowJet::clusConstituents(int i)","link":"EventAnalysis.html#anchor53","text":"gives a list of the indices of the particles that have been clustered into the i 'th cluster, at the current stage of the clustering process,"},{"name":"void DecayChannel::rescaleBR(double fac)","link":"ParticleDataScheme.html#anchor174","text":"multiply the current branching ratio by fac."},{"name":"HiggsH2:parity","link":"HiggsProcesses.html#anchor114","text":"possibility to modify angular decay correlations in the decay of a H^0(H_2) decay Z^0 Z^0 or W^+ W^- to four fermions, or tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. isotropic decays. assuming the H^0(H_2) is a pure scalar (CP-even), as in the MSSM. assuming the H^0(H_2) is a pure pseudoscalar (CP-odd). assuming the H^0(H_2) is a mixture of the two, including the CP-violating interference term. The parameter eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to eta and the CP-odd one to eta^2. Intended or decays into W^+ W^- or Z^0 Z^0. same as 3 but now phi , see below, sets the CP-mixing angle. The CP-even term is proportional to sin^2(phi) , the interference to sin(phi)cos(phi) , and the CP-odd term to cos^2(phi). Consequently phi=0 is pure CP-odd and phi=pi/2 is pure CP-even. Intended for decays of H -> f fbar , notably for tau lepton polarization, whereas W^+ W^- and Z^0 Z^0 decays are isotropic."},{"name":"HiggsH2:coup2H1H1","link":"HiggsProcesses.html#anchor93","text":"The H^0(H_2^0) coupling to a h^0(H_1^0) pair. Is cos(2 alpha) cos(beta + alpha) - 2 sin(2 alpha) sin(beta + alpha) in the MSSM."},{"name":"virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const EventAMPERSAND event, int iSys, bool inResonance = false)","link":"UserHooks.html#anchor26","text":"can optionally be called, as described above. You can study, but not modify, the event event record of the partonic process. Based on that you can decide whether to veto the emission, true, or not, false. If you veto, then the latest emission is removed from the event record. In either case the evolution of the shower will continue from the point where it was left off. is the size of the event record before the latest emission was added to it. It will also become the new size if the emission is vetoed. the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent emission, which are stored in entries from sizeOld through event.size() - 1 inclusive. If you veto the emission these entries will be removed, and the history info in the remaining partons will be restored to a state as if the emission had never occurred. the system where the radiation occurs, according to Parton Systems. true if the emission takes place in a resonance decay, subsequent to the hard process."},{"name":"virtual bool UserHooks::canModifySigma()","link":"UserHooks.html#anchor29","text":"In the base class this method returns false. If you redefine it to return true then the method multiplySigmaBy(...) will allow you to modify the cross section weight assigned to the current event."},{"name":"void Vec4::pz(double pzIn)","link":"FourVectors.html#anchor10","text":""},{"name":"void Settings::resetFVec(string key)","link":"SettingsScheme.html#anchor73","text":""},{"name":"PDF:lepton2gammaSet","link":"PDFSelection.html#anchor21","text":"The photon flux. Currently one option available. Convolute the photon flux from EPA with the selected photon PDF set. Convolution integral is performed 'on the fly', meaning that the actual integral is not computed but the x_gamma is sampled event-by-event. Since the final PDF value depends on the sampled value for x_gamma the phase-space sampling is set up using an overestimate for the PDFs. This makes the process selection somewhat less efficient compared to the case where the PDFs are fixed (e.g. for protons)."},{"name":"virtual bool UserHooks::canVetoProcessLevel()","link":"UserHooks.html#anchor8","text":"In the base class this method returns false. If you redefine it to return true then the method doVetoProcessLevel(...) will be called immediately after a hard process (and associated resonance decays) has been selected and stored in the process event record. At this stage, the process record typically contains the two beams in slots 1 and 2, the two incoming partons to the hard process in slots 3 and 4, the N (usually 1, 2 or 3) primary produced particles in slots 5 through 4 + N, and thereafter recursively the resonance decay chains, if any. Use the method omitResonanceDecays(...) if you want to skip these decay chains. There are exceptions to this structure, for soft QCD processes (where the partonic process may not yet have been selected at this stage), and when a second hard process has been requested (where two hard processes are bookkept). In general it is useful to begin the development work by listing a few process records, to clarify what the structure is for the cases of interest."},{"name":"void ParticleData::isResonance(int id, bool isResonance)","link":"ParticleDataScheme.html#anchor51","text":""},{"name":"ExtraDimensionsTEV:gmZmode","link":"ExtraDimensionalProcesses.html#anchor39","text":"Choice of full gamma_{KK}/Z_{KK} structure or not in relevant processes. full gamma_{SM}/Z_{SM} structure, with interference included. only pure gamma_{SM} contribution. only pure Z_{SM} contribution. full gamma_{KK}/Z_{KK} structure, with interference included. only pure gamma_{KK} contribution, with SM interference included. only pure Z_{KK} contribution, with SM interference included."},{"name":"void SlowJet::list()","link":"EventAnalysis.html#anchor56","text":"provides a listing of the basic jet information from above."},{"name":"ExtraDimensionsLED:ffbar2Ggamma","link":"ExtraDimensionalProcesses.html#anchor47","text":"Scatterings f fbar &rarr; G gamma. This process corresponds to the photon limit of the G Z process, as described in Ask09. Code 5025."},{"name":"ColourReconnection:forceResonance","link":"ColourReconnection.html#anchor4","text":"This parameter allows an additional CR after late resonance decays. All the particles from all resonance decays are allowed to reconnect with each other. It is mainly intended for H -> WW -> qqqq , where the Higgs decay ensures a separation between the W bosons and the MPI systems. Reconnections between the decay products from the two W bosons is still a possibility, however. This option is not available for colored resonances, and not for the MPI-based model."},{"name":"BoseEinstein:Kaon","link":"BoseEinsteinEffects.html#anchor2","text":"Include effects or not for identical K^+ , K^- , K_S^0 and K_L^0."},{"name":"SecondHard:SingleGmZ","link":"ASecondHardProcess.html#anchor7","text":"Scattering q qbar &rarr; gamma^*/Z^0 , with full interference between the gamma^* and Z^0."},{"name":"Wprime:coup2WZ","link":"NewGaugeBosonProcesses.html#anchor44","text":"the coupling W'^0 &rarr; W^+- Z^0 is taken to be this number times m_W^2 / m_W'^2 times the W^+- &rarr; W^+- Z^0 coupling. Thus a unit value corresponds to the W^+- &rarr; W^+- Z^0 coupling, scaled down by a factor m_W^2 / m_W'^2 , and gives a W'^+- partial width into this channel that increases linearly with the W'^+- mass. If you cancel this behaviour, by letting Wprime:coup2WZ be proportional to m_W'^2 / m_W^2 , you instead obtain a partial width that goes like the fifth power of the W'^+- mass. These two extremes correspond to the 'extended gauge model' and the 'reference model', respectively, of Alt89."},{"name":"void Pythia::LHAeventList()","link":"ProgramFlow.html#anchor28","text":"list the Les Houches Accord information on the current event, see LHAup::listEvent(...). (Other listings are available via the class members below, so this listing is a special case that would not fit elsewhere.)"},{"name":"bool LHAupHelaconia::readString(string line)","link":"HelacOniaProcesses.html#anchor2","text":"allows the user to send commands to HelacOnia. the command to be sent to HelacOnia. For example, the following will produce J/psi events events from 13 TeV proton proton collisions: readString('generate u u~ > cc~(3S11) g'); A special case is the generation of colour-octet states. In PYTHIA these are evolved to colour-singlet states through the emission of a soft gluon with the mass splitting set by Onia:massSplit. To ensure the colour-octet states in HelacOnia are produced with the correct masses needed for this splitting, the specific colour-octet state for the process must be set. For example: readString('generate u u~ > cc~(3S18) g'); requires that the colour-singlet state into which the colour-octet state should decay be set. This could be set via: readString('set state = 443'); for the case where a final state J/psi is requested. Note that this is not a command passed to HelacOnia, but rather a command which PYTHIA uses to set the heavy quark mass in HelacOnia and then translate the HelacOnia output to the correct colour-singlet state."},{"name":"friend void table(const HistAMPERSANDamp; h1, const HistAMPERSANDamp; h2,  string fileName, bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor16","text":"print a three-column table, where the first column gives the center of each bin and the second and third ones the corresponding bin contents of the two histograms. Only works if the two histograms have the same x axis (within a tiny tolerance), else nothing will be done. The optional last two arguments allows also underflow and overflow contents to be printed, and the x to refer to the beginning of the bin rather than the center; see above."},{"name":"Zprime:vnutau","link":"NewGaugeBosonProcesses.html#anchor26","text":"vector coupling of nu_tau neutrinos."},{"name":"double CoupSM::VCKMgen(int genU, int genD)","link":"StandardModelParameters.html#anchor40","text":""},{"name":"double Particle::mT2()","link":"ParticleProperties.html#anchor44","text":"(squared) transverse mass. If m_T^2 is negative, which can happen for a spacelike parton, then mT() returns -sqrt(-m_T^2) , by analogy with the negative sign used to store spacelike masses."},{"name":"virtual bool TimeShower::limitPTmax( EventAMPERSAND event,  double Q2Fac = 0.,  double Q2Ren = 0.)","link":"ImplementNewShowers.html#anchor5","text":"The question is whether the FSR should be allowed to occur at larger scales than the hard process it surrounds. This is process-dependent, as illustrated below for the the analogous SpaeShower::limitPTmax(...) method, although the two kinds of radiation need not have to be modeled identically. The TimeShower:pTmaxMatch switch allows you to force the behaviour among three options, but you may replace by your own logic. The internal PYTHIA implementation also allows intermediate options, where emissions can go up to the kinematical limit but be dampened above the factorization or renormalization scale. Therefore the (square of the) latter two are provided as optional input parameters."},{"name":"SecondHard:TwoPhotons","link":"ASecondHardProcess.html#anchor4","text":"Two prompt photons recoiling against each other."},{"name":"Vec4AMPERSAND Vec4::operator+=(const Vec4AMPERSAND v)","link":"FourVectors.html#anchor49","text":"add a four-vector to an existing one."},{"name":"HiggsBSM:ff2H1ff(t:WW)","link":"HiggsProcesses.html#anchor31","text":"Scattering f_1 f_2 &rarr; h^0(H_1^0) f_3 f_4 via W^+ W^- fusion. Code 1007."},{"name":"HiddenValley:sigmamqv","link":"HiddenValleyProcesses.html#anchor44","text":"the width sigma of transverse momenta in the HV fragmentation process, normalized to the qv mass. This ensures that sigma scales proportionately to m_qv. See the normal fragmentation pT description for conventions for factors of 2."},{"name":"StandardModel:GF","link":"StandardModelParameters.html#anchor6","text":"The Fermi coupling constant, in units of GeV ^-2."},{"name":"void ParticleData::resInit(int id)","link":"ParticleDataScheme.html#anchor81","text":"initialize the treatment of a resonance."},{"name":"bool AlpgenPar::haveParam(const string AMPERSANDamp;paramIn)","link":"AlpgenEventInterface.html#anchor11","text":"Method to check if a parameter with key paramIn is present. Returns true if present, else false."},{"name":"MultipartonInteractions:ecmRef","link":"MultipartonInteractions.html#anchor8","text":"The ecmRef reference energy scale introduced above."},{"name":"ExtraDimensionsLED:gg2DJqqbar","link":"ExtraDimensionalProcesses.html#anchor54","text":"Scatterings g g &rarr; (LED G*) &rarr; q qbar. Number of outgoing flavours specified by nQuarkNew parameter below. Code 5031."},{"name":"HardQCD:gg2qqbarg","link":"QCDProcesses.html#anchor30","text":"Scatterings g g &rarr; q qbar g , where q by default is a light quark ( u, d, s ) (see HardQCD:nQuarkNew above). Code 138."},{"name":"StringZ:aLund","link":"Fragmentation.html#anchor1","text":"The a parameter of the Lund symmetric fragmentation function."},{"name":"virtual UserHooks::~UserHooks()","link":"UserHooks.html#anchor2","text":"The constructor and destructor do not need to do anything."},{"name":"int ParticleData::colType(int id)","link":"ParticleDataScheme.html#anchor38","text":"the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 octet, taking into account the sign of id."},{"name":"Diffraction","link":"Diffraction.html","text":"Diffraction Introduction Diffraction is not well understood, and several alternative approaches have been proposed. Here we follow a fairly conventional Pomeron-based one, in the Ingelman-Schlein spirit Ing85 , but integrated to make full use of the standard PYTHIA machinery for multiparton interactions, parton showers and hadronization Nav10,Cor10a. This is the approach pioneered in the PomPyt program by Ingelman and collaborators Ing97. For ease of use (and of modelling), the Pomeron-specific parts of the generation of inclusive ('soft') diffreactive events are subdivided into three sets of parameters that are rather independent of each other: (i) the total, elastic and diffractive cross sections are parametrized as functions of the CM energy, or can be set by the user to the desired values, see the Total Cross Sections page; (ii) once it has been decided to have a diffractive process, a Pomeron flux parametrization is used to pick the mass of the diffractive system(s) and the t of the exchanged Pomeron, see below; (iii) a diffractive system of a given mass is classified either as low-mass unresolved, which gives a simple low- pT string topology, or as high-mass resolved, for which the full machinery of multiparton interactions and parton showers are applied, making use of Pomeron PDFs. The parameters related to multiparton interactions, parton showers and hadronization are kept the same as for normal nondiffractive events, with only one exception. This may be questioned, especially for the multiparton interactions, but we do not believe that there are currently enough good diffractive data that would allow detailed separate tunes. The above subdivision may not represent the way 'physics comes about'. For instance, the total diffractive cross section can be viewed as a convolution of a Pomeron flux with a Pomeron-proton total cross section. Since neither of the two is known from first principles there will be a significant amount of ambiguity in the flux factor. The picture is further complicated by the fact that the possibility of simultaneous further multiparton interactions ('cut Pomerons') will screen the rate of diffractive systems. In the end, our set of parameters refers to the effective description that emerges out of these effects, rather than to the underlying 'bare' parameters. In the event record the diffractive system in the case of an excited proton is denoted p_diffr , code 9902210, whereas a central diffractive system is denoted rho_diffr , code 9900110. Apart from representing the correct charge and baryon numbers, no deeper meaning should be attributed to the names. PYTHIA also includes a possibility to select hard diffraction. This machinery relies on the same sets of parameters as described above, for the Pomeron flux and PDFs. The main difference between the hard and the soft diffractive frameworks is that the user can select any PYTHIA hard process in the former case, e.g. diffractive Z 's or W 's, whereas only QCD processes are generated in the latter. These QCD processes are generated inclusively, which means that mostly they occur in the low- pT region, even if a tail stretches to higher pT scales, thus overlapping with hard diffraction. Both hard and soft diffractive processes also include the normal PYTHIA machinery, such as MPIs and showers, but for the former the MPI framework can additionally be used to determine whether a hard process survives as a diffractive event or not. The different diffractive types - low mass soft, high mass soft and hard diffraction - are described in more detail below. Pomeron flux As already mentioned above, the total diffractive cross section is fixed by a default energy-dependent parametrization or by the user, see the Total Cross Sections page. Therefore we do not attribute any significance to the absolute normalization of the Pomeron flux. The choice of Pomeron flux model still will decide on the mass spectrum of diffractive states and the t spectrum of the Pomeron exchange. In options 3, 4, 6, and 7 above, the Pomeron Regge trajectory is parametrized as alpha(t) = 1 + epsilon + alpha' t The epsilon and alpha' parameters can be set separately in options 3 and 4, and additionally alpha' is set in option 1: When option 5 is selected, the following parameters of the MBR model Cie12 are used: Separation of soft diffraction into low and high masses Preferably one would want to have a perturbative picture of the dynamics of Pomeron-proton collisions, like multiparton interactions provide for proton-proton ones. However, while PYTHIA by default will only allow collisions with a CM energy above 10 GeV, the mass spectrum of diffractive systems will stretch to down to the order of 1.2 GeV. It would not be feasible to attempt a perturbative description there. Therefore we do offer a simpler low-mass description, with only longitudinally stretched strings, with a gradual switch-over to the perturbative picture for higher masses. The probability for the latter picture is parametrized as P_pert = P_max ( 1 - exp( (m_diffr - m_min) / m_width ) ) which vanishes for the diffractive system mass m_diffr < m_min , and is 1 - 1/e = 0.632 for m_diffr = m_min + m_width , assuming P_max = 1. Low-mass soft diffraction When an incoming hadron beam is diffractively excited, it is modeled as if either a valence quark or a gluon is kicked out from the hadron. In the former case this produces a simple string to the leftover remnant, in the latter it gives a hairpin arrangement where a string is stretched from one quark in the remnant, via the gluon, back to the rest of the remnant. The latter ought to dominate at higher mass of the diffractive system. Therefore an approximate behaviour like P_q / P_g = N / m^p is assumed. When a gluon is kicked out from the hadron, the longitudinal momentum sharing between the the two remnant partons is determined by the same parameters as above. It is plausible that the primordial kT may be lower than in perturbative processes, however: High-mass soft diffraction The perturbative description need to use parton densities of the Pomeron. The options are described in the page on PDF Selection. The standard perturbative multiparton interactions framework then provides cross sections for parton-parton interactions. In order to turn these cross section into probabilities one also needs an ansatz for the Pomeron-proton total cross section. In the literature one often finds low numbers for this, of the order of 2 mb. These, if taken at face value, would give way too much activity per event. There are ways to tame this, e.g. by a larger pT0 than in the normal pp framework. Actually, there are many reasons to use a completely different set of parameters for MPI in diffraction than in pp collisions, especially with respect to the impact-parameter picture, see below. A lower number in some frameworks could alternatively be regarded as a consequence of screening, with a larger 'bare' number. For now, however, an attempt at the most general solution would carry too far, and instead we patch up the problem by using a larger Pomeron-proton total cross section, such that average activity makes more sense. This should be viewed as the main tunable parameter in the description of high-mass diffraction. It is to be fitted to diffractive event-shape data such as the average charged multiplicity. It would be very closely tied to the choice of Pomeron PDF; we remind that some of these add up to less than unit momentum sum in the Pomeron, a choice that also affect the value one ends up with. Furthermore, like with hadronic cross sections, it is quite plausible that the Pomeron-proton cross section increases with energy, so we have allowed for a power-like dependence on the diffractive mass. Also note that, even for a fixed CM energy of events, the diffractive subsystem will range from the abovementioned threshold mass m_min to the full CM energy, with a variation of parameters such as pT0 along this mass range. Therefore multiparton interactions are initialized for a few different diffractive masses, currently five, and all relevant parameters are interpolated between them to obtain the behaviour at a specific diffractive mass. Furthermore, A B &rarr; X B and A B &rarr; A X are initialized separately, to allow for different beams or PDF's on the two sides. These two aspects mean that initialization of MPI is appreciably slower when perturbative high-mass diffraction is allowed. Diffraction tends to be peripheral, i.e. occur at intermediate impact parameter for the two protons. That aspect is implicit in the selection of diffractive cross section. For the simulation of the Pomeron-proton subcollision it is the impact-parameter distribution of that particular subsystem that should rather be modeled. That is, it also involves the transverse coordinate space of a Pomeron wavefunction. The outcome of the convolution therefore could be a different shape than for nondiffractive events. For simplicity we allow the same kind of options as for nondiffractive events, except that the bProfile = 4 option for now is not implemented. Hard diffraction When PYTHIA is requested to generate a hard process, by default it is assumed that the full perturbative cross section is associated with nondiffractive topologies. With the options in this section, PYTHIA includes a possibility for creating a perturbative process diffractively, however. This framework is denoted hard diffraction to distiguish it from soft diffraction, but recall that the latter contains a tail of high- pT processes that could alternatively be obtained as hard diffraction. The idea behind hard diffraction is similar to soft diffraction, as they are both based on the Pomeron model. The proton is thus modelled as having a Pomeron component, described by the Pomeron fluxes above, and the partonic content of the Pomeron is described by the Pomeron PDFs, also described above. From these components we can evaluate the probability for the chosen hard process to have been coming from a diffractively exited system, based on the ratio of the Pomeron flux convoluted with Pomeron PDF to the inclusive proton PDF. If the hard process is likely to have been created inside a diffractively excited system, then we also evaluate the momentum fraction carried by the Pomeron, x_Pomeron , and the momentum transfer, t , in the process. This information can also be extracted in the main programs, see eg. example main61.cc. Further, we distiguish between two alternative scenarios for the classification of hard diffraction. The first is based solely on the Pomeron flux and PDF, as described above. In the second an additional requirement is imposed, wherein the MPI machinery is not allowed to generate any extra MPIs at all, since presumably these would destroy the rapidity gap and thereby the diffractive nature. We refer to the former as MPI-unchecked and the latter as MPI-checked hard diffraction. The MPI-checked option is likely to be the more realistic one, but the MPI-unchecked one offers a convenient baseline for the study of MPI effects, which still are poorly understood. For the selected hard processes, the user can choose whether to generate the inclusive sample of both diffractive and nondiffractive topologies or diffractive only, and in each case with the diffractive ones distinguished either MPI-unchecked or MPI-checked. There is also the possibility to select only a specific subset of events in hard diffraction. The Pomeron PDFs have not been scaled to unit momentum sum by the H1 Collaboration, but instead they let the PDF normalization float after the flux had been normalized to unity at x_Pom=0.03. This means that the H1 Pomeron has a momentum sum that is about a half. It could be brought to unit momentum sum by picking the parameter PDF:PomRescale to be around 2. In order not to change the convolution of the flux and the PDFs, the flux then needs to be rescaled by the inverse. This introduces a new rescaling parameter: When using the MBR flux, the model requires a renormalization of the Pomeron flux. This suppresses the flux with approximately a factor of ten, thus making it incompatible with the MPI suppression of the hard diffraction framework. We have thus implemented an option to renormalize the flux. If you wish to use the renormalized flux of the MBR model, you must generate the MPI-unchecked samples, otherwise diffractive events will be suppressed twice. The transverse matter profile of the Pomeron, relative to that of the proton, is not known. Generally a Pomeron is supposed to be a smaller object in a localized part of the proton, but one should keep an open mind. Therefore below you find three extreme scenarios, which can be compared to gauge the impact of this uncertainty."},{"name":"TimeShower:recoilToColoured","link":"TimelikeShowers.html#anchor47","text":"In the decays of coloured resonances, say t &rarr; b W , it is not possible to set up dipoles with matched colours. Originally the b radiator therefore has W as recoiler, and that choice is unique. Once a gluon has been radiated, however, it is possible either to have the unmatched colour (inherited by the gluon) still recoiling against the W ( off ), or else let it recoil against the b also for this dipole ( on ). Before version 8.160 the former was the only possibility, which could give unphysical radiation patterns. It is kept as an option to check backwards compatibility. The same issue exists for QED radiation, but obviously is less significant. Consider the example W &rarr; e nu , where originally the nu takes the recoil. In the old ( off ) scheme the nu would remain recoiler, while in the new ( on ) instead each newly emitted photon becomes the new recoiler."},{"name":"Left-Right-Symmetry Processes","link":"LeftRightSymmetryProcesses.html","text":"Left-Right-Symmetry Processes At current energies, the world is left-handed, i.e. the Standard Model contains an SU(2)_L group. Left-right symmetry at some larger scale implies the need for an SU(2)_R group. Thus the particle content is expanded by right-handed Z_R^0 and W_R^+- and right-handed neutrinos. The Higgs fields have to be in a triplet representation, leading to doubly-charged Higgs particles, one set for each of the two SU(2) groups. Also the number of neutral and singly-charged Higgs states is increased relative to the Standard Model, but a search for the lowest-lying states of this kind is no different from e.g. the freedom already accorded by the MSSM Higgs scenarios. PYTHIA implements the scenario of Hui97. The W_R^+- has been implemented as a simple copy of the ordinary W^+- , with the exception that it couples to right-handed neutrinos instead of the ordinary left-handed ones. Thus the standard CKM matrix is used in the quark sector, and the same vector and axial coupling strengths, leaving only the mass as free parameter. The Z_R^0 implementation (without interference with the photon or the ordinary Z^0 ) allows decays both to left- and right-handed neutrinos, as well as other fermions, according to one specific model ansatz. Obviously both the W_R^+- and the Z_R^0 descriptions are  likely to be simplifications, but provide a starting point. For the doubly-charged Higgs bosons, the main decay modes implemented are H_L^++ &rarr; W_L^+ W_L^+, l_i^+ l_j^+ ( i, j generation indices) and H_R^++ &rarr; W_R^+ W_R^+, l_i^+ l_j^+. The right-handed neutrinos can be allowed to decay further. Assuming them to have a mass below that of W_R^+- , they decay to three-body states via a virtual W_R^+- , nu_Rl &rarr; l+- f fbar' , where both lepton charges are allowed owing to the Majorana character of the neutrinos. If there is a significant mass splitting, also sequential decays nu_Rl &rarr; l+- l'-+  nu'_Rl are allowed. Currently the decays are isotropic in phase space. If the neutrino masses are close to or above the W_R^ ones, this description has to be substituted by a sequential decay via a real W_R^ (not implemented, but actually simpler to do than the one here). Production processes A few different production processes have been implemented, which normally would not overlap and therefore could be run together. Parameters The basic couplings of the model are The corresponding vacuum expectation value v_R is assumed given by v_R = sqrt(2) M_WR / g_R and is not stored explicitly. The Yukawa couplings of a lepton pair to a H^-- , assumed the same for H_L^-- and H_R^-- , is described by a symmetric 3-by-3 matrix. The default matrix is dominated by the diagonal elements and especially by the tau tau one."},{"name":"int ParticleData::nextId(int id)","link":"ParticleDataScheme.html#anchor26","text":"return the identity code of the sequentially next particle stored in table."},{"name":"SpaceShower:ecmPow","link":"SpacelikeShowers.html#anchor15","text":"The ecmPow energy rescaling pace introduced above."},{"name":"PDF:PomRescale","link":"PDFSelection.html#anchor16","text":"Rescale the four H1 fits above by this uniform factor, e.g. to bring up their momentum sum to around unity. By default all three have a momentum sum of order 0.5, suggesting that a factor around 2.0 should be used. You can use examples/main51.cc to get a more precise value. Note that also other parameters in the diffraction framework may need to be retuned when this parameter is changed. Specifically Diffraction:PomFluxRescale should be set to the inverse of PDF:PomRescale to preserve the cross section for hard diffractive processes."},{"name":"void CoupSM::init(SettingsAMPERSAND settings, Rndm* rndmPtr)","link":"StandardModelParameters.html#anchor17","text":"this is where the AlphaStrong and AlphaEM instances are initialized, and weak couplings and the quark mixing matrix are read in and set. This is based on the values stored on this page and among the Couplings and Scales. Internal."},{"name":"SoftQCD:singleDiffractive","link":"QCDProcesses.html#anchor4","text":"Single diffractive scattering A B &rarr; X B and A B &rarr; A X. See page on Diffraction for details. Codes 103 and 104."},{"name":"double ParticleData::resWidthStore(int id, double mHat,  int idInFlav = 0)","link":"ParticleDataScheme.html#anchor84","text":"special case of resWidth , where only open channels are included, and results are stored in the normal decay table."},{"name":"Vec4 CellJet::pMassive(int i)","link":"EventAnalysis.html#anchor38","text":"gives a Vec4 corresponding to the four-momentum defined by the sum of all the contributing cells to the i 'th jet, where each cell contributes a four-momentum as if all the eT is deposited in the center of the cell,"},{"name":"double Info::thetaHat()","link":"EventInformation.html#anchor59","text":""},{"name":"Total Cross Sections","link":"TotalCrossSections.html","text":"Total Cross Sections The SigmaTotal class returns the total, elastic, diffractive and nondiffractive cross sections in hadronic collisions, and also the slopes of the d(sigma)/dt distributions. Most of the parametrizations used are from Sch94, Sch97 which borrows some of the total cross sections from Don92. If you use the MBR (Minimum Bias Rockefeller) model Cie12 , Diffraction:PomFlux = 5 , this model contains its own parametrizations of all cross sections in p p and pbar p collisions. There are strong indications that the currently implemented diffractive cross section parametrizations, which should be in reasonable agreement with data at lower energies, overestimate the diffractive rate at larger values. If you wish to explore this (or other) aspect, it is possible to override the cross section values in two different ways. The first offers (almost) complete freedom, but needs to be defined separately for each CM energy, while the second introduces a simpler parametrized damping. The two cannot be combined. Furthermore the Coulomb term for elastic scattering, which by default is off, can be switched on. The allowed combinations of incoming particles are p + p , pbar + p , pi+ + p , pi- + p , pi0/rho0 + p , phi + p , J/psi + p , rho + rho , rho + phi , rho + J/psi , phi + phi , phi + J/psi , J/psi + J/psi. The strong emphasis on vector mesons is related to the description of gamma + p and gamma + gamma interactions in a Vector Dominance Model framework (which will not be available for some time to come, so this is a bit of overkill). Nevertheless, the sections below, with allowed variations, are mainly intended to make sense for p + p. Central diffraction Central diffraction (CD), a.k.a. double Pomeron exchange (DPE), was not part of the framework in Sch94. It has now been added for multiparticle states, i.e. excluding the resonance region below 1 GeV mass, as well as other exclusive states, but only for p p or pbar p. It uses the same proton-Pomeron vertex as in single diffraction, twice, to describe x_Pomeron and t spectra. This fixes the energy dependence, which has been integrated and parametrized. The absolute normalization has been left open, however. Furthermore, since CD has not been included in previous tunes to data, a special flag is available to reproduce the old behaviour (with due complications when one does not want to do this). Set cross sections When SigmaTotal:setOwn = on , the user is expected to set values for the corresponding cross sections: Note that the total cross section subtracted by the elastic and various diffractive ones gives the inelastic nondiffractive cross section, which therefore is not set separately. If this cross section evaluates to be negative the internal parametrizations are used instead of the ones here. However, since the nondiffractive inelastic cross section is what makes up the minimum-bias event class, and plays a major role in the description of multiparton interactions, it is important that a consistent set is used. Modify diffractive cross sections The default description of diffractive interactions was parameterized and fit in Sch94, Sch97. The following parameters allow for some modification of the mass distribution of the diffractive system, which then integrates to a modified diffractive cross section. Note that these parameters have no effect on the MBR model. Dampen diffractive cross sections As already noted, unitarization effects may dampen the rise of diffractive cross sections relative to the default parametrizations. The settings here allows one way to introduce a dampening, which is used in some of the existing tunes. When SigmaDiffractive:dampen = on , the three diffractive cross sections are damped so that they never can exceed the respective values below. Specifically, if the standard parametrization gives the cross section sigma_old(s) and a fixed sigma_max is set, the actual cross section becomes sigma_new(s) = sigma_old(s) * sigma_max / (sigma_old(s) + sigma_max). This reduces to sigma_old(s) at low energies and to sigma_max at high ones. Note that the asymptotic value is approached quite slowly, however. As above, a reduced diffractive cross section automatically translates into an increased nondiffractive one, such that the total (and elastic) cross section remains fixed. Set elastic cross section In the above option the t slopes are based on the internal parametrizations. In addition there is no Coulomb-term contribution to the elastic (or total) cross section, which of course becomes infinite if this contribution is included. If you have switched on SigmaTotal:setOwn you can further switch on a machinery to include the Coulomb term, including interference with the conventional strong-interaction Pomeron one Ber87. Then the elastic cross section is no longer taken from SigmaTotal:sigmaEl but derived from the parameters below and SigmaTotal:sigmaTot , using the optical theorem. The machinery is only intended to be used for p p and pbar p collisions. The description of diffractive events, and especially their slopes, remains unchanged."},{"name":"HiggsBSM:qqbar2A3g(l:t)","link":"HiggsProcesses.html#anchor80","text":"Scattering q qbar &rarr; A^0 g via an s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from g g &rarr; A^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1056."},{"name":"double ParticleDataEntry::m0Min()","link":"ParticleDataScheme.html#anchor118","text":"similar to mMin() above, except that for particles with no width the m0(id) value is returned."},{"name":"double LHAup::scale()","link":"LesHouchesAccord.html#anchor35","text":""},{"name":"double Info::pdf2()","link":"EventInformation.html#anchor43","text":"parton densities x*f(x,Q^2) evaluated for the two incoming partons; could be used e.g. for reweighting purposes in conjunction with the idpdf , xpdf and QFac methods. Events obtained from external programs or files may not contain this information and, if so, 0 is returned."},{"name":"ExtraDimensionsG*:VLVL","link":"ExtraDimensionalProcesses.html#anchor9","text":"Parameter to specify Z/W coupling scenario: off , usual Z/W boson couplings; on , coupling only to longitudinal Z/W bosons. In both cases the GZZ and GWW values are used and this parameter is only relevant when SMinBulk = on. The formulas for longitudinal bosons should be appropriate up to O(m_V/E_V) corrections."},{"name":"int CellJet::multiplicity(int i)","link":"EventAnalysis.html#anchor36","text":"gives the number of particles clustered into the i 'th jet,"},{"name":"double Info::a0MPI()","link":"EventInformation.html#anchor85","text":"The value of a0 when an x-dependent matter profile is used, MultipartonInteractions:bProfile = 4."},{"name":"HiddenValley:ffbar2CvCvbar","link":"HiddenValleyProcesses.html#anchor23","text":"Pair production f fbar &rarr; Cv Cvbar via intermediate gamma*/Z^*. Code 4924."},{"name":"Charmonium:gg2ccbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor37","text":"Colour-octet production of 3DJ charmonium states via g g &rarr; ccbar[3PJ(8)] g. Code 418."},{"name":"HadScatOld","link":"HadronScattering.html#anchor15","text":""},{"name":"vectorAMPERSANDlt;boolAMPERSANDgt; Settings::fvec(string key)","link":"SettingsScheme.html#anchor37","text":""},{"name":"void ResonanceWidths::calcWidth(bool calledFromInit = false)","link":"SemiInternalResonances.html#anchor3","text":"is the key method for width calculations and returns a partial width value, as further described below. It is called for a specific final state, typically in a loop over all allowed final states, subsequent to the calcPreFac(...) call above. Information on the final state is stored in a number of base-class variables, for you to use in your calculations: iChannel : the channel number in the list of possible decay channels; mult : the number of decay products; id1, id2, id3 : the identity code of up to the first three decay products, arranged in descending order of the absolute value of the identity code; id1Abs, id2Abs, id3Abs : the absolute value of the above three identity codes; mHat : the current resonance mass, which is the same as in the latest calcPreFac(...) call; mf1, mf2, mf3 : masses of the above decay products; mr1, mr2, mr3 : squared ratio of the product masses to the resonance mass; ps : is only meaningful for two-body decays, where it gives the phase-space factor ps = sqrt( (1. - mr1 - mr2)^2 - 4. * mr1 * mr2 ) ; In two-body decays the third slot is zero for the above properties. Should there be more than three particles in the decay, you would have to take care of the subsequent products yourself, e.g. using particlePtr->decay[iChannel].product(j); to extract the j 'th decay products (with j = 0 for the first, etc.). Currently we are not aware of any such examples. The base class also contains methods for alpha_em and alpha_strong evaluation, and can access many standard-model couplings; see the existing code for examples. The result of your calculation should be stored in widNow : the partial width of the current channel, expressed in GeV."},{"name":"TimeShower:weakShowerMode","link":"TimelikeShowers.html#anchor29","text":"Determine which branchings are allowed. both W^+- and Z^0 branchings. only W^+- branchings. only Z^0 branchings."},{"name":"string Particle::name()","link":"ParticleProperties.html#anchor63","text":"the name of the particle."},{"name":"Wprime:aq","link":"NewGaugeBosonProcesses.html#anchor41","text":"axial coupling of quarks."},{"name":"ParticleData:msRun","link":"ParticleData.html#anchor5","text":"the s quark MSbar mass at 2 GeV scale."},{"name":"double LHAup::weight()","link":"LesHouchesAccord.html#anchor34","text":". Note that the weight stored in Info::weight() as a rule is not the same as the above weight() : the method here gives the value before unweighting while the one in info gives the one after unweighting and thus normally is 1 or -1. Only with strategy options +-3 and +-4 would the value in info be the same as here, except for a conversion from pb to mb for +-4."},{"name":"Check:mTolErr","link":"ErrorChecks.html#anchor9","text":"For each particle the maximum allowed deviation between the mass calculated from energy-momentum and the bookkept mass, as a fraction of the energy. This energy is taken to be at least 1 GeV, in order to avoid harmless problems at very low energies (gluons mainly)."},{"name":"void Info::setHeader(string key, string val)","link":"EventInformation.html#anchor132","text":"set the header named key with the contents of val"},{"name":"Charmonium:qqbar2ccbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor32","text":"Colour-octet production of 3PJ charmonium states via q qbar &rarr; ccbar[3S1(8)] g. Code 416."},{"name":"bool Particle::isQuark()","link":"ParticleProperties.html#anchor84","text":"true for a quark or an antiquark."},{"name":"PromptPhoton:ffbar2gammagamma","link":"ElectroweakProcesses.html#anchor5","text":"Scattering q qbar &rarr; gamma gamma. Code 204."},{"name":"Wprime:al","link":"NewGaugeBosonProcesses.html#anchor43","text":"axial coupling of leptons."},{"name":"Charmonium:qqbar2doubleccbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor45","text":"Colour-singlet production of 3S1 charmonium state pairs via q qbar &rarr; ccbar[3S1(1)] ccbar[3S1(1)]. Code 422."},{"name":"double Particle::scale()","link":"ParticleProperties.html#anchor15","text":"the scale at which a parton was produced, which can be used to restrict its radiation to lower scales in subsequent steps of the shower evolution. Note that scale is linear in momenta, not quadratic (i.e. Q , not Q^2 )."},{"name":"StringFlav:probSQtoQQ","link":"FlavourSelection.html#anchor3","text":"the suppression of strange diquark production relative to light diquark production, over and above the one already given by probStoU."},{"name":"virtual void SpaceShower::update( int iSys, EventAMPERSAND event,  bool hasWeakRad = false)","link":"ImplementNewShowers.html#anchor34","text":"This method is called immediately after a timelike branching in the iSys 'th subsystem. Thus the information for that system may be out-of-date, and to be updated. For the standard PYTHIA showers this routine does not need to do anything, but that may be different in another implementation. The optional final argument is used to signal if a weak radiation has occured in the timelike evolution, which might be used to switch off the spacelike weak emissions."},{"name":"Beams:allowMomentumSpread","link":"BeamParameters.html#anchor20","text":"Allow the beam momenta to be smeared around their initialization nominal values."},{"name":"Next:showScaleAndVertex","link":"MainProgramSettings.html#anchor14","text":"In addition to the normal information in the listing of the process and event records, a second line per particle provides information on the production scale, particle polarization and production vertex."},{"name":"HiggsH2:phiParity","link":"HiggsProcesses.html#anchor116","text":"The phi value of CP-mixing in the HiggsH2:parity = 4 option."},{"name":"void Vec4::bst(const Vec4AMPERSAND p)","link":"FourVectors.html#anchor68","text":"boost the four-momentum by beta = (p_x/E, p_y/E, p_z/E)."},{"name":"HiddenValley:probVector","link":"HiddenValleyProcesses.html#anchor40","text":"fraction of HV-mesons that are assigned spin 1 (vector), with the remainder spin 0 (pseudoscalar). Assuming the qv have spin 1/2 and the mass splitting is small, spin counting predicts that 3/4 of the mesons should have spin 1."},{"name":"void Particle::rescale3(double fac)","link":"ParticleProperties.html#anchor103","text":"multiply the three-momentum components by fac."},{"name":"virtual bool MyMergingHooks::doVetoStep( const EventAMPERSAND event)","link":"MatchingAndMerging.html#anchor13","text":"This function will be used to implement the check if shower emissions should be discarded, as e.g. necessary in UMEPS or UNLOPS merging. You can study the input event event after emission, and return true if the emission is valid, and false if you want to reject the emission. Note that this veto does not lead to event rejections, only in potentially removing certain emissions during shower evolution."},{"name":"HiddenValley:gg2TvTvbar","link":"HiddenValleyProcesses.html#anchor13","text":"Pair production g g &rarr; Tv Tvbar. Code 4906."},{"name":"PDFinProcess:nQuarkIn","link":"PDFSelection.html#anchor22","text":"Number of allowed incoming quark flavours in the beams; a change to 4 would thus exclude b and bbar as incoming partons, etc."},{"name":"HadronScatter:p","link":"HadronScattering.html#anchor22","text":"p parameter as above."},{"name":"HadronScatter:k","link":"HadronScattering.html#anchor21","text":"k parameter as above."},{"name":"HadronScatter:j","link":"HadronScattering.html#anchor24","text":"j parameter as above."},{"name":"void Settings::mvec(string key, vectorAMPERSANDlt;intAMPERSANDgt; now,  bool force = false)","link":"SettingsScheme.html#anchor62","text":""},{"name":"void SpaceShower::initPtr(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  Rndm* rndmPtrIn, CoupSM* coupSMPtrIn, PartonSystems* partonSystemsPtrIn,  UserHooks* userHooksPtrIn, MergingHooks* mergingHooksPtrIn = 0)","link":"ImplementNewShowers.html#anchor29","text":"This method only imports pointers to standard facilities, and is not virtual."},{"name":"Main:numberOfSubruns","link":"MainProgramSettings.html#anchor27","text":"The number of subruns you intend to use in your current run. Unlike the two settings above, Pythia itself will not interpret this number, but you could e.g. have a loop in your main program to loop over subruns from 0 through numberOfSubruns - 1."},{"name":"ParticleDecays:multIncreaseWeak","link":"ParticleDecays.html#anchor21","text":"The above multIncrease parameter, specifically for meMode = 23. Here the weak decay implies that only the virtual W mass should contribute to the production of new particles, rather than the full meson mass."},{"name":"Diffraction:probMaxPert","link":"Diffraction.html#anchor20","text":"The abovementioned maximum probability P_max.. Would normally be assumed to be unity, but a somewhat lower value could be used to represent a small nonperturbative component also at high diffractive masses."},{"name":"bool CellJet::analyze( const EventAMPERSAND event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5)","link":"EventAnalysis.html#anchor29","text":"performs a jet finding analysis, where is an object of the Event class, most likely the pythia.event one. is the minimum transverse energy inside a cone for this to be accepted as a jet. is the size of the cone in (eta, phi) space drawn around the geometric center of the jet. the minimum eT in a cell for this to be acceptable as the trial center of a jet. If the routine returns false the analysis failed, but currently this is not foreseen ever to happen."},{"name":"void Particle::bst(const Vec4AMPERSAND pBst)","link":"ParticleProperties.html#anchor109","text":"boost four-momentum and production vertex by beta = (px/e, py/e, pz/e)."},{"name":"double CellJet::etaCenter(int i)","link":"EventAnalysis.html#anchor32","text":""},{"name":"Charmonium:gg2ccbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor30","text":"Colour-octet production of 3PJ charmonium states via g g &rarr; ccbar[3S1(8)] g. Code 414."},{"name":"HadronScatter:N","link":"HadronScattering.html#anchor20","text":"N parameter as above."},{"name":"Merging:muFac","link":"NLOMerging.html#anchor2","text":"The fixed factorisation scale used in the hard process cross section, as needed to generate the leading-order weight, in case the factorisation scale cannot be inferred from Les Houches event input. (This is the case for files that have been generated with the POWHEG-BOX program, since this program prints the transverse momentum scale of the real emission into the LH events.). If the value is not set, the SCALUP variable of the current LH event will be used instead. If wimpy showers (see Timelike Showers and Spacelike Showers ) are used together with multi-jet merging, then this scale further sets the parton shower starting scale ( &mu; Q ) for the core hard process."},{"name":"bool Particle::mayDecay()","link":"ParticleProperties.html#anchor78","text":"flag whether particle has been declared unstable or not, offering the main user switch to select which particle species to decay."},{"name":"bool  JetMatchingMadgraph::getExclusive()","link":"JetMatching.html#anchor31","text":"Return flag to identify if exclusive or inclusive vetoes should be applied to this event."},{"name":"ExtraDimensionsG*:KKintMode","link":"ExtraDimensionalProcesses.html#anchor26","text":"Choice of full g^*/KK-gluon^* structure or not in relevant processes. full g^*/KK-gluon^* structure, with interference included. only pure gluon_{SM} contribution. only pure gluon_{KK} contribution."},{"name":"WeakBosonAndParton:qg2Wq","link":"ElectroweakProcesses.html#anchor28","text":"Scattering q g &rarr; W^+- q. Code 252."},{"name":"ParticleDecays:FSRinDecays","link":"ParticleDecays.html#anchor25","text":"When a particle decays to q qbar , g g , g g g or gamma g g , with meMode > 90 , allow or not a shower to develop from it, before the partonic system is hadronized. (The typical example is Upsilon decay.) In addition, some variables defined for string fragmentation and for flavour production are used also here."},{"name":"TimeShower:alphaEMorder","link":"TimelikeShowers.html#anchor9","text":"The running of alpha_em. first-order running, constrained to agree with StandardModel:alphaEMmZ at the Z^0 mass. zeroth order, i.e. alpha_em is kept fixed at its value at vanishing momentum transfer. zeroth order, i.e. alpha_em is kept fixed, but at StandardModel:alphaEMmZ , i.e. its value at the Z^0 mass."},{"name":"bool Pythia::LHAeventSkip(int nSkip)","link":"ProgramFlow.html#anchor29","text":"skip ahead a number of events in the Les Houches generation sequence, without doing anything further with them, see LHAup::skipEvent(nSkip). Mainly intended for debug purposes, e.g. when an event at a known location in a Les Houches Event File is causing problems. number of events to skip. Note: The method returns false if the operation fails, specifically if the end of a LHEF has been reached, cf. next() above."},{"name":"PhaseSpace:pTHatMaxSecond","link":"PhaseSpaceCuts.html#anchor18","text":"The maximum invariant pT for a second interaction, if separate. A value below pTHatMin means there is no upper limit."},{"name":"void ParticleDataEntry::setDoForceWidth(bool  doForceWidth)","link":"ParticleDataScheme.html#anchor130","text":""},{"name":"HadronScatter:minProbSS","link":"HadronScattering.html#anchor13","text":"The minimum probability P min SS for the  scattering of two hadrons within the same string. (Relative to that for  different strings, i.e. for the total probability the baseline maxProbDS factor also enters.)"},{"name":"Bottomonium:gg2bbbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor74","text":"Colour-octet production of 3DJ bottomonium states via g g &rarr; bbbar[3PJ(8)] g. Code 518."},{"name":"int MergingHooks::nResInCurrent()","link":"CKKWLMerging.html#anchor23","text":"The number of resonances in the hard process reconstructed from the current event. If e.g. the ME configuration was pp &rarr; (w+&rarr;e+ve)(z &rarr; mu+mu-)jj , and the ME generator put both intermediate bosons into the LHE file, this will return 2."},{"name":"Merging:includeMassive","link":"CKKWLMerging.html#anchor33","text":"If on, use the correct massive evolution variable and massive splitting kernels in the reconstruction and picking of parton shower histories of the matrix  element. If off, reconstruct evolution scales, kinematics and splitting kernels  as if all partons were massless."},{"name":"HadronScatter:tile","link":"HadronScattering.html#anchor26","text":"Use tiling in (eta, phi) to reduce number of pairwise tests."},{"name":"void UserHooks::subEvent(const EventAMPERSAND event,  bool isHardest = true)","link":"UserHooks.html#anchor5","text":"is a protected method that you can make use of in your own methods to extract a brief list of the current partons of interest, with all irrelevant ones omitted. It is primarily intended to track the evolution at the parton level, notably the shower evolution of the hardest (i.e. first) interaction. For the default isHardest = true only the outgoing partons from the hardest interaction (including the partons added to it by ISR and FSR) are extracted, as relevant e.g. for doVetoPT( iPos, event) with iPos = 0 - 4. With isHardest = false instead the outgoing partons of the latest 'subprocess' are extracted, as relevant when iPos = 5 , where it corresponds to the outgoing partons in the currently considered decay. The method also works at the process level, but there simply extracts all final-state partons in the event, and thus offers no extra functionality. The result is stored in workEvent below. Since the history has been removed, mother1() and mother2() return 0, while daughter1() and daughter2() both return the index of the same parton in the original event record ( event ; possibly process ), so that you can trace the full history, if of interest."},{"name":"WeakSingleBoson:ffbar2W","link":"ElectroweakProcesses.html#anchor14","text":"Scattering f fbar' &rarr; W^+-. Code 222."},{"name":"LeptoQuark:qqbar2LQLQbar","link":"LeptoquarkProcesses.html#anchor5","text":"Scatterings q qbar &rarr; LQ LQbar. Code 3204."},{"name":"ExtraDimensionsG*:gg2G*","link":"ExtraDimensionalProcesses.html#anchor2","text":"Scatterings g g &rarr; G^*. Code 5001."},{"name":"void Particle::p(double px, double py, double pz, double e)","link":"ParticleProperties.html#anchor29","text":"sets the four-momentum components in one go."},{"name":"ParticleAMPERSAND Event::front()","link":"EventRecord.html#anchor3","text":""},{"name":"Event JetMatchingMadgraph::getProcessSubset()","link":"JetMatching.html#anchor30","text":"Return the event record containing the hard process, without resonance decay products and particles that should not be included in the jet matching, as necessary to implement the vetoes in the shower-kT and kT-MLM schemes. In the former, this event is needed to find the lowest pT in the ME inputs. In the latter, the event record is used to count the number of hard-process partons, minimal hard process pT, and to perform the matching of hard-process particles to shower jets."},{"name":"JetMatching:eTseed","link":"JetMatching.html#anchor8","text":"Specific to the CellJet algorithm, the minimum eT for a cell to be acceptable as the trial center of a jet."},{"name":"int SigmaProcess::id5Mass()","link":"SemiInternalProcesses.html#anchor19","text":"are the one, two or three final-state flavours, where masses are to be selected before the matrix elements are evaluated. Only the absolute value should be given. For massless particles, like gluons and photons, one need not give anything, i.e. one defaults to 0. The same goes for normal light quarks, where masses presumably are not implemented in the matrix elements. Later on, these quarks can still (automatically) obtain constituent masses, once a u , d or s flavour has been selected."},{"name":"SigmaProcess:renormFixScale","link":"CouplingsAndScales.html#anchor10","text":"A fix Q^2 value used as renormalization scale for 2 &rarr; 1 , 2 &rarr; 2 and 2 &rarr; 3 processes in some of the options above."},{"name":"void Info::hasHistory(bool hasHistoryIn)","link":"EventInformation.html#anchor108","text":""},{"name":"mapAMPERSANDlt;string, FlagAMPERSANDgt; Settings::getFlagMap(string match)","link":"SettingsScheme.html#anchor49","text":""},{"name":"virtual Event SpaceShower::clustered( const EventAMPERSAND event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor42","text":"This function should return a PYTHIA event record in which the emission of the particle with index iEmt in the input event (also changing the particles with index iRad and iRec ) is undone. name is a string identifier for the splitting. Such reclustered events are crucial in setting up consistent parton shower histories."},{"name":"ParticleData:mdRun","link":"ParticleData.html#anchor3","text":"the d quark MSbar mass at 2 GeV scale."},{"name":"StringFlav:probQQtoQ","link":"FlavourSelection.html#anchor2","text":"the suppression of diquark production relative to quark production, i.e. of baryon relative to meson production."},{"name":"Hidden Valley Processes","link":"HiddenValleyProcesses.html","text":"Hidden Valley Processes This Hidden Valley (HV) scenario has been developed specifically to allow the study of visible consequences of radiation in a hidden sector, by recoil effect. A key aspect is therefore that the normal timelike showering machinery has been expanded with a third kind of radiation, in addition to the QCD and QED ones. These three kinds of radiation are fully interleaved, i.e. evolution occurs in a common pT -ordered sequence. The scenario is described in Car10. Furthermore hadronization in the hidden sector has been implemented. Three main scenarios for production into and decay out of the hidden sector can be compared, in each case either for an Abelian or a non-Abelian gauge group in the HV. For further details see Car11. Warning : do not use the alternative hadronization scenarios StringPT:thermalModel = on or StringPT:mT2suppression = on in conjunction with Hidden Valley processes, since they have not been constructed to work together. Particle content and properties For simplicity we assume that the HV contains an unbroken SU(N) gauge symmetry. This is used in the calculation of production cross sections. These could be rescaled by hand for other gauge groups. A minimal HV particle content has been introduced. Firstly, there is a set of 12 particles that mirrors the Standard Model flavour structure, and is charged under both the SM and the HV symmetry groups. Each new particle couples flavour-diagonally to a corresponding SM state, and has the same SM charge and colour, but in addition is in the fundamental representation of the HV colour, as follows: Dv , identity 4900001, partner to the normal d quark; Uv , identity 4900002, partner to the normal u quark; Sv , identity 4900003, partner to the normal s quark; Cv , identity 4900004, partner to the normal c quark; Bv , identity 4900005, partner to the normal b quark; Tv , identity 4900006, partner to the normal t quark; Ev , identity 4900011, partner to the normal e lepton; nuEv , identity 4900012, partner to the normal nue neutrino; MUv , identity 4900013, partner to the normal mu lepton; nuMUv , identity 4900014, partner to the normal numu neutrino; TAUv , identity 4900015, partner to the normal tau lepton; nuTAUv , identity 4900016, partner to the normal nutau neutrino. Collectively we will refer to these states as Fv ; note, however, that they need not be fermions themselves. In addition the model contains the HV gauge particle, either a HV-gluon or a HV-photon, but not both; see Ngauge above: gv , identity 4900021, is the massless gauge boson of the HV SU(N) group; gammav , identity 4900022,  is the massless gauge boson of the HV U(1) group. Finally, for the basic HV scenario, there is a new massive particle with only HV charge sitting in the fundamental representation of the HV gauge group: qv , identity 4900101. The typical scenario would be for pair production of one of the states presented first above, e.g. g g &rarr; Dv Dvbar. Such a Dv can radiate gluons and photons like an SM quark, but in addition HV-gluons or HV-photons in a similar fashion. Eventually the Dv will decay like Dv &rarr; d + qv. The strength of this decay is not set as such, but is implicit in your choice of width for the Dv state. Thereafter the d and qv can radiate further within their respective sectors. The qv , gv or gammav are invisible, so their fate need not be considered further. While not part of the standard scenario, as an alternative there is also a kind of Z' resonance: Zv , identity 4900023, a boson that can couple both to pairs of Standard Model fermions and to qv qvbar pairs. Mass, total width and branching ratios can be set as convenient. This opens up for alternative processes l^+l^-, q qbar &rarr; Zv &rarr; qv qvbar. The possibility of a leakage back from the hidden sector will be considered in the Hadronization section below. For the U(1) case the gammav acquires a mass and can decay back to a Standard-Model fermion pair, while the qv remains invisible. The SU(N) alternative remains unbroken, so confinement holds and the gv is massless. A string like qv - gv - ... - gv - qvbar can break by the production of new qv - qvbar pairs, which will produce qv-qvbar mesons. It would be possible to build a rather sophisticated hidden sector by trivial extensions of the HV flavour content. For now, however, the qv can be duplicated in up to eight copies with the same properties except for the flavour charge. These are assigned codes 4900101 - 4900108. This gives a total of 64 possible lowest-lying mesons. We also include a duplication of that, into two multiplets, corresponding to the pseudoscalar and vector mesons of QCD. For now, again, these are assumed to have the same mass and other properties. By default, only the flavour-diagonal ones can decay back into the Standard-Model sector, however, while the rest remains in the hidden sector. It is therefore only necessary to distinguish a few states: pivDiag , identity 4900111, a flavour-diagonal HV-meson with spin 0 that can decay back into the Standard-Model sector; rhovDiag , identity 4900113, a flavour-diagonal HV-meson with spin 1 that can decay back into the Standard-Model sector; pivUp , identity 4900211, an off-diagonal HV-meson with spin 0 that is stable and invisible, with an antiparticle pivDn with identity -4900211; the particle is the one where the code of the flavour is larger than that of the antiflavour; rhovUp , identity 4900213, an off-diagonal HV-meson with spin 1 that is stable and invisible, with an antiparticle rhovDn with identity -4900213; again the particle is the one where the code of the flavour is larger than that of the antiflavour; ggv , identity 4900991, is only rarely used, to handle cases where it is kinematically impossible to produce an HV-meson on shell, and it therefore is assumed to de-excite by the emission of invisible gv-gv v-glueball bound states. By changing ParticleData, it is possible to allow decays even for the off-diagonal Up/Dn mesons. Only the spin of the HV-gluon or HV-photon is determined unambiguously to be unity, for the others you can make your choice. You should set the Fv and qv masses appropriately, with the latter smaller than the former two to allow decays. When U(1) hadronization is switched on, you need to set the gammav mass and decay modes. For SU(N) hadronization the HV-meson masses should be set to match the qv ones. The simplest is to assume that m_qv defines a constituent mass, so that m_HVmeson = 2 m_qv. The hvMesonDiag decay modes also need to be set. Production processes Timelike showers One key point of this HV scenario is that radiation off the HV-charged particles is allowed. This is done by the standard final-state showering machinery. (HV particles are not produced in initial-state radiation.) All the (anti)particles Fv and qv have one (negative) unit of HV charge. That is, radiation closely mimics the one in QCD. Both QCD, QED and HV radiation are interleaved in one common sequence of decreasing emission pT scales. Each radiation kind defines a set of dipoles, usually spanned between a radiating parton and its recoil partner, such that the invariant mass of the pair is not changed when a radiation occurs. This need not follow from trivial colour assignments, but is often obvious. For instance,  in a decay Qv &rarr; q + qv the QCD dipole is between the q and the hole after Qv , but qv becomes the recoiler should a radiation occur, while the role of q and qv is reversed for HV radiation. This also includes matrix-element corrections for a number of decay processes, with colour, spin and mass effects included Nor01. They were calculated within the context of the particle content of the MSSM, however, which does not include spin 1 particles with unit colour charge. In such cases spin 0 is assumed instead. By experience, the main effects come from mass and colour flow anyway, so this is not a bad approximation. (Furthermore the MSSM formulae allow for gamma_5 factors from wave functions or vertices; these are even less important.) An emitted gv can branch in its turn, gv &rarr; gv + gv. This radiation may affect momenta in the visible sector by recoil effect, but this is a minor effect relative to the primary emission of the gv. While the default model has a fixed Hidden Valley coupling alpha_HV , some further work Scw15 has considered the impact of a running coupling. This is included as an option. Hadronization By default the HV particles with no Standard Model couplings are not visible. Their presence can only be deduced by the observation of missing (transverse) momentum in the event as a whole. In the current implementation it is possible to simulate two different scenarios where activity can leak back from the hidden sector. The first possibility is relevant for the U(1) scenario. The U(1) group may be broken, so that the gammav acquires a mass. Furthermore, the gammav may have a small mixing angle with the normal photon, or with some Z' state or other mediator, and may thus decay back into Standard Model particles. The qv still escapes undetected; recall that there is no confinement in the U(1) option. In order to enable this machinery two commands are necessary, 4900022:m0 = ... to set the gammav mass to the desired value, and 4900022:onMode = on to enable gammav decays. The default gammav decay table contains all Standard Model fermion-antifermion pairs, except top, with branching ratios in proportion to their coupling to the photon, whenever the production channel is allowed by kinematics. This table could easily be tailored to more specific models and needs. For instance, for a mass below 1 - 2 GeV, it would make sense to construct a table of exclusive hadronic decay channels rather than go the way via a hadronizing quark pair. The gammav are expected to decay so rapidly that no secondary vertex will be detectable. However, it is possible to set 4900022:tau0 to a finite lifetime (in mm) that will be used to create separated secondary vertices. The second, more interesting, possibility is relevant for the SU(N) scenarios. Here the gauge group remains unbroken, i.e. gv is massless, and the partons are confined. Like in QCD, the HV-partons can therefore be arranged in one single HV-colour-ordered chain, with a qv in one end, a qvbar in the other, and a varying number of gv in between. Each event will only contain (at most) one such string, (i) since perturbative branchings gv &rarr; qv qvbar have been neglected, as is a reasonable approximation for QCD, and (ii) since HV-colours are assigned in the N_C &rarr; infinity limit, just like in the handling of string fragmentation in QCD. The HV-string can then fragment by the nonperturbative creation of qv qvbar pairs, leading to the formation of HV-mesons along the string, each with its qv from one vertex and its qvbar from the neighbouring one. Since, so far, we have only assumed there to be one qv species, all produced qv qvbar HV-mesons are of the same flavour-diagonal species. Such an HV-meson can decay back to the normal sector, typically by whatever mediator particle allowed production in the first place. In this framework the full energy put into the HV sector will leak back to the normal one. To allow more flexibility, an ad hoc possibility of n_Flav different qv species is introduced. For now they are all assumed to have the same mass and other properties, but distinguished by some flavour-like property. Only the flavour-diagonal ones can decay, meaning that only a fraction (approximately) 1/n_Flav of the HV-energy leaks back, while the rest remains in the hidden sector. This scenario contains more parameters than the first one, for the U(1) group. They can be subdivided into two sets. One is related to particle properties, both for qv and for the two different kinds of HV-mesons, here labeled 4900111 and 4900113 for the diagonal ones, and +-4900211 and +-4900213 for the off-diagonal ones. It makes sense to set the HV-meson masses to be twice the qv one, as in a simple constituent mass context. Furthermore the hvMesonDiag decay modes need to be set up. Like with the gammav in the U(1) option, the default decay table is based on the branching ratios of an off-shell photon. The second set are fragmentation parameters that extend or replace the ones used in normal string fragmentation. Some of them are not encoded in the same way as normally, however, but rather scale as the qv mass is changed, so as to keep a sensible default behaviour. This does not mean that deviations from this set should not be explored, or that other scaling rules could be preferred within alternative scenarios. These parameters are as follows."},{"name":"Bottomonium:qg2bbbar(3S1)[1S0(8)]q","link":"OniaProcesses.html#anchor56","text":"Colour-octet production of 3S1 bottomonium states via q g &rarr; bbbar[1S0(8)] q. Code 506."},{"name":"bool SigmaProcess::convert2mb()","link":"SemiInternalProcesses.html#anchor15","text":"it is assumed that cross sections normally come in dimensions such that they, when integrated over the relevant phase space, obtain the dimension GeV^-2, and therefore need to be converted to mb. If the cross section is already encoded as mb then convert2mb() should be overloaded to instead return false."},{"name":"StringFlav:thetaL1S0J1","link":"FlavourSelection.html#anchor30","text":"gives the mixing angle theta in the (L=1,S=0,J=1) pseudovector meson sector, expressed in degrees."},{"name":"WeakShower:enhancement","link":"WeakShowers.html#anchor1","text":"Enhancement factor for the weak shower. This is used to increase the statistics of weak shower emissions. Remember afterwards to correct for the additional weak emissions (i.e. divide the rate of weak emissions by the same factor)."},{"name":"Zprime:amu","link":"NewGaugeBosonProcesses.html#anchor17","text":"axial coupling of mu leptons."},{"name":"void Vec4::bst(const Vec4AMPERSAND p, double m)","link":"FourVectors.html#anchor69","text":"boost the four-momentum by beta = (p_x/E, p_y/E, p_z/E) , where the gamma = E/m is also calculated from input to allow better precision when beta is close to unity."},{"name":"void ParticleDataEntry::setNames(string name,  string antiName)","link":"ParticleDataScheme.html#anchor101","text":""},{"name":"ExtraDimensionsLED:qq2DJqq","link":"ExtraDimensionalProcesses.html#anchor56","text":"Scatterings q q(bar)' &rarr; (LED G*) &rarr; q q(bar)'. Including q and qbar of same or different flavours, but the outgoing flavours equals the incoming ones. Code 5033."},{"name":"void Pythia8ToHepMC::set_convert_gluon_to_0(bool b = false)","link":"HepMCInterface.html#anchor9","text":""},{"name":"double Info::mergingWeight()","link":"EventInformation.html#anchor83","text":"combined leading-order merging weight assigned to the current event, if tree-level multi-jet merging (i.e. CKKW-L or UMEPS merging) is attempted. If tree-level multi-jet merging is performed, all histograms should be filled with this weight, as discussed in CKKW-L Merging and UMEPS Merging."},{"name":"UncertaintyBands:MPIshowers","link":"Variations.html#anchor4","text":"Flag specifying whether the automated shower variations include showers off MPI systems or not. Note that substantially larger weight fluctuations must be expected when including shower variations for MPI, due to the (many) more systems which then enter in the reweightings."},{"name":"void Particle::rotbst(const RotBstMatrixAMPERSAND M)","link":"ParticleProperties.html#anchor113","text":"combined rotation and boost of the four-momentum and production vertex."},{"name":"PromptPhoton:gg2gammagamma","link":"ElectroweakProcesses.html#anchor6","text":"Scattering g g &rarr; gamma gamma. Note: This is a box graph. The full quark-mass dependence in the loop leads to very complicated expressions. The current implementation is based on assuming five massless quarks (see below), and thus is questionable at small ( pT < m_b ) or large ( pT > m_t ) transverse momenta. Code 205."},{"name":"Diffraction:coreFraction","link":"Diffraction.html#anchor30","text":"When assuming a double Gaussian matter profile, bProfile = 2 , the inner core is assumed to have a fraction coreFraction of the matter content of the hadron."},{"name":"virtual bool UserHooks::doVetoProcessLevel(EventAMPERSAND process)","link":"UserHooks.html#anchor9","text":"can optionally be called, as described above. You can study the process event record of the hard process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of Pythia::next(). Warning: Normally you should not modify the process event record. However, for some matrix-element-matching procedures it may become unavoidable. If so, be very careful, since there are many pitfalls. Only to give one example: if you modify the incoming partons then also the information stored in the beam particles may need to be modified. Note: the above veto is different from setting the flag PartonLevel:all = off. Also in the latter case the event generation will stop after the process level, but an event generated up to this point is considered perfectly acceptable. It can be studied and it contributes to the cross section. That is, PartonLevel:all = off is intended for simple studies of hard processes, where one can save a lot of time by not generating the rest of the story. By contrast, the doVetoProcessLevel() method allows you to throw away uninteresting events at an early stage to save time, but those events that do survive the veto are allowed to develop into complete final states (unless flags have been set otherwise)."},{"name":"Higgs:cubicWidth","link":"HiggsProcesses.html#anchor1","text":"The partial width of a Higgs particle to a pair of gauge bosons, W^+ W^- or Z^0 Z^0 , depends cubically on the Higgs mass. When selecting the Higgs according to a Breit-Wigner, so that the actual mass mHat does not agree with the nominal m_Higgs one, an ambiguity arises which of the two to use Sey95. The default is to use a linear dependence on mHat , i.e. a width proportional to m_Higgs^2 * mHat , while on gives a mHat^3 dependence. This does not affect the widths to fermions, which only depend linearly on mHat. This flag is used both for SM and BSM Higgs bosons."},{"name":"SUSY:qqbar2squarkantisquark","link":"SUSYProcesses.html#anchor11","text":"Pair production of a scalar quark together with a scalar antiquark by quark-antiquark annihilation. For same-isospin ~q~q* production (i.e., ~u~u* , ~u~c* , ...), the s -channel gluon, photon, and Z and t -channel gluino contributions have so far been implemented (i.e., the t -channel neutralino contributions are neglected). For opposite-isospin ~q~q* production ( ~u~d* , ~u~s* , ...), the s -channel W and t -channel gluino contributions have been implemented (i.e., the t -channel neutralino contributions are neglected). The cross section expressions follow Boz07. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: in older PYTHIA 6 versions, a bug caused the ~t1~t2* cross to be overcounted by a factor of 2. Starting from version 6.4.24, that generator now agrees with the implementation here.)"},{"name":"virtual bool TimeShower::rescatterPropogateRecoil(  EventAMPERSAND event, Vec4AMPERSAND pNew)","link":"ImplementNewShowers.html#anchor16","text":"This method is only called if rescattering is switched on in the description of multiparton interactions. It then propagates a recoil from a timelike branching to internal lines that connect systems. As for rescatterUpdate above, this is not likely to be of interest to most implementors of new showers."},{"name":"Alpgen:setLightMasses","link":"AlpgenEventInterface.html#anchor2","text":"When switched on, c and b quark masses provided by ALPGEN are set in the PYTHIA particle database. Since ALPGEN may set these two masses to vanish, the parton shower programs have been provided with some protection, but other parts of the code may not be as fortunate. You should therefore only switch on this option if you know what you are doing."},{"name":"The Event Record","link":"EventRecord.html","text":"The Event Record A Pythia instance contains two members of the Event class. The one called process provides a brief summary of the main steps of the hard process, while the one called event contains the full history. The user would normally interact mainly with the second one, so we will exemplify primarily with that one. The Event class to first approximation is a vector of Particle s, so that it can expand to fit the current event size. The index operator is overloaded, so that e.g. event[i] corresponds to the i 'th particle of the object event. Thus event[i].id() returns the identity of the i 'th particle, and so on. Therefore the methods of the Particle class are at least as essential as those of the Event class itself. As used inside PYTHIA, some conventions are imposed on the structure of the event record. Entry 0 of the vector<Particle> is used to represent the event as a whole, with its total four-momentum and invariant mass, but does not form part of the event history. Lines 1 and 2 contains the two incoming beams, and only from here on history tracing works as could be expected. That way unassigned mother and daughter indices can be put 0 without ambiguity. Depending on the task at hand, a loop may therefore start at index 1 rather than 0 without any loss. Specifically, for translation to other event record formats such as HepMC Dob01 , where the first index is 1, the Pythia entry 0 definitely ought to be skipped in order to minimize the danger of indexing errors. In the following we will list the methods available. Only a few of them have a function to fill in normal user code. Basic output methods Some methods are available to read out information on the current event record: i 'th or last particle in the event record, as an alternative to the methods above. Further output methods Many event properties are accessible via the Info class, see here. Since they are used directly in the event generation, a few are stored directly in the Event class, however. One data member in an Event object is used to keep track of the largest col() or acol() colour tag set so far, so that new ones do not clash. Constructors and modifications of the event record Although you would not normally need to create your own Event instance, there may be times where that could be convenient. The typical example would be if you want to create a new event record that is the sum of a few different ones, e.g. if you want to simulate pileup events. There may also be cases where you want to add one or a few particles to an existing event record. A few methods exist to rotate and boost events. These derive from the Vec4 methods, and affect both the momentum and the vertex (position) components of all particles. The Junction Class The event record also contains a vector of junctions, which often is empty or else contains only a very few per event. Methods are available to add further junctions or query the current junction list. This is only for the expert user, however, and is not discussed further here, but only the main points. A junction stores the properties associated with a baryon number that is fully resolved, i.e. where three different colour indices are involved. There are two main applications, baryon beams, where at least two valence quarks are kicked out, and so the motion of the baryon number is nontrivial; baryon-number violating processes, e.g. in SUSY with broken R -parity. Information on junctions is set, partly in the process generation, partly in the beam remnants machinery, and used by the fragmentation routines, but the normal user does not have to know the details. For each junction, information is stored on the kind of junction, and on the three (anti)colour indices that are involved in the junction. The possibilities foreseen are: kind = 1 : incoming colourless particle to three outgoing colours (e.g. baryon beam remnant or neutralino &rarr; q q q ); kind = 2 : incoming colourless particle to three outgoing anticolours; kind = 3 : one incoming anticolour (stored first) and two outgoing  colours (e.g. antisquark decaying to two quarks, or  gluino decay to three quarks); kind = 4 : one incoming colour (stored first) and two outgoing anticolours (e.g. squark decaying to two antiquarks, or  gluino decaying to three antiquarks); kind = 5 : two incoming anticolours (stored first) and one outgoing colour (e.g. resonant squark production through RPV); kind = 6 : two incoming colours (stored first) and one outgoing anticolour (e.g. resonant antisquark production  through RPV); The odd (even) kind codes corresponds to a +1 (-1) change in baryon number across the junction. The kind and colour information in the list of junctions can be set or read with methods of the Event class, but are not of common interest and so not described here. A listing of current junctions can be obtained with the listJunctions() method. Subsystems Separate from the event record as such, but closely tied to it is the PartonSystems class, which mainly stores the parton indices of incoming and outgoing partons, classified by collision subsystem. Such information is needed to interleave multiparton interactions, initial-state showers and final-state showers, and append beam remnants. It could also be used in other places. It is intended to be accessed only by experts, such as implementors of new showering models."},{"name":"virtual bool doChainDecay(int idMother) {return false;}","link":"ExternalDecays.html#anchor3","text":"if true then chainDecay is called, else decay. This method is called for each particle that is to be decayed externally. is the PDG identity code of the decaying mother."},{"name":"bool Hist::sameSize(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor20","text":"checks that the number of bins and upper and lower limits are the same as in the histogram in the argument."},{"name":"HiggsA3:etaParity","link":"HiggsProcesses.html#anchor118","text":"The eta value of CP-violation in the HiggsA3:parity = 3 option."},{"name":"StringFragmentation:eNormJunction","link":"Fragmentation.html#anchor42","text":"Used to find the effective rest frame of the junction, which is complicated when the three string legs may contain additional gluons between the junction and the endpoint. To this end, a pull is defined as a weighed sum of the momenta on each leg, where the weight is exp(- eSum / eNormJunction) , with eSum the summed energy of all partons closer to the junction than the currently considered one (in the junction rest frame). Should in principle be (close to) sqrt((1 + a) / b) , with a and b the parameters of the Lund symmetric fragmentation function."},{"name":"Zprime:abPrime","link":"NewGaugeBosonProcesses.html#anchor32","text":"axial coupling of b' quarks."},{"name":"SUSY:qqbar2chi+-chi0","link":"SUSYProcesses.html#anchor16","text":"Associated chargino-neutralino production by quark-antiquark annihilation. With four neutralino species, two chargino ones, and maintaining charge conjugate processes separate, this gives 16 separate processes, codes 1221 - 1236. The cross section expressions follow Boz07. Only the MFV case has been explicitly validated."},{"name":"SigmaElastic:bSlope","link":"TotalCrossSections.html#anchor19","text":"the slope b of the strong-interaction term exp(bt) , in units of GeV^-2."},{"name":"bool Settings::isMVec(string key)","link":"SettingsScheme.html#anchor22","text":""},{"name":"Merging:doUMEPSTree","link":"UMEPSMerging.html#anchor1","text":"Reweight events according to the UMEPS prescription for tree-level configurations."},{"name":"int ParticleData::heaviestQuark(int id)","link":"ParticleDataScheme.html#anchor77","text":"extracts the heaviest quark or antiquark, i.e. one with largest id number, for a hadron."},{"name":"StringPT:enhancedWidth","link":"Fragmentation.html#anchor26","text":"enhancedWidth ,the enhancement of the width in this fraction."},{"name":"double JetMatchingMadgraph::getPTfirst()","link":"JetMatching.html#anchor32","text":"Return the transverse momentum (w.r.t. the beam) of the first parton shower emission, as needed for the shower-kT scheme."},{"name":"UncertaintyBands:List","link":"Variations.html#anchor5","text":"Vector of uncertainty-variation strings defining which variations will be calculated by Pythia when UncertaintyBands:doVariations is switched on."},{"name":"virtual int UserHooks::numberVetoStep()","link":"UserHooks.html#anchor18","text":"Returns the number of steps n each of ISR and FSR, for the hardest interaction, that you want to be able to study. That is, the method will be called after the first n ISR emissions, irrespective of the number of FSR ones at the time, and after the first n FSR emissions, irrespective of the number of ISR ones. The number of steps defaults to the first one only, but you are free to pick another value. Note that double diffraction is handled as two separate Pomeron-proton collisions, and thus has two sequences of emissions."},{"name":"Onia:all(3PJ)","link":"OniaProcesses.html#anchor5","text":"Common switch for the group of 3PJ onia production, e.g. chi_c and chi_b."},{"name":"generic","link":"SUSYLesHouchesAccord.html#anchor10","text":""},{"name":"Merging:nRequested","link":"CKKWLMerging.html#anchor30","text":"Exact number of additional jets requested for a particular LHE file. If a file should for example only contain W + g g events, this switch should be set to '2' for this LHE file. For NLO merging schemes (see NLO Merging ), this number has to be set."},{"name":"BeamRemnants:valencePowerUinP","link":"BeamRemnants.html#anchor14","text":"The abovementioned power for valence u quarks in protons."},{"name":"int Event::size()","link":"EventRecord.html#anchor6","text":"The event size, i.e. the size of the vector<Particle>. Thus valid particles, to be accessed by the above indexing operator, are stored in the range 0 <= i < size(). See comment above about the (ir)relevance of entry 0."},{"name":"HiggsBSM:gg2A3","link":"HiggsProcesses.html#anchor46","text":"Scattering g g &rarr; A^0(A_3^0) via loop contributions primarily from top. Code 1042."},{"name":"HadronScatter:yDiffMax","link":"HadronScattering.html#anchor4","text":""},{"name":"double LHAup::spin(int i)","link":"LesHouchesAccord.html#anchor51","text":""},{"name":"virtual double UserHooks::scaleVetoPT()","link":"UserHooks.html#anchor15","text":"In the base class this method returns 0. You should redefine it to return the pT scale at which you want to study the event."},{"name":"StringFragmentation:stopMass","link":"Fragmentation.html#anchor35","text":"Is used to define a W_min = m_q1 + m_q2 + stopMass , where m_q1 and m_q2 are the masses of the two current endpoint quarks or diquarks."},{"name":"ContactInteractions:etaLR","link":"CompositenessProcesses.html#anchor41","text":"Helicity parameter."},{"name":"ContactInteractions:etaLL","link":"CompositenessProcesses.html#anchor39","text":"Helicity parameter."},{"name":"ColourReconnection:mode","link":"ColourReconnection.html#anchor2","text":"Determine which model is used for colour reconnection. Beware that different BeamRemnants:remnantMode should be used for different reconnection schemes. The MPI-based original Pythia 8 scheme. The new more QCD based scheme. The new gluon-move model. The SK I e^+ e^- CR model. The SK II e^+ e^- CR model."},{"name":"double Particle::py()","link":"ParticleProperties.html#anchor10","text":""},{"name":"Onia:all(3DJ)","link":"OniaProcesses.html#anchor6","text":"Common switch for the group of 3DJ onia production, e.g. psi(3770)."},{"name":"Beams:maxDevTime","link":"BeamParameters.html#anchor35","text":"The collision time is restricted to be in the range |t| < sigma_t * maxDevTime."},{"name":"vector AMPERSANDlt;stringAMPERSANDgt; Info::headerKeys()","link":"EventInformation.html#anchor131","text":"return a vector of all header key names"},{"name":"friend double theta(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor38","text":""},{"name":"void ParticleDataEntry::clearChannels()","link":"ParticleDataScheme.html#anchor151","text":"resets to an empty decay table."},{"name":"double Info::pT2NowISR()","link":"EventInformation.html#anchor113","text":"set/get value of pT^2 in latest ISR branching."},{"name":"friend Vec4 operator/(const Vec4AMPERSAND v, double f)","link":"FourVectors.html#anchor57","text":"divide a four-vector by a real number."},{"name":"bool LHAup::newEventFile(const char* fileIn)","link":"LesHouchesAccord.html#anchor81","text":"close current event input file/stream and open a new one, to continue reading events of the same kind as before."},{"name":"LesHouches:matchInOut","link":"LesHouchesAccord.html#anchor74","text":"The energies and longitudinal momenta of the two incoming partons are recalculated from the sum of the outgoing final (i.e. status 1) particles. The incoming partons are set massless. There are two main applications for this option. Firstly, if there is a mismatch in the Les Houches input itself, e.g. owing to limited precision in the stored momenta. Secondly, if a mismatch is induced by PYTHIA recalculations, notably when an outgoing lepton or quark is assigned a mass although assumed massless in the Les Houches input. Warning: it is assumed that the incoming partons are along the +-z axis; else the kinematics construction will fail."},{"name":"MiniStringFragmentation:nTry","link":"Fragmentation.html#anchor41","text":"Whenever the machinery is called, first this many attempts are made to pick two hadrons that the system fragments to. If the hadrons are too massive the attempt will fail, but a new subsequent try could involve other flavour and hadrons and thus still succeed. After nTry attempts, instead an attempt is made to produce a single hadron from the system. Should also this fail, some further attempts at obtaining two hadrons will be made before eventually giving up."},{"name":"friend double m(const Vec4AMPERSAND v1, const Vec4AMPERSAND v2)","link":"FourVectors.html#anchor33","text":""},{"name":"virtual vectorAMPERSANDlt;intAMPERSANDgt; SpaceShower::getRecoilers(  const EventAMPERSAND event, int iRad, int iEmt, string name)","link":"ImplementNewShowers.html#anchor47","text":"This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the spacelike shower for all possible recoilers for a particular combination of radiator and emission. The function arguments are the event which contains the radiator and emission, and the position of the radiator ( iRad ) and emission ( iEmt ) in said event. Since this information might not be enough to uniquely determine the list of recoilers, a further string argument that encodes e.g. the splitting name is supplied. The function should return a vector of the positions of all possible allowed recoilers in the input event."},{"name":"bool ParticleData::isLepton(int id)","link":"ParticleDataScheme.html#anchor68","text":"true for a lepton or an antilepton (including neutrinos)."},{"name":"HiggsBSM:ffbar2H+-H2","link":"HiggsProcesses.html#anchor61","text":"Scattering f fbar &rarr; H^+- H^0(H_2). Code 1084."},{"name":"HiggsBSM:ffbar2H+-H1","link":"HiggsProcesses.html#anchor60","text":"Scattering f fbar &rarr; H^+- h^0(H_1). Code 1083."},{"name":"double Info::eA()","link":"EventInformation.html#anchor6","text":""},{"name":"TimeShower:nGluonToQuark","link":"TimelikeShowers.html#anchor32","text":"Number of allowed quark flavours in g &rarr; q qbar branchings (phase space permitting). A change to 4 would exclude g &rarr; b bbar , etc."},{"name":"WeakShower:vetoWeakDeltaR","link":"WeakShowers.html#anchor5","text":"The delta R parameter used in the kT clustering for the veto algorithm used to avoid double counting. Relates to the relative importance given to ISR and FSR emissionbs."},{"name":"StandardModel:sin2thetaWbar","link":"StandardModelParameters.html#anchor5","text":"The sine-squared of the weak mixing angle, as used to derive the vector couplings of fermions to the Z^0 , in the relation v_f = a_f - 4 e_f sin^2(theta_W)bar. Default is the effective-angle value from Yao06."},{"name":"Top:gmgm2ttbar","link":"TopProcesses.html#anchor7","text":"Scatterings gamma gamma &rarr; t tbar. Code 606."},{"name":"int Particle::status()","link":"ParticleProperties.html#anchor2","text":"status code. The status code includes information on how a particle was produced, i.e. where in the program execution it was inserted into the event record, and why. It also tells whether the particle is still present or not. It does not tell how a particle disappeared, whether by a decay, a shower branching, a hadronization process, or whatever, but this is implicit in the status code of its daughter(s). The basic scheme is: status = +- (10 * i + j) +       : still remaining particles -       : decayed/branched/fragmented/... and not remaining i =  1 - 9 : stage of event generation inside PYTHIA i = 10 -19 : reserved for future expansion i >= 20   : free for add-on programs j = 1 - 9  : further specification In detail, the list of used or foreseen status codes is: 11 - 19 : beam particles 11 : the event as a whole 12 : incoming beam 13 : incoming beam-inside-beam (e.g. gamma inside e ) 14 : outgoing elastically scattered 15 : outgoing diffractively scattered 21 - 29 : particles of the hardest subprocess 21 : incoming 22 : intermediate (intended to have preserved mass) 23 : outgoing 24 : outgoing, nonperturbatively kicked out in diffraction 31 - 39 : particles of subsequent subprocesses 31 : incoming 32 : intermediate (intended to have preserved mass) 33 : outgoing 34 : incoming that has already scattered 41 - 49 : particles produced by initial-state-showers 41 : incoming on spacelike main branch 42 : incoming copy of recoiler 43 : outgoing produced by a branching 44 : outgoing shifted by a branching 45 : incoming rescattered parton, with changed kinematics        owing to ISR in the mother system (cf. status 34) 46 : incoming copy of recoiler when this is a rescattered        parton (cf. status 42) 47 : a W or Z gauge boson produced in the        shower evolution 49 : a special state in the evolution, where E^2 - p^2 = m^2 is not fulfilled 51 - 59 : particles produced by final-state-showers 51 : outgoing produced by parton branching 52 : outgoing copy of recoiler, with changed momentum 53 : copy of recoiler when this is incoming parton,        with changed momentum 54 : copy of a recoiler, when in the initial state of a        different system from the radiator 55 : copy of a recoiler, when in the final state of a        different system from the radiator 56 : a W or Z gauge boson produced in a        shower branching (special case of 51) 59 : a special state in the evolution, where E^2 - p^2 = m^2 is not fulfilled 61 - 69 : particles produced by beam-remnant treatment 61 : incoming subprocess particle with primordial kT included 62 : outgoing subprocess particle with primordial kT included 63 : outgoing beam remnant 64 : copied particle with new colour according to the colour        configuration of the beam remnant 71 - 79 : partons in preparation of hadronization process 71 : copied partons to collect into contiguous colour singlet 72 : copied recoiling singlet when ministring collapses to        one hadron and momentum has to be reshuffled 73 : combination of very nearby partons into one 74 : combination of two junction quarks (+ nearby gluons)        to a diquark (this index is not changed by recoils        or recombinations) 75 : gluons split to decouple a junction-antijunction pair 76 : partons with momentum shuffled or a new colour to decouple        junction-antijunction structures 77 : temporary opposing parton when fragmenting first two        strings in to junction (should disappear again) 78 : temporary combined diquark end when fragmenting last        string in to junction (should disappear again) 79 : copy of particle with new colour indices after the        colour reconnection 81 - 89 : primary hadrons produced by hadronization process 81 : from ministring into one hadron 82 : from ministring into two hadrons 83, 84 : from normal string (the difference between the two        is technical, whether fragmented off from the top of the        string system or from the bottom, useful for debug only) 85, 86 : primary produced hadrons in junction fragmentation of        the first two string legs in to the junction,        in order of treatment 87, 88 : primary produced baryon from a junction (similar difference           as for 83, 84) 89 : primary produced baryon from a junction in the ministring        framework 91 - 99 : particles produced in decay process, or by Bose-Einstein  effects 91 : normal decay products 92 : decay products after oscillation B0 &harr; B0bar or B_s0 &harr; B_s0bar 93, 94 : decay handled by an external program, normally        or with oscillation 95, 96 : a forced decay handled by an external program, i.e. picked        from a subset of the possible channels to enhance the rate        of rare signals, normally or with oscillation 99 : particles with momenta shifted by Bose-Einstein effects        (not a proper decay, but bookkept as an 1 &rarr; 1 such,        happening after decays of short-lived resonances but before        decays of longer-lived particles) 101 - 109 : particles in the handling of R-hadron production and  decay, i.e. long-lived (or stable) particles containing a very heavy  flavour 101 : when a string system contains two such long-lived particles,         the system is split up by the production of a new q-qbar         pair (bookkept as decay chains that seemingly need not conserve         flavour etc., but do when considered together) 102 : partons rearranged from the long-lived particle end to prepare         for fragmentation from this end 103 : intermediate 'half-R-hadron' formed when a colour octet particle         (like the gluino) has been fragmented on one side, but not yet on         the other 104 : an R-hadron 105 : partons or particles formed together with the R-hadron during         the fragmentation treatment 106 : subdivision of an R-hadron into its flavour content, with         momentum split accordingly, in preparation of the decay of         the heavy new particle, if it is unstable 107 : two temporary leftover gluons joined into one in the formation         of a gluino-gluon R-hadron 111 - 119 : hadrons with changed momentum due to hadron  (re)scattering 111 : first time scattering 112 : second or more time scattering 121 - 199 : reserved for future expansion 201 - : free to be used by anybody. Note: a clarification on the role of the 'hardest' vs. the 'subsequent' subprocesses, the 20'ies and 30'ies status code series, respectively. Most events contain exactly one 'hardest' 2 &rarr; n interaction, and then an arbitrary number of 'subsequent' softer 2 &rarr; 2 ones generated by the MPI framework. In the SoftQCD:nonDiffractive event class also the 'hardest' is generated by the MPI machinery, and can be arbitrarily soft, but still with 20'ies codes. Diffractive systems span a broad mass range, where the higher masses admit a perturbative description with 'hard' and 'subsequent' subprocesses, like for nondiffractive events. A double diffractive event can contain up to two such 'hardest' interactions, one per diffractive system. A nonperturbative diffractive system does not contain any 2 &rarr; n subprocesses, but there is a kicked-out quark or gluon with status 24, combined with a beam remnant of one or two partons with status 63, that together define the mass and longitudinal axis of the diffractive system, for use in the subsequent hadronization. An event may also contain two 20'ies perturbative subcollisions if you use the Second Hard Process generation machinery."},{"name":"SpaceShower:alphaSorder","link":"SpacelikeShowers.html#anchor7","text":"Order at which alpha_strong runs, zeroth order, i.e. alpha_strong is kept fixed. first order, which is the normal value. second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"BeamRemnants:halfMassForKT","link":"BeamRemnants.html#anchor5","text":"The scale m_half in the equation above, defining the half-way point between low-mass and high-mass subsystems. (Kinematics construction can easily fail if a system is assigned a primordial kT value higher than its mass, so the mass-dampening is intended to reduce some troubles later on.)"},{"name":"Charmonium:states(3PJ)","link":"OniaProcesses.html#anchor24","text":"The 3PJ charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"double ParticleData::constituentMass(int id)","link":"ParticleDataScheme.html#anchor64","text":"is the constituent mass for a quark, hardcoded as m_u = m_d = 0.325 , m_s = 0.50 , m_c = 1.60 and m_b = 5.0 GeV, for a diquark the sum of quark constituent masses, and for everything else the same as the ordinary mass."},{"name":"string Info::getGeneratorValue(unsigned int n = 0)","link":"EventInformation.html#anchor117","text":"Return the contents of the n'th <generator> tag in the vector of tags."},{"name":"ExtraDimensionsLED:qqbar2DJgg","link":"ExtraDimensionalProcesses.html#anchor57","text":"Scatterings q qbar &rarr; (LED G*) &rarr; g g. Code 5034."},{"name":"double ParticleDataEntry::mSel()","link":"ParticleDataScheme.html#anchor136","text":"give the mass of a particle, either at the nominal value or picked according to a (linear or quadratic) Breit-Wigner."},{"name":"Bose-Einstein Effects","link":"BoseEinsteinEffects.html","text":"Bose-Einstein Effects The BoseEinstein class performs shifts of momenta of identical particles to provide a crude estimate of Bose-Einstein effects. The algorithm is the BE_32 one described in Lon95 , with a Gaussian parametrization of the enhancement. We emphasize that this approach is not based on any first-principles quantum mechanical description of interference phenomena; such approaches anyway have many problems to contend with. Instead a cruder but more robust approach is adopted, wherein BE effects are introduced after the event has already been generated, with the exception of the decays of long-lived particles. The trick is that momenta of identical particles are shifted relative to each other so as to provide an enhancement of pairs closely separated, which is compensated by a depletion of pairs in an intermediate region of separation. More precisely, the intended target form of the BE correlations in BE_32 is f_2(Q) = (1 + lambda * exp(-Q^2 R^2))      * (1 + alpha * lambda * exp(-Q^2 R^2/9) * (1 - exp(-Q^2 R^2/4))) where Q^2 = (p_1 + p_2)^2 - (m_1 + m_2)^2. Here the strength lambda and effective radius R are the two main parameters. The first factor of the equation is implemented by pulling pairs of identical hadrons closer to each other. This is done in such a way that three-momentum is conserved, but at the price of a small but non-negligible negative shift in the energy of the event. The second factor compensates this by pushing particles apart. The negative alpha parameter is determined iteratively, separately for each event, so as to restore energy conservation. The effective radius parameter is here R/3 , i.e. effects extend further out in Q. Without the dampening (1 - exp(-Q^2 R^2/4)) in the second factor the value at the origin would become f_2(0) = (1 + lambda) * (1 + alpha * lambda) , with it the desired value f_2(0) = (1 + lambda) is restored. The end result can be viewed as a poor man's rendering of a rapidly dampened oscillatory behaviour in Q. Further details can be found in Lon95. For instance, the target is implemented under the assumption that the initial distribution in Q can be well approximated by pure phase space at small values, and implicitly generates higher-order effects by the way the algorithm is implemented. The algorithm is applied after the decay of short-lived resonances such as the rho , but before the decay of longer-lived particles. This algorithm is known to do a reasonable job of describing BE phenomena at LEP. It has not been tested against data for hadron colliders, to the best of our knowledge, so one should exercise some judgment before using it. Therefore by default the master switch HadronLevel:BoseEinstein is off. Furthermore, the implementation found here is not (yet) as sophisticated as the one used at LEP2, in that no provision is made for particles from separate colour singlet systems, such as W 's and Z 's, interfering only at a reduced rate. Warning: The algorithm will create a new copy of each particle with shifted momentum by BE effects, with status code 99, while the original particle with the original momentum at the same time will be marked as decayed. This means that if you e.g. search for all pi+- in an event you will often obtain the same particle twice. One way to protect yourself from unwanted doublecounting is to use only particles with a positive status code, i.e. ones for which event[i].isFinal() is true. Main parameters Assuming you have set HadronLevel:BoseEinstein = on , you can regulate the detailed behaviour with the following settings."},{"name":"RHadrons:idStop","link":"RHadrons.html#anchor4","text":"The lightest stop identity code. For other scenarios than SUSY this code could be changed to represent another long-lived charge 2/3 colour triplet particle, that then would be treated in the same spirit. As above it could be set to 0 to forbid any stop R-hadron formation."},{"name":"bool Info::isHardDiffractiveB()","link":"EventInformation.html#anchor21","text":"is either beam hard diffractively excited?"},{"name":"StringFlav:mesonBvector","link":"FlavourSelection.html#anchor9","text":"the relative production ratio vector/pseudoscalar for bottom mesons."},{"name":"ParticleDataEntryAMPERSAND operator=( const ParticleDataEntryAMPERSAND  particleDataEntryIn)","link":"ParticleDataScheme.html#anchor92","text":"copy the values stored in an existing ParticleDataEntry object."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; Settings::getReadHistory(int subrun)","link":"SettingsScheme.html#anchor15","text":"Method to retrieve the history of readString commands that have been processed by Settings , for a specific subrun (see the section on Main-Program Settings ). For subrun = -1 , returns the readString history common to all subruns. For subrun >= 0 , returns the history of readString commands for that specific subrun (omitting the common part)."},{"name":"bool ParticleDataEntry::doExternalDecay()","link":"ParticleDataScheme.html#anchor127","text":"a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the pythia.decayPtr method should be provided with the list of relevant particles."},{"name":"int Event::copy(int iCopy, int newStatus = 0)","link":"EventRecord.html#anchor30","text":"copies the existing particle in entry iCopy to the bottom of the event record and returns the index of this position. By default, i.e. with newStatus = 0 , everything is copied precisely as it is, which means that history information has to be modified further by hand to make sense. With a positive newStatus , the new copy is set up to be the daughter of the old, with status code newStatus , while the status code of iCopy is negated. With a negative newStatus , the new copy is instead set up to be the mother of iCopy. An attempt to copy an out-of-range entry will return -1."},{"name":"Bottomonium:O(3S1)[3S1(1)]1","link":"OniaProcesses.html#anchor79","text":"The color-singlet long-distance matrix elements <O[3S1(1)]> for the first 3S1 bottomonium states."},{"name":"RHadrons:setMasses","link":"RHadrons.html#anchor7","text":"Use simple mass formulae to construct all available R-hadron masses based on the currently initialized gluino/squark masses and the constituent masses of the other partons in the hadron. If you switch this off, it is your responsibility to set each of the R-hadron masses on your own, and set them in an internally consistent way. If you mess up on this you may generate accordingly crazy results. Specifically, it is to be assumed that none of the R-hadrons has a mass below its constituent sparticle, i.e. that the light degrees of freedom and the additional confinement gluon field gives a net positive contribution to the R-hadron mass."},{"name":"SUSY Les Houches Accord","link":"SUSYLesHouchesAccord.html","text":"SUSY Les Houches Accord The PYTHIA 8 program does not contain an internal spectrum calculator (a.k.a. RGE package) to provide supersymmetric couplings, mixing angles, masses and branching ratios. Thus the SUSY Les Houches Accord (SLHA) Ska04 All08 is the only way of inputting SUSY models, and SUSY processes (see the SUSYProcesses page) cannot be run unless such an input has taken place. The SLHA input format can also be extended for use with more general BSM models, beyond SUSY. Information specific to  how to use the SLHA interface for generic BSM models is collected below, under Using SLHA for generic BSM Models , with more elaborate explanations and examples in Des11. Most of the SUSY implementation in PYTHIA 8 is compatible with both the SLHA1 Ska04 and SLHA2 All08 conventions (with some limitations for the NMSSM in the latter case). Internally, PYTHIA 8 uses the SLHA2 conventions and translates SLHA1 input to these when necessary. See the section on SUSY Processes and Des11 for more information. Note that PYTHIA assumes that a spectrum is either fully SHLA1 or fully SLHA2 compliant. Mixing of the two standards is discouraged, as this can lead to ambiguities and inconsistencies. When reading LHEF files, Pythia automatically looks for SLHA information between <slha>...</slha> tags in the header of such files. When running Pythia without LHEF input (or if reading an LHEF file that does not contain SLHA information in the header), a separate file containing SLHA information may be specified using SLHA:file (see below). Normally the LHEF would be in uncompressed format, and thus human-readable if opened in a text editor. A possibility to read gzipped files has been added, based on the Boost and zlib libraries, which therefore have to be linked appropriately in order for this option to work. See the README file in the main directory for details on how to do this. Finally, the SLHA input capability can of course also be used to input SLHA-formatted MASS and DECAY tables for other particles, such as the Higgs boson, furnishing a less sophisticated but more universal complement to the standard PYTHIA 8-specific methods for inputting such information (for the latter, see the section on Particle Data and the scheme to modify it). This may at times not be desirable, so a few options can be used to curb the right of SLHA to overwrite particle data. Conversely, it is sometimes useful to allow the user to modify eg a mass parameter relative to its value in the SLHA spectrum. This is normally not permitted (the SLHA spectrum is normally self-consistent and should not be modified), but an option for allowing it is provided. The reading-in of information from SLHA or LHEF files is handled by the SusyLesHouches class, while the subsequent calculation of derived quantities of direct application to SUSY processes is done in the CoupSUSY , SigmaSUSY , and SUSYResonanceWidths classes. Sanity Checks As an aid for basic validation, some checks and ranges are imposed  on SLHA input during initialization, as follows: Several parameters ( SLHA:keepSM , minMassSM , and SLHA:allowUserOverride ) provide some safety against unintentionally overwriting PYTHIA's Standard-Model information. These parameters can be altered to hand over more or less control to the SLHA interface. In particular, a lot of mass and decay-table information may be included by default in some SLHA files, without it being the explicit intention of the user to overwrite the corresponding PYTHIA information. The default values of the SLHA safety parameters have been chosen so as to eliminate at least the most obvious causes of Garbage In Garbage Out. (E.g., there is usually no reason to modify the masses of well-measured SM particles, like the W and Z bosons, nor to replace their sophisticated internal decay treatments by the simplified isotropic treatment used for SLHA DECAY tables.) For SLHA SUSY spectra, the interface checks  the mass-ordering of the Higgs, Neutralino, and  Chargino sectors, and the unitarity/orthogonality of the mixing matrices. It also performs some additional self-consistency checks on whether the correct SLHA BLOCKs for the given SUSY model have been included, and whether all required entries have been defined. If MASS or DECAY information for a particle has been changed by SLHA input, the following sanity checks will be carried out. The particle will be declared stable unless there is at least one on-shell decay channel open (regardless of the presence of any DECAY information). In particular, massless particles will always be declared stable. A lower cutoff is imposed on the Breit-Wigner shape of the particle, requiring its mass to remain above the sum of masses for the lightest decay channel. Subject to that constraint, the lower cutoff will normally be placed at 5 times the width (so that the default gives a decent sampling of the shape), but the user is allowed to use the mMin parameter to choose a larger sampling range if so desired (still subject to the on-shell constraint). For each decay channel in an SLHA DECAY table, PYTHIA will checks the available phase space. If the channel is on shell (sum of daughter masses is less than mass of decaying particle), then the threshold dependence is given by SLHA:meMode. If the channel is off shell, then an meMode of 100 is always used. As a further protection against GIGO, if the channel appears to be physically impossible (defined as requiring fluctuations of more than more than 100 times the effective combined widths), it is switched of and a warning message is printed. DECAY table branching fractions are always interpreted as positive. However, a negative sign for one or more channels can be given, and will then be interpreted to mean that the corresponding channel(s) should be switched off for the current run. This furnishes a simple way to switch SLHA DECAY channels on and off while preserving the sum of branching fractions equal to unity. Note that these sanity checks will not catch all possible cases of Garbage In Garbage Out, so human verification of the input files is always a good idea, as is taking a look at any warnings or error messages printed by the SLHA interface during initialization. It is ultimately up to the user to ensure that sensible input is being given. SLHA Switches and Parameters SLHA DECAY Tables In addition to SUSY spectra, the SLHA also defines a set of conventions for decay tables. These are not restricted to SUSY models, but can be used for arbitrary particles, either in combination with or independently of the SUSY parts of the Accord. The settings in this section control whether and how PYTHIA will make use of such tables. See also the comments under sanity checks above. Note : the PYTHIA SLHA interface is limited to at most 1&rarr;8 decays. Internal SLHA Variables Using SLHA for generic BSM Models Using the QNUMBERS extension Alw07 , the SLHA can also be used to define new particles, with arbitrary quantum numbers. This already serves as a useful way to introduce new particles and can be combined with MASS and DECAY tables in the usual way, to generate isotropically distributed decays or even chains of such decays. (If you want something better than isotropic, sorry, you'll have to do some actual work ...) A more advanced further option is to make use of the possibility in the SLHA to include user-defined blocks with arbitrary names and contents. Obviously, standalone PYTHIA 8 does not know what to do with such information. However, it does not throw it away either, but instead stores the contents of user blocks as strings, which can be read back later, with the user having full control over the format used to read the individual entries. The contents of both standard and user-defined SLHA blocks can be accessed in any class inheriting from PYTHIA 8's SigmaProcess class (i.e., in particular, from any semi-internal process written by a user), through its SLHA pointer, slhaPtr , by using the following methods: bool slhaPtr->getEntry(string blockName, double& val); bool slhaPtr->getEntry(string blockName, int indx, double& val); bool slhaPtr->getEntry(string blockName, int indx, int jndx, double& val); bool slhaPtr->getEntry(string blockName, int indx, int jndx, int kndx, double& val); This particular example assumes that the user wants to read the entries (without index, indexed, matrix-indexed, or 3-tensor-indexed, respectively) in the user-defined block blockName , and that it should be interpreted as a double. The last argument is templated, and hence if anything other than a double is desired to be read, the user has only to give the last argument a different type. If anything went wrong (i.e., the block doesn't exist, or it doesn't have an entry with that index, or that entry can't be read as a double), the method returns false; true otherwise. This effectively allows to input completely arbitrary parameters using the SLHA machinery, with the user having full control over names and conventions. Of course, it is then the user's responsibility to ensure complete consistency between the names and conventions used in the SLHA input, and those assumed in any user-written semi-internal process code. Note that PYTHIA 8 always initializes at least the SLHA blocks MASS and SMINPUTS, starting from its internal SM parameters and particle data table values (updated to take into account user modifications). These blocks can therefore be accessed using the slhaPtr->getEntry() methods even in the absence of SLHA input. Note: in the SMINPUTS block, PYTHIA outputs physically correct (i.e., measured) values of GF , m_Z , and alpha_EM(m_Z). However, if one attempts to compute, e.g., the W mass, at one loop from these quantities, a value of 79 GeV results, with a corresponding value for the weak mixing angle. We advise to instead take the physically measured W mass from block MASS, and recompute the EW parameters as best suited for the application at hand."},{"name":"string Settings::word(string key)","link":"SettingsScheme.html#anchor36","text":""},{"name":"bool Settings::isFVec(string key)","link":"SettingsScheme.html#anchor21","text":""},{"name":"int Particle::statusAbs()","link":"ParticleProperties.html#anchor32","text":"the absolute value of the status code."},{"name":"double CoupSM::cos2thetaW()","link":"StandardModelParameters.html#anchor26","text":"the sine-squared and cosine-squared of the weak mixing angle, as used in the gauge-boson sector."},{"name":"Stat:showProcessLevel","link":"MainProgramSettings.html#anchor16","text":"Print the available statistics on number of generated events and cross sections, where relevant."},{"name":"int ParticleDataEntry::sizeChannels()","link":"ParticleDataScheme.html#anchor153","text":"returns the number of decay channels for a particle."},{"name":"Charmonium:qg2ccbar(3PJ)[3PJ(1)]q","link":"OniaProcesses.html#anchor28","text":"Colour-singlet production of 3PJ charmonium states via q g &rarr; ccbar[3PJ(1)] q. Code 412."},{"name":"TimeShower:nMaxGlobalRecoil","link":"TimelikeShowers.html#anchor21","text":"Represents the maximum number of particles in the final state for which the next final-state emission can be performed with the global recoil strategy. This number counts all particles, whether they are allowed to radiate or not, e.g. also Z^0. Also partons created by initial-state radiation emissions counts towards this sum, as part of the interleaved evolution. Without interleaved evolution this option would not make sense, since then a varying and large number of partons could already have been created by the initial-state radiation before the first final-state one, and then there is not likely to be any matrix elements available for matching."},{"name":"mapAMPERSANDlt;string, WVecAMPERSANDgt; Settings::getWVecMap(string match)","link":"SettingsScheme.html#anchor56","text":"return a map of all settings of the respective type that contain the string 'match' in its name."},{"name":"FourthGeneration:VubPrime","link":"FourthGenerationProcesses.html#anchor16","text":"The V_ub' matrix element in the 4 * 4 CKM matrix."},{"name":"int ParticleData::baryonNumberType(int id)","link":"ParticleDataScheme.html#anchor78","text":"is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a minus sign for antiparticles, and else zero."},{"name":"TimeShower:alphaSuseCMW","link":"TimelikeShowers.html#anchor8","text":"Do not apply the CMW rescaling. Apply the CMW rescaling, increasing Lambda_QCD for timelike showers by a factor roughly 1.6."},{"name":"bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr)","link":"ProgramFlow.html#anchor17","text":"offers the possibility to add further user hooks, see setUserHooksPtr above for further information. Note: The method currently always returns true. Warning: usually it is meaningful to combine several requirements, but there are examples where not. It is the responsibility of the user to check that a particular combination works as intended. Also see here."},{"name":"double Particle::m0()","link":"ParticleProperties.html#anchor71","text":"the nominal mass of the particle, according to the data tables."},{"name":"LeptoQuark:gg2LQLQbar","link":"LeptoquarkProcesses.html#anchor4","text":"Scatterings g g &rarr; LQ LQbar. Code 3203."},{"name":"HiggsH1:etaParity","link":"HiggsProcesses.html#anchor112","text":"The eta value of CP-violation in the HiggsH1:parity = 3 option."},{"name":"Next:numberShowProcess","link":"MainProgramSettings.html#anchor12","text":"The number of events to list the process record for, where relevant."},{"name":"void Event::clear()","link":"EventRecord.html#anchor20","text":"empties event record. Specifically the Particle vector size is reset to zero."},{"name":"Merging:pickBySumPT","link":"CKKWLMerging.html#anchor39","text":"If on, exclusively pick parton shower histories of the matrix element for which have the smallest sum of scalar evolution pT for consecutive splittings has been calculated."},{"name":"Particle::Particle()","link":"ParticleProperties.html#anchor116","text":"constructs an empty particle, i.e. where all properties have been set 0 or equivalent."},{"name":"int Particle::daughter1()","link":"ParticleProperties.html#anchor5","text":""},{"name":"double LHAup::px(int i)","link":"LesHouchesAccord.html#anchor45","text":""},{"name":"double Vec4::theta()","link":"FourVectors.html#anchor25","text":"the polar angle, in the range 0 through pi."},{"name":"Higgs:clipWings","link":"HiggsProcesses.html#anchor3","text":"The Breit-Wigner shape of a Higgs is nontrivial, owing to the rapid width variation with the mass of a Higgs. This implies that a Higgs of low nominal mass may still acquire a non-negligible high-end tail. The validity of the calculation may be questioned in these wings. With this option on, the Higgs:wingsFac value is used to cut away the wings. Warning: with this option on, the allowed mass range is shrunk, but never widened. This can lead to inconsistencies if a run consists of several subruns with different Higgs masses. The id:mMin and id:mMax values should therefore be reset (e.g. to the defaults 50. and 0.) when id:m0 is changed."},{"name":"int LHAup::pdfSetBeamA()","link":"LesHouchesAccord.html#anchor19","text":""},{"name":"virtual void TimeShower::prepareGlobal( EventAMPERSAND event)","link":"ImplementNewShowers.html#anchor10","text":"This method resets some counters and extracts the locations of outgoing partons, in preparation of using the optional global recoil scheme. Unlike prepare(...) below it is only called once during the parton-level evolution, since it only relates to the hardest interaction. Is probably of no use to most people."},{"name":"int LHAup::id1()","link":"LesHouchesAccord.html#anchor54","text":""},{"name":"int ParticleDataEntry::chargeType(int id = 1)","link":"ParticleDataScheme.html#anchor106","text":""},{"name":"void ParticleData::antiName(int id, string antiName)","link":"ParticleDataScheme.html#anchor29","text":""},{"name":"double Particle::tProd()","link":"ParticleProperties.html#anchor20","text":"the production vertex coordinates, in mm or mm/c."},{"name":"Beams:offsetTime","link":"BeamParameters.html#anchor39","text":"The time t of the interaction vertex is centered at this value."},{"name":"HiggsH1:parity","link":"HiggsProcesses.html#anchor111","text":"possibility to modify angular decay correlations in the decay of a h^0(H_1) decay Z^0 Z^0 or W^+ W^- to four fermions, or tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. isotropic decays. assuming the h^0(H_1) is a pure scalar (CP-even), as in the MSSM. assuming the h^0(H_1) is a pure pseudoscalar (CP-odd). assuming the h^0(H_1) is a mixture of the two, including the CP-violating interference term. The parameter eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to eta and the CP-odd one to eta^2. Intended for decays into W^+ W^- or Z^0 Z^0. same as 3 but now phi , see below, sets the CP-mixing angle. The CP-even term is proportional to sin^2(phi) , the interference to sin(phi)cos(phi) , and the CP-odd term to cos^2(phi). Consequently phi=0 is pure CP-odd and phi=pi/2 is pure CP-even. Intended for decays of h -> f fbar , notably for tau lepton polarization, whereas W^+ W^- and Z^0 Z^0 decays are isotropic."},{"name":"int LHAup::pdfGroupBeamB()","link":"LesHouchesAccord.html#anchor18","text":""},{"name":"PDF:PomQuarkA","link":"PDFSelection.html#anchor12","text":"the parameter a in the ansatz xq(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"HistAMPERSANDamp; Hist::operator-=(const HistAMPERSANDamp; h)","link":"Histograms.html#anchor24","text":"adds or subtracts the current histogram by the contents of the histogram in the argument if sameSize(...) is true, else does nothing."},{"name":"PhaseSpace:pTHat5Min","link":"PhaseSpaceCuts.html#anchor11","text":"The minimum invariant pT of the lowest- pT parton in QCD 2 &rarr; 3 processes."},{"name":"Diffraction:largeMassSuppress","link":"Diffraction.html#anchor24","text":"The choice of longitudinal and transverse structure of a diffractive beam remnant for a kicked-out gluon implies a remnant mass m_rem distribution (i.e. quark plus diquark invariant mass for a baryon beam) that knows no bounds. A suppression like (1 - m_rem^2 / m_diff^2)^p is therefore introduced, where p is the diffLargeMassSuppress parameter."},{"name":"HiggsBSM:all","link":"HiggsProcesses.html#anchor23","text":"Common switch for the group of Higgs production beyond the Standard Model, as listed below."},{"name":"Charmonium:O(3S1)[3S1(1)]1","link":"OniaProcesses.html#anchor42","text":"The color-singlet long-distance matrix elements <O[3S1(1)]> for the first 3S1 charmonium states."},{"name":"Charmonium:O(3S1)[3S1(1)]2","link":"OniaProcesses.html#anchor43","text":"The color-singlet long-distance matrix elements <O[3S1(1)]> for the second 3S1 charmonium states."},{"name":"void ResonanceWidths::calcPreFac(bool calledFromInit = false)","link":"SemiInternalResonances.html#anchor2","text":"is called once a mass has been chosen for the resonance, but before a specific final state is considered. This routine can therefore be used to perform calculations that otherwise might have to be repeated over and over again in calcWidth below. It is optional whether you want to use this method, however, or put everything in calcWidth(). The optional argument will have the value true when the resonance is initialized, and then be false throughout the event generation, should you wish to make a distinction. In PYTHIA such a distinction is made for gamma^*/Z^0 and gamma^*/Z^0/Z'^0 , owing to the necessity of a special description of interference effects, but not for other resonances. In addition to the base-class member variables already described above, mHat contains the current mass of the resonance. At initialization this agrees with the nominal mass mRes , but during the run it will not (in general)."},{"name":"SUSY:gg2squarkantisquark","link":"SUSYProcesses.html#anchor10","text":"Pair production of a scalar quark together with a scalar antiquark by gluon annihilation via s -channel gluon exchange, t - and u -channel squark exchange, and the direct 4-point coupling. The cross section expression follows Boz07. Only the MFV case has been explicitly validated."},{"name":"HadronScatter:scatterSameString","link":"HadronScattering.html#anchor8","text":"If switched on, strings within the same string are allowed to  scatter off each other. Otherwise only hadron pairs that are  not produced on the same string are taken into account."},{"name":"HadronScatter:scatterRepeat","link":"HadronScattering.html#anchor18","text":"Allow hadrons which have already scattered to scatter again. Even if switched on, the same pair can not scatter off each other twice."},{"name":"LeftRightSymmmetry:lgm2HRmu","link":"LeftRightSymmetryProcesses.html#anchor12","text":"Scatterings l_i gamma &rarr; H_R^-- mu^+. Code 3143."},{"name":"void ParticleDataEntry::setMayDecay(bool mayDecay)","link":"ParticleDataScheme.html#anchor124","text":""},{"name":"PhaseSpace:sameForSecond","link":"PhaseSpaceCuts.html#anchor14","text":"By default use the same cuts for a second hard process as for the first. If off then instead use the mass and pT cuts below, where relevant. (The other cuts above still remain the same.)"},{"name":"bool Pythia8ToHepMC::fill_next_event( Pythia8::PythiaAMPERSAND pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1)","link":"HepMCInterface.html#anchor3","text":"convert a Pythia event to a HepMC one. Will return true if succeeded. the input Pythia generator object, from which both the event and other information can be obtained. the output GenEvt event, in its standard form. set the event number of the current event. If negative then the internal event number is used, which is incremented by one for each new event. if true then the input event is appended to the current HepMC event record, rather than starting a new one. the root particle that defines the new production vertex for the particles to be added in the append = true option. used to set the bar code when append = true. If positive then start from iBarcode itself, if negative then start from the current size of the HepMC event record, and if 0 then set all bar codes to vanish."},{"name":"double CoupSM::efvf(int idAbs)","link":"StandardModelParameters.html#anchor38","text":""},{"name":"double Vec4::px()","link":"FourVectors.html#anchor12","text":""},{"name":"UMEPS Merging","link":"UMEPSMerging.html","text":"Unitarised Matrix Element + Parton Shower Merging Pythia offers the possibility to use the unitarised matrix element + parton shower merging scheme, as presented in Lon12. Unitarised ME+PS merging (UMEPS) allows for a consistent inclusion of tree-level multi-parton matrix elements into Pythia, and prevents potential changes in the inclusive production cross section. This makes it theoretically more appealing than CKKW-L merging. As in CKKW-L, UMEPS merging requires the user to supply Les Houches Event File input. UMEPS is different from other tree-level merging schemes in that it contains events with negative weights. These are generated by constructing parts of no-emission probabilities by reweighted higher-multiplicity samples Lon12. The main philosophy of UMEPS is 'subtract what you add', meaning that in order to ensure the stability of the inclusive cross section, one has to counter the inclusion of additional tree-level matrix elements by 'subtraction terms'. The scheme closely reflects how unitarity is achieved in a non-merged shower, and indeed explicitly enforces the cancellations that are implicitly happening in a non-merged shower. This makes very low merging scale values possible. The usage of UMEPS is illustrated in the sample main program main86.cc , together with the input file main86.cmnd. Unitarised merging is heavily indebted to CKKW-L merging, and shares many settings with CKKW-L. In particular, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( Merging:Process )needs to be defined exactly as in CKKW-L (see Defining the hard process in the CKKW-L documentation ). &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( Merging:TMS ) has to be set. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons Merging:nJetMax has to be set. UMEPS further shares the switches listed under the sections ' Matrix element merging and HepMC output for RIVET ' and ' Further variables ' in  the CKKW-L documentation with CKKW-L merging. Also, all MergingHooks routines that allow for user interference in CKKW-L merging are also usable for UMEPS -- with the exception of a user-defined merging scale. Currently, UMEPS is only implemented for a merging scale defined by the minimal Pythia evolution pT value between sets of radiator, emitted and recoiler partons. This is no fundamental limitation of the method, and will possibly be lifted in the future. Since this merging scale definition is not completely obvious, UMEPS also shares the Merging:enforceCutOnLHE switch with CKKW-L. In this way, it is possible to use LHE files that are regularised only with weak cuts as input, while the merging machinery imposes the stronger merging scale cut automatically. This means that no merging scale implementation is required from the user side, but also means that it is the user's responsibility to ensure that the cuts used for generating input LHE files are always looser than the cut given by the merging scale value Merging:TMS. UMEPS merging with main86.cc The UMEPS procedure is illustrated in the sample main program main86.cc (with the input card main86.cmnd ). This program produces HepMC events Dob01 , that can be histogrammed (e.g. using RIVET Buc10 ), or used as input for a detector simulation. If the user is not familiar with HepMC analysis tools, it is possible to instead use Pythia's histogramming routines. For this, remove the lines referring to HepMC, and histogram events as illustrated (for CKKW-L) for the histogram histPTFirstSum in main84.cc , i.e. using weight*normhepmc as weight. In principle, no changes to main86.cc are necessary. Instead, all settings can be transferred to main86.cc through an input file. The input LHE files are also part of the (command line) input of main86.cc. Note  that the sample program assumes that LHE file names are of the form name_tree_#nAdditionalJets.lhe. If you want to e.g. use the LHE files that are shipped with the Pythia distribution, you can execute main86.exe with the command ./main86.exe ./main86.cmnd ./w_production ./myhepmc.hepmc Since main86.cc is currently the 'front-end' for UMEPS merging, we will briefly discuss this sample program in the following. Inputs In its current form, main86.cc uses separate tree-level LHE files for different numbers of additional partons as input. If e.g. UMEPS merging for W-boson + up to two additional partons is to be performed, three LHE files (for W+zero, W+one, W+two partons) are required. The configurations in the input files should be regularised with inclusive (i.e. weak) cuts. The actual 'merging scale cut' will be handled internally. If e.g. Merging:TMS = 15 is the desired merging scale value, it is acceptable to regularise the matrix element calculation for Higgs+jets events at the LHC with the loose cuts pT jet = 5 GeV , &Delta;R jetA jetB = 0.01 and Q jetA jetB = 5 GeV. All input settings are handed to main86.cc in the form of an input file. This input file has to contain &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The number of desired events ( Main:numberOfEvents ) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( Merging:Process ) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( Merging:TMS ) &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons ( Merging:nJetMax ). Other settings are of course allowed. However, please refrain from adding switches that are used to invoke other merging schemes (e.g. Merging:doKTMerging ) into the input file, since this can cause problems. Program flow The sample program starts by estimating the cross section for samples with different jet multiplicities. For this, the switch Merging:doXSectionEstimate is invoked together with the merging scale definition of Merging:doUMEPSTree , which corresponds to the minimal Pythia evolution pT value. We will come back to the latter switch below. All showering, multiparton interactions and hadronisation is, for speed reasons, switched off when estimating the cross section, since the hard cross section estimate would not be influenced by the event evolution anyway. After the hard cross sections are known (including the application of the merging scale cut), the first part of the UMEPS events is generated by using the following switch. The weight generated by the UMEPS procedure can be accessed by using the function double Info::mergingWeight(). When printing (or histogramming) merged events, this weight, multiplied with the estimated cross section for the current sample, should be used as event weight (or to fill histogram bins). After this first part is complete, the outcome is an addition of reweighted tree-level samples. To restore the inclusive cross section (i.e. that the cross section after merging corresponds to the cross section of the hard process, without any additional jets), it is necessary to subtract samples. Parton shower unitarity leads to the conclusion that 'resolved' and 'unresolved' corrections always cancel between states that contain an additional resolved jet, and states in which we 'integrate over' the phase space of the additional jet. main86.cc makes this cancellation explicit by producing (correctly weighted) counter events by switching on The integration is achieved internally, and the number of desired integrations (which is always one for UMEPS counter events) is set by Again, the weight generated by the UMEPS procedure can be accessed by using the function double Info::mergingWeight(). This weight, multiplied with the cross section of the current sample, and multiplied by -1 , should then be used as event weight (or to fill histogram bins). Before returning, main86.cc prints the merged cross section after UMEPS merging."},{"name":"HiggsSM:gg2Hg(l:t)","link":"HiggsProcesses.html#anchor19","text":"Scattering g g &rarr; H^0 g via loop contributions primarily from top. Code 914."},{"name":"Beams:sigmaVertexY","link":"BeamParameters.html#anchor31","text":"The width of a Gaussian distribution of the y location of the interaction vertex."},{"name":"Beams:sigmaVertexX","link":"BeamParameters.html#anchor30","text":"The width of a Gaussian distribution of the x location of the interaction vertex."},{"name":"Beams:sigmaVertexZ","link":"BeamParameters.html#anchor32","text":"The width of a Gaussian distribution of the z location of the interaction vertex."},{"name":"SUSY:qg2squarkgluino","link":"SUSYProcesses.html#anchor9","text":"Associated production of a squark with a gluino. The cross section expression follows Fuk11 and include the possibility of non-minimal flavour violation through misalignment of quarks with squarks. Only the MFV case has been explicitly validated."},{"name":"int SigmaProcess::isQCD3body()","link":"SemiInternalProcesses.html#anchor24","text":"there are two different 3-body phase-space selection machineries, of which the non-QCD one is default. If you overload this method instead the QCD-inspired machinery will be used. The differences between these two is related to which phase space cuts can be set, and also that the QCD machinery assumes (almost) massless outgoing partons."},{"name":"double LHAup::tau(int i)","link":"LesHouchesAccord.html#anchor50","text":""},{"name":"ExtraDimensionsTEV:ffbar2uubar","link":"ExtraDimensionalProcesses.html#anchor28","text":"Scatterings f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; u ubar , Code 5062."},{"name":"void Settings::addFVec(string key,  vectorAMPERSANDlt;boolAMPERSANDgt; default)","link":"SettingsScheme.html#anchor29","text":""},{"name":"double Info::m3Hat()","link":"EventInformation.html#anchor57","text":""},{"name":"Beams:idB","link":"BeamParameters.html#anchor2","text":"The PDG id code for the second incoming particle."},{"name":"Beams:idA","link":"BeamParameters.html#anchor1","text":"The PDG id code for the first incoming particle. Allowed codes include 2212 = p , -2212 = pbar , 2112 = n , -2112 = nbar , 211 = pi^+ , -211 = pi^- , 111 = pi^0 , 990 = Pomeron (used in diffractive machinery; here mainly for debug purposes), 22 = gamma (for gamma-gamma and gamma-hadron interactions, more info here ), 11 = e^- , -11 = e^+ , 13 = mu^- , -13 = mu^+ , and a few more leptons/neutrinos in a few combinations."},{"name":"int ClusterJet::mult(int i)","link":"EventAnalysis.html#anchor22","text":"the number of particles that have been clustered into the i 'th jet."},{"name":"int Particle::mother2()","link":"ParticleProperties.html#anchor4","text":"the indices in the event record where the first and last mothers are stored, if any. There are six allowed combinations of mother1 and mother2 : mother1 = mother2 = 0 : for lines 0 - 2, where line 0 represents the event as a whole, and 1 and 2 the two incoming beam particles; mother1 = mother2 > 0 : the particle is a 'carbon copy' of its mother, but with changed momentum as a 'recoil'  effect, e.g. in a shower; mother1 > 0, mother2 = 0 : the 'normal' mother case, where it is meaningful to speak of one single mother to several products, in a shower or decay; mother1 < mother2 , both > 0, for abs(status) = 81 - 86 : primary hadrons produced from the fragmentation of a string spanning the range from mother1 to mother2 , so that all partons in this range should be considered mothers; and analogously for abs(status) = 101 - 106 , the formation of R-hadrons; mother1 < mother2 , both > 0, except case 4: particles with two truly different mothers, in particular the particles emerging from a hard 2 &rarr; n interaction. mother2 < mother1 , both > 0: particles with two truly different mothers, notably for the special case that two nearby partons are joined together into a status 73 or 74 new parton, in the g + q &rarr; q case the q is made first mother to simplify flavour tracing. Note 1: in backwards evolution of initial-state showers, the mother may well appear below the daughter in the event record. Note 2: the motherList() method below returns a vector of all the mothers, providing a uniform representation for all six cases."},{"name":"HadronLevel:HadronScatter","link":"MasterSwitches.html#anchor13","text":"Master switch for hadron rescattering, following the hadronization; on/off = true/false. Further options are found here."},{"name":"void ParticleDataEntry::setMMax(double mMax)","link":"ParticleDataScheme.html#anchor116","text":""},{"name":"void DecayChannel::multiplicity(int multiplicity)","link":"ParticleDataScheme.html#anchor177","text":""},{"name":"BoseEinstein:QRef","link":"BoseEinsteinEffects.html#anchor5","text":"The size parameter of the region in Q space over which Bose-Einstein effects are significant.  Can be thought of as the inverse of an effective distance in normal space, R = hbar / QRef , with R as used in the above equation. That is, f_2(Q) = (1 + lambda * exp(-(Q/QRef)^2)) * (...)."},{"name":"bool Rndm::dumpState(string fileName)","link":"RandomNumbers.html#anchor11","text":"save the current state of the random number generator to a binary file. This involves two integers and 100 double-precision numbers. Intended for debug purposes. Note that binary files may be platform-dependent and thus not transportable."},{"name":"double Rndm::flat()","link":"RandomNumbers.html#anchor5","text":"generate next random number uniformly between 0 and 1."},{"name":"BoseEinstein:Eta","link":"BoseEinsteinEffects.html#anchor3","text":"Include effects or not for identical eta and eta'."},{"name":"HiddenValley:Ngauge","link":"HiddenValleyProcesses.html#anchor1","text":"is U(1) for Ngauge = 1 , is SU(N) if Ngauge > 1. Note that pair production cross sections contains a factor of Ngauge for new particles in the fundamental representation of this group."},{"name":"WeakShower:vetoQCDjets","link":"WeakShowers.html#anchor4","text":"This flag vetoes some QCD emission for Drell-Yan weak production to avoid doublecounting with weak emission in QCD hard processes. For more information see WeakShower:vetoWeakJets above. Note that this flag only affects the process codes 221 and 222, i.e. the main built-in processes for gamma^*/Z^0/W^+- production, and not other internal or external processes."},{"name":"SecondHard:TwoJets","link":"ASecondHardProcess.html#anchor2","text":"Standard QCD 2 &rarr; 2 processes involving gluons and d, u, s, c, b quarks."},{"name":"ExcitedFermion:qq2uStarq","link":"CompositenessProcesses.html#anchor11","text":"Scatterings q q(bar) &rarr; u^* q(bar). Code 4022."},{"name":"bool ParticleDataEntry::mayDecay()","link":"ParticleDataScheme.html#anchor125","text":"a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for particle decays (or resonance decays ). All particles with tau0 below 1000 mm are by default initialized to allow decays."},{"name":"Merging:doUNLOPSSubt","link":"NLOMerging.html#anchor14","text":"This switch will allow the processing of tree-level events, to produce UMEPS subtraction terms for the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSTree , Merging:doUNLOPSLoop and Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is mandatory to set the correct value of Merging:nRequested. Furthermore, it is necessary to set the value of Merging:nRecluster to one."},{"name":"DecayChannelAMPERSAND ParticleDataEntry::pickChannel()","link":"ParticleDataScheme.html#anchor158","text":"pick a decay channel according to branching ratios from preparePick."},{"name":"double LHAup::xMax(i)","link":"LesHouchesAccord.html#anchor26","text":"for process i in the range 0 <= i < sizeProc()."},{"name":"void SigmaProcess::setIdColAcol()","link":"SemiInternalProcesses.html#anchor9","text":"is called only once an initial state and a kinematical configuration has been picked. This routine must set the complete flavour information and the colour flow of the process. This may involve further random choices, between different possible final-state flavours or between possible competing colour flows. Private data members of the class may be used to retain some information from the previous steps above. When this routine is called the two incoming flavours have already been selected and are available in id1 and id2 , whereas the one, two or three outgoing ones either are fixed for a given process or can be determined from the instate (e.g. whether a W^+ or W^- was produced).  There is also a standard method in VCKM to pick a final flavour from an initial one with CKM mixing. Once you have figured out the value of id3 and, the case being, id4 and id5 , you store these values permanently by a call setId( id1, id2, id3, id4, id5) , where the last two may be omitted if irrelevant. Correspondingly, the colours are stored with setColAcol( col1, acol1, col2, acol2, col3, acol3, col4, acol4, col5, acol5) , where the final ones may be omitted if irrelevant. Les Houches style colour tags are used, but starting with number 1 (and later shifted by the currently requested offset). The input is grouped particle by particle, with the colour index before the anticolour one. You may need to select colour flow dynamically, depending on the kinematics, when several distinct possibilities exist. Trivial operations, like swapping colours and anticolours, can be done with existing methods. When the id3Mass() and id4Mass() methods have been used, the order of the outgoing particles may be inconsistent with the way the tHat and uHat variables have been defined. A typical example would be a process like q g &rarr; q' W with tHat defined between incoming and outgoing quark, but where id3Mass() = 24 and so the process is to be stored as q g &rarr; W q'. One should then put the variable swapTU = true in setIdColAcol() for each event where the tHat and uHat variables should be swapped before the event kinematics is reconstructed. This variable is automatically restored to false for each new event."},{"name":"virtual BeamShape::~BeamShape()","link":"BeamShape.html#anchor2","text":"the constructor and destructor do not need to do anything."},{"name":"int Event::append(int id, int status, int col,  int acol, Vec4 p, double m = 0., double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor28","text":"appends a particle to the bottom of the event record and returns the index of this position, as above but with vanishing (i.e. zero) mother and daughter indices."},{"name":"Charmonium:O(3PJ)[3P0(1)]","link":"OniaProcesses.html#anchor25","text":"The color-singlet long-distance matrix elements <O[3P0(1)]>/m_Q^2 for the 3PJ charmonium states. The remaining <O[3PJ(1)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"SpaceShower:pTmaxMatch","link":"SpacelikeShowers.html#anchor1","text":"Way in which the maximum shower evolution scale is set to match the scale of the hard process itself. (i) if the final state of the hard process (not counting subsequent resonance decays) contains at least one quark ( u, d, s, c ,b ), gluon or photon then pT_max is chosen to be the factorization scale for internal processes and the scale value for Les Houches input; (ii) if not, emissions are allowed to go all the way up to the kinematical limit. The reasoning is that in the former set of processes the ISR emission of yet another quark, gluon or photon could lead to double-counting, while no such danger exists in the latter case. always use the factorization scale for an internal process and the scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some emissions that ought to have been simulated. (Also known as wimpy showers.) always allow emissions up to the kinematical limit. This will simulate all possible event topologies, but may lead to double-counting. (Also known as power showers.) Note 1: Some processes contain matrix-element matching to the first emission; this is the case notably for single gamma^*/Z^0, W^+- and H^0 production. Then default and option 2 give the correct result, while option 1 should never be used. Note 2: as enumerated in the text, these options take effect both for internal and external processes. Whether a particular option makes sense depends on the context. For instance, if events for the same basic process to different orders are to be matched, then option 1 would be a reasonable first guess. Note, however, that a program like the POWHEG BOX uses a pT definition for ISR and FSR that does not quite agree with the PYTHIA evolution scale, and thus there will be some amount of mismatch. In more sophisticated descriptions, therefore, option 2 could be combined with UserHooks vetoes on emissions that would lead to double-counting, using more flexible phase space boundaries. Further details are found in the Matching and Merging description, with an example in examples/main31. Option 0, finally, may be most realistic when only Born-level processes are involved, possibly in combination with a nonzero SpaceShower:pTdampMatch. The rules used for avoiding double-counting are not foolproof, however. As an example, for the t -channel process gamma gamma &rarr; e^+ e^- its pT scale is the plausible upper shower limit, with only dampened emissions above it. But the initial state is not checked and, had only incoming quarks and gluons been taken into account, only the s -channel process q qbar &rarr; gamma^*/Z^0 &rarr; e^+ e^- would have been possible, where indeed the whole phase space should be populated. So this is erroneously used, giving too much emissions. Note 3: These options only apply to the hard interaction. If a 'second hard' process is present, the two are analyzed and set separately for the default 0 option, while both are affected the same way for non-default options 1 and 2. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of each process itself."},{"name":"PhotonCollision:gmgm2mumu","link":"ElectroweakProcesses.html#anchor36","text":"Scattering gamma gamma &rarr; mu+ mu-. Code 265."},{"name":"double Info::bMPI()","link":"EventInformation.html#anchor86","text":"The impact parameter b assumed for the current collision when multiparton interactions are simulated. Is not expressed in any physical size (like fm), but only rescaled so that the average should be unity for minimum-bias events (meaning less than that for events with hard processes)."},{"name":"WeakBosonExchange:all","link":"ElectroweakProcesses.html#anchor9","text":"Common switch for the group of gamma^*/Z^0 or W^+- exchange between two fermions."},{"name":"Charmonium:states(3S1)","link":"OniaProcesses.html#anchor9","text":"The 3S1 charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"ExtraDimensionsLED:gg2DJgg","link":"ExtraDimensionalProcesses.html#anchor53","text":"Scatterings g g &rarr; (LED G*) &rarr; g g. Code 5030."},{"name":"void ParticleDataEntry::setAll(  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.)","link":"ParticleDataScheme.html#anchor96","text":"change all the properties of the particle associated with a given identity code."},{"name":"Tune:pp","link":"Tunes.html#anchor3","text":"Choice of tune to pp/ppbar data, mainly for the initial-state-radiation, multiparton-interactions and  beam-remnants aspects of PYTHIA. You should study the Settings::initTunePP(...) method to find exactly which are the settings for the respective tune. Note that all early tunes, including those done by the LHC collaborations based on tune 4C, imply the settings of Tune:ee = 3 , while the Monash 2013 tune and the further tunes based on it imply Tune:ee = 7. This is set automatically, and has to be overridden afterwards if not the wanted behaviour. reset all values that are affected by any of the pp/ppbar tunes to the default values. This option can be used on its own, but is also automatically used as a first step for either of the positive tune values below, to undo the effect of previous tune settings. no values are overwritten during the initial setup, step 2 above. Note that changing to 0 in the user code has no effect; if you want to restore the individual settings you should instead use -1. default used up to version 8.126, based on some early and primitive comparisons with data. 'Tune 1', default in 8.127 - 8.139, based on some data comparisons by Peter Skands. Largely but not wholly overlaps with the default option 0. 'Tune 2C', introduced with 8.140 Cor10a. It uses the CTEQ 6L1 PDF, and is intended to give good agreement with much of the published CDF data. 'Tune 2M', introduced with 8.140 Cor10a. It is uses the MRST LO** PDF, which has a momentum sum somewhat above unity, which is compensated by a smaller alpha_s than in the previous tune. Again it is intended to give good agreement with much of the published CDF data. 'Tune 4C', newer tune, introduced with 8.145 Cor10a. Starts out from tune 2C, but with a reduced cross section for diffraction, plus modified multiparton interactions parameters to give a higher and more rapidly increasing charged pseudorapidity plateau, for better agreement with some early key LHC numbers. See also the comparative study in Buc11. The starting point for many later tunes. 'Tune 4Cx', based on tune 4C, but using the x-dependent matter profile, MultipartonInteractions:bProfile = 4 and an increased MultipartonInteractions:pT0Ref Cor11. 'ATLAS MB Tune A2-CTEQ6L1', a minimum-bias tune based on tune 4Cx, but without rapidity-ordered spacelike emissions ATL12. Uses CTEQ 6L1, by default from LHAPDF. 'ATLAS MB Tune A2-MSTW2008LO', as above, but uses MSTW 2008 LO, by default from LHAPDF. 'ATLAS UE Tune AU2-CTEQ6L1', an underlying-event tune based on tune 4Cx, but without rapidity-ordered spacelike emissions ATL12. Uses CTEQ 6L1, by default from LHAPDF. 'ATLAS UE Tune AU2-MSTW2008LO', as above, but uses MSTW 2008 LO, by default from LHAPDF. 'ATLAS UE Tune AU2-CT10', as above, but uses CT 10, which is not currently implemented in PYTHIA, so you must link LHAPDF. 'ATLAS UE Tune AU2-MRST2007LO*', as above, but uses MRST 2007 LO*, by default from LHAPDF. 'ATLAS UE Tune AU2-MRST2007LO**', as above, but uses MRST 2007 LO**, by default from LHAPDF. the Monash 2013 tune by Peter Skands at al. Ska14 , to both e^+e^- and pp/pbarp data. The starting point for many later tunes. 'CMS UE Tune CUETP8S1-CTEQ6L1', an underlying-event tune based on tune 4C CMS14. Uses CTEQ 6L1, by default from LHAPDF. 'CMS UE Tune CUETP8S1-HERAPDF1.5LO', an underlying-event tune based on tune 4C CMS14. Uses HERAPDF1.5LO, which is not currently implemented in PYTHIA, so you must link LHAPDF. 'ATLAS Tune AZ', is tuned to the pT spectrum of the Z^/gamma^*0 boson in a set of rapidity bins ATL14. 'CMS Tune MonashStar', alias CUETP8M1-NNPDF2.3LO, an underlying-event tune based on the Monash 2013 tune. 'ATLAS A14 central tune with CTEQL1', a full-scale tune to most ATLAS jet and underlying-event observables ATL14a , starting out from the Monash 2013 tune. The following tunes 20 - 32 belong to the same group. 'ATLAS A14 central tune with MSTW2008LO', see above tune 19. 'ATLAS A14 central tune with NNPDF2.3LO', see above tune 19. Defines the center of the 23 - 32 variations, so would be a good choice if you only want to study one tune from the A14 family. 'ATLAS A14 central tune with HERAPDF1.5LO', see above tune 19. Uses HERAPDF1.5LO, which is not currently implemented in PYTHIA, so you must link LHAPDF. 'ATLAS A14 variation 1+' of tune 21. 'ATLAS A14 variation 1-' of tune 21. 'ATLAS A14 variation 2+' of tune 21. 'ATLAS A14 variation 2-' of tune 21. 'ATLAS A14 variation 3a+' of tune 21. 'ATLAS A14 variation 3a-' of tune 21. 'ATLAS A14 variation 3b+' of tune 21. 'ATLAS A14 variation 3b-' of tune 21. 'ATLAS A14 variation 3c+' of tune 21. 'ATLAS A14 variation 3c-' of tune 21. tune that includes close-packing of strings and hadron rescattering, Gaussian model for pT and flavour selection Fis16. Based on Monash tune, mainly tuned to pT spectra. tune that includes close-packing of strings and hadron rescattering, thermodynamical model for pT and flavour selection Fis16. Based on Monash tune, mainly tuned to pT spectra."},{"name":"double CoupSM::V2CKMsum(int id)","link":"StandardModelParameters.html#anchor44","text":"the sum of squared CKM mixing element that a given flavour can couple to, excluding the top quark and fourth generation. Is close to unity for the first two generations. Returns unity for the lepton-neutrino sector."},{"name":"vectorAMPERSANDlt;stringAMPERSANDgt; Settings::wvec(string key)","link":"SettingsScheme.html#anchor40","text":"return the current value(s) of the respective setting. If the name does not exist in the database, a value false , 0 , 0. , &quot; &quot; , or a vector of length 1 and value false , 0 , 0. or &quot; &quot; , respectively, is returned."},{"name":"TimeShower:QEDshowerByQ","link":"TimelikeShowers.html#anchor36","text":"Allow quarks to radiate photons, i.e. branchings q &rarr; q gamma ; on/off = true/false."},{"name":"ExcitedFermion:egm2eStar","link":"CompositenessProcesses.html#anchor7","text":"Scatterings e gamma &rarr; e^*. Code 4011."},{"name":"double Vec4::thetaXZ()","link":"FourVectors.html#anchor27","text":"the angle in the xz plane, in the range -pi through pi , with 0 along the +z axis."},{"name":"double ParticleDataEntry::resWidthOpen(int idSgn,  double mHat, int idInFlav = 0)","link":"ParticleDataScheme.html#anchor163","text":"special case of resWidth , where only open channels are included, but results are not stored in the normal decay table."},{"name":"ExtraDimensionsUnpart:monojet","link":"ExtraDimensionalProcesses.html#anchor70","text":"Common switch for the group of lowest-order U jet emission processes, i.e. the three ones below."},{"name":"double SigmaProcess::sigmaHat()","link":"SemiInternalProcesses.html#anchor7","text":"is the key method for cross section calculations and returns a cross section value, as described in the previous section. It is called when also a preliminary set of incoming flavours has been picked, in addition to the kinematical ones already available for sigmaKin. Typically sigmaHat is called inside a loop over all allowed incoming flavour combinations, stored in id1 and id2 , with fixed kinematics, as already illustrated above. The sum over the different flavour combinations provides the total cross section, while their relative size is used to make a selection of a specific incoming state."},{"name":"Merging:muRenInME","link":"NLOMerging.html#anchor5","text":"The fixed renormalisation scale used in the matrix element calculation. This information is needed if renormalisation scale variations in NLO merged results are attempted, for the same reason as factorisation scales might be required. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the SCALUP variable of the current LH event will be used instead."},{"name":"TimeShower:QEDshowerByL","link":"TimelikeShowers.html#anchor37","text":"Allow leptons to radiate photons, i.e. branchings l &rarr; l gamma ; on/off = true/false."},{"name":"HistAMPERSANDamp; Hist::operator+=(double f)","link":"Histograms.html#anchor27","text":""},{"name":"int Info::id2()","link":"EventInformation.html#anchor31","text":"the identities of the two partons coming in to the hard process."},{"name":"int Particle::acol()","link":"ParticleProperties.html#anchor8","text":"the colour and anticolour tags, Les Houches Accord Boo01 style (starting from tag 101 by default, see below). Note: in the preliminary implementation of colour sextets (exotic BSM particles) that exists since PYTHIA 8.150, a negative anticolour tag is interpreted as an additional positive colour tag, and vice versa."},{"name":"HiggsSM:all","link":"HiggsProcesses.html#anchor6","text":"Common switch for the group of Higgs production within the Standard Model."},{"name":"PhaseSpace:pTHatMin","link":"PhaseSpaceCuts.html#anchor3","text":"The minimum invariant pT."},{"name":"ContactInteractions:QCqqbar2qqbar","link":"CompositenessProcesses.html#anchor33","text":"Scatterings q qbar &rarr; q' qbar' including contact interactions. Code 4202."},{"name":"Check:levelParticleData","link":"ErrorChecks.html#anchor3","text":"The level of verbosity and checks of particle data, if switched on. minimal amount of checks, e.g. that no channels open. further warning if individual channels closed, except for resonances. also print branching-ratio-averaged threshold mass except for resonances. as 1, but include resonances in detailed checks. as 2, but include resonances in detailed checks."},{"name":"EventAMPERSAND Event::operator=(const EventAMPERSAND oldEvent)","link":"EventRecord.html#anchor17","text":"copies the input event record."},{"name":"SigmaElastic:phaseConst","link":"TotalCrossSections.html#anchor23","text":"The Coulomb term is taken to contain a phase factor exp(+- i alpha phi(t)) , with + for p p and - for pbar p , where phi(t) = - phaseConst - ln(-B t/2). This constant is model dependent Cah82."},{"name":"StringFlav:mesonNonetL1","link":"FlavourSelection.html#anchor44","text":"Switch on to include the pseudovector, scalar, pseudovector, and tensor nonet (L=1)."},{"name":"Zprime:anglesWW","link":"NewGaugeBosonProcesses.html#anchor29","text":"in the decay chain Z'^0 &rarr; W^+ W^- &rarr;f_1 fbar_2 f_3 fbar_4 the decay angular distributions is taken to be a mixture of two possible shapes. This parameter gives the fraction that is distributed as in Higgs h^0 &rarr; W^+ W^- (longitudinal bosons), with the remainder (by default all) is taken to be the same as for Z^0 &rarr; W^+ W^- (a mixture of transverse and longitudinal bosons)."},{"name":"bool ParticleDataEntry::isVisible()","link":"ParticleDataScheme.html#anchor129","text":"a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector."},{"name":"ClusterJet::analyze( const EventAMPERSAND event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0)","link":"EventAnalysis.html#anchor19","text":"performs a jet finding analysis, where is an object of the Event class, most likely the pythia.event one. is the cutoff joining scale, below which jets are joined. Is given in quadratic dimensionless quantities. Either yScale or pTscale must be set nonvanishing, and the larger of the two dictates the actual value. is the cutoff joining scale, below which jets are joined. Is given in linear quantities, such as pT or m depending on the measure used, but always in units of GeV. Either yScale or pTscale must be set nonvanishing, and the larger of the two dictates the actual value. the minimum number of jets to be reconstructed. If used, it can override the yScale and pTscale values. the maximum number of jets to be reconstructed. Is not used if below nJetMin. If used, it can override the yScale and pTscale values. Thus e.g. nJetMin = nJetMax = 3 can be used to reconstruct exactly 3 jets. If the routine returns false the analysis failed, e.g. because the number of particles was smaller than the minimum number of jets requested."},{"name":"void Vec4::rotaxis(double phi, double nx, double ny,  double nz)","link":"FourVectors.html#anchor64","text":"rotate the three-momentum with the azimuthal angle phi around the direction defined by the (n_x, n_y, n_z) three-vector."},{"name":"SUSY:qqbar2gluinogluino","link":"SUSYProcesses.html#anchor8","text":"Pair production of gluinos by quark-antiquark annihilation and t -channel squark exchange.  The cross section expression follows Fuk11 and include the possibility of non-minimal flavour violation through misalignment of quarks with squarks. Only the MFV case has been explicitly validated."},{"name":"void Particle::vProd(double xProd, double yProd,  double zProd, double tProd)","link":"ParticleProperties.html#anchor30","text":"sets the production vertex components in one go."},{"name":"double Particle::pol()","link":"ParticleProperties.html#anchor16","text":"the polarization/spin/helicity of a particle. Currently Pythia does not use this variable for internal operations, except for W/Z polarization states in weak showers, so its meaning is not uniquely defined. The LHA standard sets SPINUP to be the cosine of the angle between the spin vector and the 3-momentum of the decaying particle in the lab frame, i.e. restricted to be between +1 and -1. A more convenient choice could be the same quantity in the rest frame of the particle production, either the hard subprocess or the mother particle of a decay. Unknown or unpolarized particles should be assigned the value 9."},{"name":"SpaceShower:ecmRef","link":"SpacelikeShowers.html#anchor14","text":"The ecmRef reference energy scale introduced above."},{"name":"void RotBstMatrix::bstback(const Vec4AMPERSAND)","link":"FourVectors.html#anchor80","text":"boost with a beta = p/E or beta = -p/E , respectively."},{"name":"double Particle::mWidth()","link":"ParticleProperties.html#anchor72","text":""},{"name":"Diffraction:mPowPomP","link":"Diffraction.html#anchor27","text":"The p mass rescaling pace introduced above."},{"name":"SigmaProcess:Kfactor","link":"CouplingsAndScales.html#anchor4","text":"Multiply almost all cross sections by this common fix factor. Excluded are only unresolved processes, where cross sections are better set directly , and multiparton interactions, which have a separate K factor of their own. This degree of freedom is primarily intended for hadron colliders, and should not normally be used for e^+e^- annihilation processes."},{"name":"Merging:pickByFullP","link":"CKKWLMerging.html#anchor37","text":"If on, pick parton shower histories of the matrix element by the full shower  splitting kernels, including potential ME corrections and Jacobians from joined evolution measures."},{"name":"bool Info::isNonDiffractive()","link":"EventInformation.html#anchor22","text":"is the process the SoftQCD:nonDiffractive one, i.e. corresponding to the full inelastic nondiffractive part of the total cross section. (Note that a hard process, say Z^0 production, normally is nondiffractive, but this is not what we aim at here, and so the method would return false , unless the Z^0 had been generated as part of the MPI machinery for the SoftQCD:nonDiffractive component.)"},{"name":"int CellJet::size()","link":"EventAnalysis.html#anchor30","text":"gives the number of jets found, with jets numbered 0 through size() - 1 ,"},{"name":"double ParticleDataEntry::mRun(double mH)","link":"ParticleDataScheme.html#anchor137","text":"calculate the running quark mass at a hard scale mH. For other particles the on-shell mass is given."},{"name":"HiggsBSM:qqbar2H1bbbar","link":"HiggsProcesses.html#anchor65","text":"Scattering q qbar &rarr; h^0 b bbar via an s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1013."}];